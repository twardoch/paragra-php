Project Structure:
ğŸ“ paragra-php
â”œâ”€â”€ ğŸ“ config
â”‚   â”œâ”€â”€ ğŸ“ providers
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ catalog.json
â”‚   â”‚   â””â”€â”€ ğŸ“„ catalog.php
â”‚   â””â”€â”€ ğŸ“„ paragra.example.php
â”œâ”€â”€ ğŸ“ docs
â”‚   â”œâ”€â”€ ğŸ“„ api.md
â”‚   â”œâ”€â”€ ğŸ“„ architecture.md
â”‚   â”œâ”€â”€ ğŸ“„ configuration.md
â”‚   â”œâ”€â”€ ğŸ“„ examples.md
â”‚   â””â”€â”€ ğŸ“„ migration.md
â”œâ”€â”€ ğŸ“ examples
â”‚   â”œâ”€â”€ ğŸ“ config
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ askyoda.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ gemini_file_search.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ragie_cerebras.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ ragie_openai.php
â”‚   â”œâ”€â”€ ğŸ“ external-search
â”‚   â”‚   â””â”€â”€ ğŸ“„ twat_search_fallback.php
â”‚   â”œâ”€â”€ ğŸ“ media
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ chutes_answer_with_image.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ fal_answer_with_image.php
â”‚   â”œâ”€â”€ ğŸ“ vector-stores
â”‚   â”‚   â””â”€â”€ ğŸ“„ hybrid_pipeline.php
â”‚   â””â”€â”€ ğŸ“„ moderated_answer.php
â”œâ”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ Assistant
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaHostedAdapter.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaHostedResult.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ RagAnswer.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ RagAnswerer.php
â”‚   â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ PriorityPool.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ ProviderSpec.php
â”‚   â”œâ”€â”€ ğŸ“ Embedding
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CohereEmbeddingConfig.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CohereEmbeddingProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ EmbeddingProviderInterface.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ EmbeddingRequest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiEmbeddingConfig.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiEmbeddingProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiEmbeddingConfig.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiEmbeddingProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ VoyageEmbeddingConfig.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ VoyageEmbeddingProvider.php
â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â””â”€â”€ ğŸ“„ ConfigurationException.php
â”‚   â”œâ”€â”€ ğŸ“ ExternalSearch
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ExternalSearchException.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ExternalSearchRetrieverInterface.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ TwatSearchRetriever.php
â”‚   â”œâ”€â”€ ğŸ“ Llm
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaClient.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaResponse.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChatRequestOptions.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChatResponse.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChatUsage.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ NeuronAiAdapter.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiChatClient.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiChatConfig.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ PromptBuilder.php
â”‚   â”œâ”€â”€ ğŸ“ Media
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChutesImageProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ FalImageProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ImageOperationInterface.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ MediaException.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ MediaRequest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ MediaResult.php
â”‚   â”œâ”€â”€ ğŸ“ Moderation
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ModerationException.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ModerationResult.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ModeratorInterface.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ NullModerator.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ OpenAiModerator.php
â”‚   â”œâ”€â”€ ğŸ“ Pipeline
â”‚   â”‚   â””â”€â”€ ğŸ“„ HybridRetrievalPipeline.php
â”‚   â”œâ”€â”€ ğŸ“ Planner
â”‚   â”‚   â””â”€â”€ ğŸ“„ PoolBuilder.php
â”‚   â”œâ”€â”€ ğŸ“ ProviderCatalog
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CapabilityMap.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderDiscovery.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ ProviderSummary.php
â”‚   â”œâ”€â”€ ğŸ“ Providers
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AbstractProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiFileSearchProvider.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderFactory.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderInterface.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ RagieProvider.php
â”‚   â”œâ”€â”€ ğŸ“ ReferenceCatalog
â”‚   â”‚   â””â”€â”€ ğŸ“„ ProviderCatalogBuilder.php
â”‚   â”œâ”€â”€ ğŸ“ Response
â”‚   â”‚   â””â”€â”€ ğŸ“„ UnifiedResponse.php
â”‚   â”œâ”€â”€ ğŸ“ Router
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ FallbackStrategy.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ KeyRotator.php
â”‚   â”œâ”€â”€ ğŸ“ Support
â”‚   â”‚   â””â”€â”€ ğŸ“„ ExceptionEnhancer.php
â”‚   â”œâ”€â”€ ğŸ“ Util
â”‚   â”‚   â””â”€â”€ ğŸ“„ ConfigValidator.php
â”‚   â”œâ”€â”€ ğŸ“ VectorStore
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChromaVectorStore.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiFileSearchVectorStore.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ PineconeVectorStore.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ QdrantVectorStore.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ VectorNamespace.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ VectorStoreInterface.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ WeaviateVectorStore.php
â”‚   â””â”€â”€ ğŸ“„ ParaGra.php
â”œâ”€â”€ ğŸ“ tests
â”‚   â”œâ”€â”€ ğŸ“ Assistant
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaHostedAdapterTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ RagAnswererTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ RagAnswerTest.php
â”‚   â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ PriorityPoolTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ ProviderSpecTest.php
â”‚   â”œâ”€â”€ ğŸ“ Embedding
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CohereEmbeddingConfigTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CohereEmbeddingProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ EmbeddingRequestTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiEmbeddingConfigTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiEmbeddingProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiEmbeddingConfigTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiEmbeddingProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ VoyageEmbeddingConfigTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ VoyageEmbeddingProviderTest.php
â”‚   â”œâ”€â”€ ğŸ“ ExternalSearch
â”‚   â”‚   â””â”€â”€ ğŸ“„ TwatSearchRetrieverTest.php
â”‚   â”œâ”€â”€ ğŸ“ Llm
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaClientTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaResponseTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ NeuronAiAdapterTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiChatClientTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ OpenAiChatConfigTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ PromptBuilderTest.php
â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â””â”€â”€ ğŸ“„ SpyLogger.php
â”‚   â”œâ”€â”€ ğŸ“ Media
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChutesImageProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ FalImageProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ MediaRequestTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ MediaResultTest.php
â”‚   â”œâ”€â”€ ğŸ“ Moderation
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ NullModeratorTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ OpenAiModeratorTest.php
â”‚   â”œâ”€â”€ ğŸ“ Pipeline
â”‚   â”‚   â””â”€â”€ ğŸ“„ HybridRetrievalPipelineTest.php
â”‚   â”œâ”€â”€ ğŸ“ Planner
â”‚   â”‚   â””â”€â”€ ğŸ“„ PoolBuilderTest.php
â”‚   â”œâ”€â”€ ğŸ“ ProviderCatalog
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ CapabilityMapTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderDiscoveryTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderSummaryTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ SyncProviderCatalogTest.php
â”‚   â”œâ”€â”€ ğŸ“ Providers
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AbstractProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ AskYodaProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiFileSearchProviderTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ProviderFactoryTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ RagieProviderTest.php
â”‚   â”œâ”€â”€ ğŸ“ ReferenceCatalog
â”‚   â”‚   â””â”€â”€ ğŸ“„ ProviderCatalogBuilderTest.php
â”‚   â”œâ”€â”€ ğŸ“ Response
â”‚   â”‚   â””â”€â”€ ğŸ“„ UnifiedResponseTest.php
â”‚   â”œâ”€â”€ ğŸ“ Router
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ FallbackStrategyTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ KeyRotatorTest.php
â”‚   â”œâ”€â”€ ğŸ“ Support
â”‚   â”‚   â””â”€â”€ ğŸ“„ ExceptionEnhancerTest.php
â”‚   â”œâ”€â”€ ğŸ“ Util
â”‚   â”‚   â””â”€â”€ ğŸ“„ ConfigValidatorTest.php
â”‚   â”œâ”€â”€ ğŸ“ VectorStore
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ChromaVectorStoreTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ GeminiFileSearchVectorStoreTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ PineconeVectorStoreTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ QdrantVectorStoreTest.php
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ VectorNamespaceTest.php
â”‚   â”‚   â””â”€â”€ ğŸ“„ WeaviateVectorStoreTest.php
â”‚   â”œâ”€â”€ ğŸ“„ bootstrap.php
â”‚   â””â”€â”€ ğŸ“„ ParaGraTest.php
â”œâ”€â”€ ğŸ“ tools
â”‚   â”œâ”€â”€ ğŸ“„ pool_builder.php
â”‚   â”œâ”€â”€ ğŸ“„ provider_catalog.php
â”‚   â””â”€â”€ ğŸ“„ sync_provider_catalog.php
â”œâ”€â”€ ğŸ“ vendor
â”‚   â”œâ”€â”€ ğŸ“ amphp
â”‚   â”‚   â”œâ”€â”€ ğŸ“ amp
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Future
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ byte-stream
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Base64
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Compression
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ parallel
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Context
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ipc
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Worker
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ parser
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ pipeline
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ windows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Posix
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Windows
â”‚   â”‚   â”œâ”€â”€ ğŸ“ serialization
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ SocketAddress
â”‚   â”‚   â””â”€â”€ ğŸ“ sync
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”œâ”€â”€ ğŸ“ brick
â”‚   â”‚   â””â”€â”€ ğŸ“ math
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”‚               â””â”€â”€ ğŸ“ Calculator
â”‚   â”œâ”€â”€ ğŸ“ clue
â”‚   â”‚   â””â”€â”€ ğŸ“ ndjson-react
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ composer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ pcre
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ PHPStan
â”‚   â”‚   â”œâ”€â”€ ğŸ“ semver
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚   â””â”€â”€ ğŸ“ xdebug-handler
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ danog
â”‚   â”‚   â””â”€â”€ ğŸ“ advanced-json-rpc
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”œâ”€â”€ ğŸ“ daverandom
â”‚   â”‚   â””â”€â”€ ğŸ“ libdns
â”‚   â”‚       â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Decoder
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Encoder
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Packets
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Records
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ TypeDefinitions
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Types
â”‚   â”‚       â””â”€â”€ ğŸ“ tools
â”‚   â”œâ”€â”€ ğŸ“ dg
â”‚   â”‚   â””â”€â”€ ğŸ“ bypass-finals
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ dnoegel
â”‚   â”‚   â””â”€â”€ ğŸ“ php-xdg-base-dir
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ doctrine
â”‚   â”‚   â””â”€â”€ ğŸ“ deprecations
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ PHPUnit
â”‚   â”œâ”€â”€ ğŸ“ evenement
â”‚   â”‚   â””â”€â”€ ğŸ“ evenement
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ felixfbecker
â”‚   â”‚   â””â”€â”€ ğŸ“ language-server-protocol
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ fidry
â”‚   â”‚   â””â”€â”€ ğŸ“ cpu-core-counter
â”‚   â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Executor
â”‚   â”‚           â””â”€â”€ ğŸ“ Finder
â”‚   â”œâ”€â”€ ğŸ“ firebase
â”‚   â”‚   â””â”€â”€ ğŸ“ php-jwt
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ friendsofphp
â”‚   â”‚   â””â”€â”€ ğŸ“ php-cs-fixer
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚           â”œâ”€â”€ ğŸ“ ConfigurationException
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ FixReport
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ListSetsReport
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ SelfUpdate
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Differ
â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Documentation
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Error
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Fixer
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Alias
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ArrayNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ AttributeNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Basic
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Casing
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ CastNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassUsage
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstantNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ControlStructure
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DoctrineAnnotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FunctionNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Import
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ LanguageConstruct
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ListNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NamespaceNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Naming
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Phpdoc
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpTag
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpUnit
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ReturnNotation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Semicolon
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Strict
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ StringNotation
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Whitespace
â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerConfiguration
â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerDefinition
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Linter
â”‚   â”‚           â”œâ”€â”€ ğŸ“ RuleSet
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Sets
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Parallel
â”‚   â”‚           â””â”€â”€ ğŸ“ Tokenizer
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Analysis
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Processor
â”‚   â”‚               â””â”€â”€ ğŸ“ Transformer
â”‚   â”œâ”€â”€ ğŸ“ google
â”‚   â”‚   â”œâ”€â”€ ğŸ“ auth
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Credentials
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ CredentialSource
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ ExecutableHandler
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ HttpHandler
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Middleware
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cloud-ai-platform
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ metadata
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Artifact
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ BatchMigrateResourcesOperationMetadata
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ BatchPredictionJob
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ BatchReadFeatureValuesRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ DeployedIndexAuthConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExamplesOverride
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Execution
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExplanationMetadata
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ InputMetadata
â”‚   â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Visualization
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExplanationMetadataOverride
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExportFeatureValuesRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExportModelOperationMetadata
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ExportModelRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Feature
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ MonitoringStatsAnomaly
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ FeatureNoiseSigma
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Featurestore
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ OnlineServingConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ FeaturestoreMonitoringConfig
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ ImportFeaturesAnalysis
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ FeatureValue
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Gapic
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ImportFeatureValuesRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Index
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ IndexDatapoint
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Measurement
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ MetadataSchema
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ MetadataStore
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ MigratableResource
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ DataLabelingDataset
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ MigrateResourceRequest
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ MigrateDataLabelingDatasetConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Model
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ ExportFormat
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelDeploymentMonitoringBigQueryTable
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelDeploymentMonitoringJob
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelEvaluation
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelEvaluationSlice
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelMonitoringAlertConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelMonitoringObjectiveConfig
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ ExplanationConfig
â”‚   â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ ExplanationBaseline
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelMonitoringStatsAnomalies
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ModelSourceInfo
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ NasJobOutput
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ NasJobSpec
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ MultiTrialAlgorithmSpec
â”‚   â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ MetricSpec
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ NasTrial
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ NearestNeighborSearchOperationMetadata
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ RecordError
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ PipelineJob
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ RuntimeConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ PipelineTaskDetail
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ PipelineTaskExecutorDetail
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ReadFeatureValuesResponse
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ EntityView
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ ReadTensorboardUsageResponse
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ resources
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ SampleConfig
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ SamplingStrategy
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ SearchDataItemsRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ SearchModelDeploymentMonitoringStatsAnomaliesRequest
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Study
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ StudySpec
â”‚   â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ MetricSpec
â”‚   â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ ParameterSpec
â”‚   â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ ConditionalParameterSpec
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ TensorboardTimeSeries
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Trial
â”‚   â”‚   â”œâ”€â”€ ğŸ“ common-protos
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ metadata
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cloud
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Location
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Google
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Iam
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Iam
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Rpc
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Context
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ BackendRule
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Billing
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Distribution
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ BucketOptions
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ FieldInfo
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ LabelDescriptor
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ MethodSettings
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ MetricDescriptor
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ MetricDescriptorMetadata
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Monitoring
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Property
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ PythonSettings
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ ResourceDescriptor
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Cloud
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Iam
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ AuditConfigDelta
â”‚   â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ AuditLogConfig
â”‚   â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ BindingDelta
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Location
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Iam
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ V1
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Logging
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Rpc
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ BadRequest
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Context
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ AttributeContext
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Help
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ PreconditionFailure
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ QuotaFailure
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ PhoneNumber
â”‚   â”‚   â”œâ”€â”€ ğŸ“ gax
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ metadata
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ ApiCore
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Testing
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Google
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ ApiCore
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Tests
â”‚   â”‚   â”‚   â”‚               â””â”€â”€ ğŸ“ Unit
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Middleware
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Options
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ TransportOptions
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ ResourceTemplate
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Testing
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Transport
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Grpc
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Rest
â”‚   â”‚   â”œâ”€â”€ ğŸ“ grpc-gcp
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ cloudprober
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ bins
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ opt
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ grpc_gpc_prober
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ doc
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ generated
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ GPBMetadata
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Grpc
â”‚   â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ Gcp
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ third_party
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ googleapis
â”‚   â”‚   â”œâ”€â”€ ğŸ“ longrunning
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ metadata
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Longrunning
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ ApiCore
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ LongRunning
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Gapic
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ LongRunning
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Client
â”‚   â”‚   â”‚           â”œâ”€â”€ ğŸ“ Gapic
â”‚   â”‚   â”‚           â””â”€â”€ ğŸ“ resources
â”‚   â”‚   â””â”€â”€ ğŸ“ protobuf
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Google
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Protobuf
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Field
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ DescriptorProto
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ EnumDescriptorProto
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ ExtensionRangeOptions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FeatureSet
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ VisibilityFeature
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FeatureSetDefaults
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FieldDescriptorProto
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FieldOptions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FileOptions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ GeneratedCodeInfo
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ MethodOptions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ SourceCodeInfo
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ UninterpretedOption
â”‚   â”‚           â””â”€â”€ ğŸ“ GPBMetadata
â”‚   â”‚               â””â”€â”€ ğŸ“ Google
â”‚   â”‚                   â””â”€â”€ ğŸ“ Protobuf
â”‚   â”‚                       â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ google-gemini-php
â”‚   â”‚   â””â”€â”€ ğŸ“ client
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â”œâ”€â”€ ğŸ“ art
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Data
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Foundation
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Requests
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ CachedContents
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ GenerativeModel
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ CachedContents
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ GenerativeModel
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Models
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Testing
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ FunctionCalls
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Requests
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Concerns
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ Fixtures
â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ CachedContents
â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ GenerativeModel
â”‚   â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ Models
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Transporters
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ DTOs
â”‚   â”‚       â””â”€â”€ ğŸ“ tests
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ CachedContents
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ GenerativeModel
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Models
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Testing
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â””â”€â”€ ğŸ“ Transporters
â”‚   â”œâ”€â”€ ğŸ“ grpc
â”‚   â”‚   â””â”€â”€ ğŸ“ grpc
â”‚   â”‚       â”œâ”€â”€ ğŸ“ etc
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ lib
â”‚   â”‚               â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ guzzlehttp
â”‚   â”‚   â”œâ”€â”€ ğŸ“ guzzle
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Cookie
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Handler
â”‚   â”‚   â”œâ”€â”€ ğŸ“ promises
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ psr7
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ Exception
â”‚   â”œâ”€â”€ ğŸ“ inspector-apm
â”‚   â”‚   â””â”€â”€ ğŸ“ inspector-php
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Models
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Partials
â”‚   â”‚           â””â”€â”€ ğŸ“ Transports
â”‚   â”œâ”€â”€ ğŸ“ kelunik
â”‚   â”‚   â””â”€â”€ ğŸ“ certificate
â”‚   â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ league
â”‚   â”‚   â”œâ”€â”€ ğŸ“ uri
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ UriTemplate
â”‚   â”‚   â””â”€â”€ ğŸ“ uri-interfaces
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Idna
â”‚   â”‚       â”œâ”€â”€ ğŸ“ IPv4
â”‚   â”‚       â”œâ”€â”€ ğŸ“ IPv6
â”‚   â”‚       â””â”€â”€ ğŸ“ KeyValuePair
â”‚   â”œâ”€â”€ ğŸ“ myclabs
â”‚   â”‚   â””â”€â”€ ğŸ“ deep-copy
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ DeepCopy
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Matcher
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Reflection
â”‚   â”‚               â”œâ”€â”€ ğŸ“ TypeFilter
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Date
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Spl
â”‚   â”‚               â””â”€â”€ ğŸ“ TypeMatcher
â”‚   â”œâ”€â”€ ğŸ“ netresearch
â”‚   â”‚   â””â”€â”€ ğŸ“ jsonmapper
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ JsonMapper
â”‚   â”œâ”€â”€ ğŸ“ neuron-core
â”‚   â”‚   â””â”€â”€ ğŸ“ neuron-ai
â”‚   â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Chat
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Attachments
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ History
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Messages
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Evaluation
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Make
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Stubs
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Evaluation
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assertions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Dataset
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Discovery
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Runner
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚           â”œâ”€â”€ ğŸ“ MCP
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Observability
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Events
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Providers
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Anthropic
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ AWS
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Deepseek
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Gemini
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ HuggingFace
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Mistral
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Ollama
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ OpenAI
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ XAI
â”‚   â”‚           â”œâ”€â”€ ğŸ“ RAG
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DataLoader
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Embeddings
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PostProcessor
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PreProcessor
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Retrieval
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Splitter
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ VectorStore
â”‚   â”‚           â”œâ”€â”€ ğŸ“ StructuredOutput
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Deserializer
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Validation
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Rules
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Tools
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Toolkits
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ AWS
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Calculator
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Calendar
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Jina
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ MySQL
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ PGSQL
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Supadata
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Tavily
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Zep
â”‚   â”‚           â””â”€â”€ ğŸ“ Workflow
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Exporter
â”‚   â”‚               â””â”€â”€ ğŸ“ Persistence
â”‚   â”œâ”€â”€ ğŸ“ nikic
â”‚   â”‚   â””â”€â”€ ğŸ“ php-parser
â”‚   â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”‚           â””â”€â”€ ğŸ“ PhpParser
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚               â”œâ”€â”€ ğŸ“ ErrorHandler
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ TokenEmulator
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ ğŸ“ AssignOp
â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚               â”‚   â”‚   â””â”€â”€ ğŸ“ Cast
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚               â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚               â”‚   â”‚   â””â”€â”€ ğŸ“ MagicConst
â”‚   â”‚               â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚               â”‚       â””â”€â”€ ğŸ“ TraitUseAdaptation
â”‚   â”‚               â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚               â””â”€â”€ ğŸ“ PrettyPrinter
â”‚   â”œâ”€â”€ ğŸ“ openai-php
â”‚   â”‚   â””â”€â”€ ğŸ“ client
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Actions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Conversations
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTuning
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Moderations
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Transporter
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assistants
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Audio
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Streaming
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Batches
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Chat
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Completions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Containers
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Objects
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Conversations
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Objects
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ MessageTypes
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Edits
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Embeddings
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTunes
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTuning
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Images
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Meta
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Models
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Moderations
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Realtime
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Session
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Tools
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ TranscriptionSession
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Format
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Input
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ CodeInterpreter
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ ComputerAction
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Streaming
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Tool
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ToolChoice
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Threads
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Delta
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Runs
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Steps
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Delta
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ VectorStores
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ FileBatches
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Search
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Testing
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Requests
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Fixtures
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Assistants
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Audio
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Batches
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Chat
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Completions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Containers
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Conversations
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Edits
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Embeddings
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FineTunes
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FineTuning
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Images
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Models
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Moderations
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Realtime
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Threads
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Runs
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ Steps
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ VectorStores
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ Search
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Transporters
â”‚   â”‚           â””â”€â”€ ğŸ“ ValueObjects
â”‚   â”‚               â””â”€â”€ ğŸ“ Transporter
â”‚   â”œâ”€â”€ ğŸ“ phar-io
â”‚   â”‚   â”œâ”€â”€ ğŸ“ manifest
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ values
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ xml
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ tools
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ php-cs-fixer.d
â”‚   â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ constraints
â”‚   â”‚           â””â”€â”€ ğŸ“ exceptions
â”‚   â”œâ”€â”€ ğŸ“ php-http
â”‚   â”‚   â”œâ”€â”€ ğŸ“ discovery
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Composer
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Strategy
â”‚   â”‚   â””â”€â”€ ğŸ“ multipart-stream-builder
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ phpdocumentor
â”‚   â”‚   â”œâ”€â”€ ğŸ“ reflection-common
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ reflection-docblock
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Tags
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Factory
â”‚   â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Reference
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â””â”€â”€ ğŸ“ type-resolver
â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ PseudoTypes
â”‚   â”‚           â””â”€â”€ ğŸ“ Types
â”‚   â”œâ”€â”€ ğŸ“ phpstan
â”‚   â”‚   â”œâ”€â”€ ğŸ“ phpdoc-parser
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ast
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ ConstExpr
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpDoc
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Printer
â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan
â”‚   â”‚       â””â”€â”€ ğŸ“ conf
â”‚   â”œâ”€â”€ ğŸ“ phpunit
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-code-coverage
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Data
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Html
â”‚   â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Renderer
â”‚   â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ Template
â”‚   â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ css
â”‚   â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ icons
â”‚   â”‚   â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ js
â”‚   â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ StaticAnalysis
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestStatus
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Util
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-file-iterator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-invoker
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-text-template
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ php-timer
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â””â”€â”€ ğŸ“ phpunit
â”‚   â”‚       â”œâ”€â”€ ğŸ“ schema
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Dispatcher
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Emitter
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Events
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Application
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ HookMethod
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Lifecycle
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Outcome
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ TestDouble
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ TestRunner
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Telemetry
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ TestData
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Framework
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assert
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Attributes
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Constraint
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Boolean
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cardinality
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Equality
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Filesystem
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Math
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Object
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ String
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Traversable
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Incomplete
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ ObjectEquals
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Skipped
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ MockObject
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Generator
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ templates
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Interface
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ PropertyHook
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Rule
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Stub
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ TestRunner
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ templates
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestStatus
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ JUnit
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ TeamCity
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Metadata
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Version
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Baseline
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DeprecationCollector
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Extension
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ GarbageCollection
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ HookMethod
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PHPT
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ templates
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ResultCache
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”œâ”€â”€ ğŸ“ TextUI
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Commands
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Configuration
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ CodeCoverage
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Migration
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Migrations
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ SchemaDetector
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Validator
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Default
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ ProgressPrinter
â”‚   â”‚           â”‚       â”‚       â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Printer
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â””â”€â”€ ğŸ“ Util
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Http
â”‚   â”‚               â”œâ”€â”€ ğŸ“ PHP
â”‚   â”‚               â””â”€â”€ ğŸ“ Xml
â”‚   â”œâ”€â”€ ğŸ“ psr
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ container
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-client
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-factory
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ http-message
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ log
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ simple-cache
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ ragie
â”‚   â”‚   â””â”€â”€ ğŸ“ ragie-php
â”‚   â”‚       â”œâ”€â”€ ğŸ“ benchmarks
â”‚   â”‚       â”œâ”€â”€ ğŸ“ dev
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Coverage
â”‚   â”‚       â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Assistant
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Benchmark
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Examples
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Http
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Llm
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Metrics
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Moderation
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Ragie
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ lib
â”‚   â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ test
â”‚   â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ Model
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Retry
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Validation
â”‚   â”‚       â””â”€â”€ ğŸ“ vendor
â”‚   â”‚           â”œâ”€â”€ ğŸ“ amphp
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ amp
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Future
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ byte-stream
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Base64
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Compression
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ parallel
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Context
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ipc
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Worker
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ parser
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ pipeline
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ windows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Posix
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Windows
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ serialization
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ SocketAddress
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ sync
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚           â”œâ”€â”€ ğŸ“ clue
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ ndjson-react
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ composer
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 0255826d
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ phpDocumentor-ReflectionDocBlock-94f8051
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Tags
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 033e0a08
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 0a26529e
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 14388646
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 17b201e8
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ PHP-CS-Fixer-PHP-CS-Fixer-a8d1558
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ ConfigurationException
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ SelfUpdate
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Differ
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Documentation
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Error
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Fixer
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Alias
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ArrayNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ AttributeNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Basic
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Casing
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ CastNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassUsage
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstantNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ControlStructure
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ DoctrineAnnotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ FunctionNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Import
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ LanguageConstruct
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ListNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NamespaceNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Naming
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Phpdoc
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpTag
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpUnit
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ReturnNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Semicolon
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Strict
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ StringNotation
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Whitespace
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerConfiguration
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ FixerDefinition
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Linter
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ RuleSet
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Sets
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Parallel
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Tokenizer
â”‚   â”‚           â”‚   â”‚               â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚           â”‚   â”‚               â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚               â”œâ”€â”€ ğŸ“ Processor
â”‚   â”‚           â”‚   â”‚               â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚               â””â”€â”€ ğŸ“ Transformer
â”‚   â”‚           â”‚   â”‚                   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 1a34818a
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 1bfda51b
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 1ecf1afe
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 24718d76
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 25fd5263
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 2ac29b77
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 30fd0943
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 32de3a4d
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 41b2b4ef
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 43a3352f
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 4c268d9d
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan-phpstan-2770dcd
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ conf
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 586fef72
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ phpstan-phpdoc-parser-1e0cd53
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Ast
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstExpr
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpDoc
â”‚   â”‚           â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚   â”‚           â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Printer
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 682705a0
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 6e905185
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 73333a09
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 7a1e38e4
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 7e879b1f
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ phpDocumentor-TypeResolver-679e3ce
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ PseudoTypes
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ Types
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 808a603a
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 8091d750
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 87d5ca8b
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 94c8c8ba
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ 95302519
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-type-462699a
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚           â”œâ”€â”€ ğŸ“ exception
â”‚   â”‚           â”‚   â”‚           â””â”€â”€ ğŸ“ type
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ a00d52a4
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ ada3b2a4
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ b0319bdd
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ bbe2c5ec
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-recursion-context-47e3421
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ bdb4ce1a
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ d7c0a4ec
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ sebastianbergmann-version-c51fa83
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ dfae04b7
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ e74f709e
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ e7dbc155
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ fcf78585
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ pcre
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ PHPStan
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ semver
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ xdebug-handler
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ danog
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ advanced-json-rpc
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”‚           â”œâ”€â”€ ğŸ“ daverandom
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ libdns
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ Decoder
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ Encoder
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ Packets
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ Records
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ TypeDefinitions
â”‚   â”‚           â”‚       â”‚       â””â”€â”€ ğŸ“ Types
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ tools
â”‚   â”‚           â”œâ”€â”€ ğŸ“ dnoegel
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ php-xdg-base-dir
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ doctrine
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ deprecations
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ PHPUnit
â”‚   â”‚           â”œâ”€â”€ ğŸ“ evenement
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ evenement
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ felixfbecker
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ language-server-protocol
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ fidry
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ cpu-core-counter
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Executor
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Finder
â”‚   â”‚           â”œâ”€â”€ ğŸ“ friendsofphp
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ php-cs-fixer
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Cache
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ ConfigurationException
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Console
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ FixReport
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ListSetsReport
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ SelfUpdate
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Differ
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Documentation
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Error
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Fixer
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Alias
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ArrayNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ AttributeNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Basic
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Casing
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ CastNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ClassUsage
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ConstantNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ControlStructure
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ DoctrineAnnotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ FunctionNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Import
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ LanguageConstruct
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ListNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ NamespaceNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Naming
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Phpdoc
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpTag
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ PhpUnit
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ReturnNotation
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Semicolon
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Strict
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ StringNotation
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Whitespace
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FixerConfiguration
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ FixerDefinition
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Linter
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ RuleSet
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Sets
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Parallel
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Tokenizer
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Analysis
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Processor
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ Transformer
â”‚   â”‚           â”œâ”€â”€ ğŸ“ guzzlehttp
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ guzzle
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Cookie
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Handler
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ promises
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ psr7
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”œâ”€â”€ ğŸ“ kelunik
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ certificate
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ league
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ uri
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ UriTemplate
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ uri-interfaces
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Idna
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ IPv4
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ IPv6
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ KeyValuePair
â”‚   â”‚           â”œâ”€â”€ ğŸ“ myclabs
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ deep-copy
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ DeepCopy
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Matcher
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Reflection
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ TypeFilter
â”‚   â”‚           â”‚               â”‚   â”œâ”€â”€ ğŸ“ Date
â”‚   â”‚           â”‚               â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Spl
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ TypeMatcher
â”‚   â”‚           â”œâ”€â”€ ğŸ“ netresearch
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ jsonmapper
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ JsonMapper
â”‚   â”‚           â”œâ”€â”€ ğŸ“ nikic
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ php-parser
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ PhpParser
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Comment
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ ErrorHandler
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ TokenEmulator
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚           â”‚               â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚           â”‚               â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚           â”‚               â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚           â”‚               â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ PrettyPrinter
â”‚   â”‚           â”œâ”€â”€ ğŸ“ openai-php
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ client
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Actions
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Conversations
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Contracts
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTuning
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Moderations
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Transporter
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Exceptions
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assistants
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Audio
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Streaming
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Batches
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Chat
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Completions
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Containers
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Objects
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Conversations
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Objects
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Edits
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Embeddings
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTunes
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ FineTuning
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Images
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Meta
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Models
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Moderations
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Realtime
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Session
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Tools
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ TranscriptionSession
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Format
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Input
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Streaming
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Tool
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ ToolChoice
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Threads
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messages
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Runs
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ VectorStores
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ FileBatches
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Files
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ Search
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Testing
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Enums
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Requests
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Responses
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Concerns
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ Fixtures
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Transporters
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ ValueObjects
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ Transporter
â”‚   â”‚           â”œâ”€â”€ ğŸ“ phar-io
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ manifest
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ values
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ xml
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ tools
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ php-cs-fixer.d
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ constraints
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”œâ”€â”€ ğŸ“ php-http
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ discovery
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Composer
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Strategy
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ multipart-stream-builder
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ phpdocumentor
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ reflection-common
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ .github
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ workflows
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ reflection-docblock
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ DocBlock
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Tags
â”‚   â”‚           â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Factory
â”‚   â”‚           â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚           â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Reference
â”‚   â”‚           â”‚   â”‚       â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ type-resolver
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ PseudoTypes
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Types
â”‚   â”‚           â”œâ”€â”€ ğŸ“ phpstan
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ phpdoc-parser
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Ast
â”‚   â”‚           â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ ConstExpr
â”‚   â”‚           â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ NodeVisitor
â”‚   â”‚           â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpDoc
â”‚   â”‚           â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Doctrine
â”‚   â”‚           â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Lexer
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Printer
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ phpstan
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ conf
â”‚   â”‚           â”œâ”€â”€ ğŸ“ phpunit
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ php-code-coverage
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Data
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ Html
â”‚   â”‚           â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Renderer
â”‚   â”‚           â”‚   â”‚       â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ StaticAnalysis
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ TestStatus
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Util
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ php-file-iterator
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ php-invoker
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ php-text-template
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ php-timer
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ phpunit
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ schema
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Dispatcher
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Emitter
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Events
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Application
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ TestRunner
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Telemetry
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ TestSuite
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Framework
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Assert
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Attributes
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Constraint
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Boolean
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cardinality
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Equality
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Filesystem
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Math
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Object
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Operator
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ String
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Traversable
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Incomplete
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ ObjectEquals
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Skipped
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ MockObject
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Generator
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Runtime
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ TestSize
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ TestStatus
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Logging
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ JUnit
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ TeamCity
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Metadata
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Api
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Parser
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Annotation
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Version
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ Runner
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Baseline
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Extension
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Filter
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ GarbageCollection
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ ResultCache
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ TestResult
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ Subscriber
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”œâ”€â”€ ğŸ“ TextUI
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Commands
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Configuration
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Value
â”‚   â”‚           â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Xml
â”‚   â”‚           â”‚           â”‚   â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚           â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Default
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â”œâ”€â”€ ğŸ“ Printer
â”‚   â”‚           â”‚           â”‚       â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â”‚       â””â”€â”€ ğŸ“ TestDox
â”‚   â”‚           â”‚           â”‚           â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ Util
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Http
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ PHP
â”‚   â”‚           â”‚               â”‚   â””â”€â”€ ğŸ“ Template
â”‚   â”‚           â”‚               â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ Xml
â”‚   â”‚           â”œâ”€â”€ ğŸ“ psr
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ container
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ http-client
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ http-factory
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ http-message
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ log
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ simple-cache
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ ralouphie
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ getallheaders
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ react
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ child-process
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Model
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Protocol
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Query
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Resolver
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ event-loop
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Tick
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Timer
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ promise
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ stream
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ revolt
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ event-loop
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ EventLoop
â”‚   â”‚           â”‚               â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚           â”‚               â””â”€â”€ ğŸ“ Internal
â”‚   â”‚           â”œâ”€â”€ ğŸ“ sebastian
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ cli-parser
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ code-unit
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ code-unit-reverse-lookup
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ comparator
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ complexity
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Complexity
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Visitor
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ diff
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ environment
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ exporter
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ global-state
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ lines-of-code
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ object-enumerator
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ object-reflector
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ recursion-context
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ type
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ exception
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ type
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ spatie
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ array-to-xml
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ symfony
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ console
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ CI
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ CommandLoader
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Completion
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ DataCollector
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Descriptor
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ EventListener
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Helper
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Input
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Logger
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Question
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ bin
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ SignalRegistry
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Style
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Tester
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ deprecation-contracts
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher-contracts
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ filesystem
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ finder
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Comparator
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Iterator
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ options-resolver
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-ctype
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-grapheme
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-normalizer
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ ğŸ“ stubs
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-mbstring
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-php80
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-php81
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ polyfill-php84
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Pipes
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ service-contracts
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ ğŸ“ Test
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ stopwatch
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ string
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Inflector
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ data
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ Slugger
â”‚   â”‚           â”œâ”€â”€ ğŸ“ theseer
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ tokenizer
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ vimeo
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ psalm
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ dictionaries
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ autogen
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ override
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ annotating_code
â”‚   â”‚           â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ type_syntax
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ contributing
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ manipulating_code
â”‚   â”‚           â”‚       â”‚   â”œâ”€â”€ ğŸ“ running_psalm
â”‚   â”‚           â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ issues
â”‚   â”‚           â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ plugins
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ security_analysis
â”‚   â”‚           â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚           â”‚       â”‚   â””â”€â”€ ğŸ“ Psalm
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ CodeLocation
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Algebra
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Codebase
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ DataFlow
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Diff
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ ExecutionEnvironment
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ FileManipulation
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Fork
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Json
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ LanguageServer
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpTraverser
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpVisitor
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PluginManager
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scanner
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scope
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Stubs
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ TypeVisitor
â”‚   â”‚           â”‚       â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚           â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚           â”‚       â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Plugin
â”‚   â”‚           â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ EventHandler
â”‚   â”‚           â”‚       â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Progress
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ SourceControl
â”‚   â”‚           â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Git
â”‚   â”‚           â”‚       â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â”œâ”€â”€ ğŸ“ Storage
â”‚   â”‚           â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Assertion
â”‚   â”‚           â”‚       â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚           â”‚       â”‚           â””â”€â”€ ğŸ“ Atomic
â”‚   â”‚           â”‚       â”‚               â””â”€â”€ ... (depth limit reached)
â”‚   â”‚           â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â”‚           â””â”€â”€ ğŸ“ extensions
â”‚   â”‚           â””â”€â”€ ğŸ“ webmozart
â”‚   â”‚               â””â”€â”€ ğŸ“ assert
â”‚   â”‚                   â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ ralouphie
â”‚   â”‚   â””â”€â”€ ğŸ“ getallheaders
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ ramsey
â”‚   â”‚   â”œâ”€â”€ ğŸ“ collection
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Map
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Tool
â”‚   â”‚   â””â”€â”€ ğŸ“ uuid
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Builder
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Codec
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Converter
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Number
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Time
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Fields
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Generator
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Guid
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Lazy
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Math
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Nonstandard
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Dce
â”‚   â”‚           â”‚   â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚           â”‚   â””â”€â”€ ğŸ“ Time
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Rfc4122
â”‚   â”‚           â”œâ”€â”€ ğŸ“ Type
â”‚   â”‚           â””â”€â”€ ğŸ“ Validator
â”‚   â”œâ”€â”€ ğŸ“ react
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cache
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ child-process
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ dns
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Model
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Protocol
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Query
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Resolver
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-loop
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Tick
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Timer
â”‚   â”‚   â”œâ”€â”€ ğŸ“ promise
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Internal
â”‚   â”‚   â”œâ”€â”€ ğŸ“ socket
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â””â”€â”€ ğŸ“ stream
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ revolt
â”‚   â”‚   â””â”€â”€ ğŸ“ event-loop
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”‚           â””â”€â”€ ğŸ“ EventLoop
â”‚   â”‚               â”œâ”€â”€ ğŸ“ Driver
â”‚   â”‚               â””â”€â”€ ğŸ“ Internal
â”‚   â”œâ”€â”€ ğŸ“ sebastian
â”‚   â”‚   â”œâ”€â”€ ğŸ“ cli-parser
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ code-unit
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ code-unit-reverse-lookup
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ comparator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ complexity
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Complexity
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Visitor
â”‚   â”‚   â”œâ”€â”€ ğŸ“ diff
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Output
â”‚   â”‚   â”œâ”€â”€ ğŸ“ environment
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ exporter
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ global-state
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ exceptions
â”‚   â”‚   â”œâ”€â”€ ğŸ“ lines-of-code
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ object-enumerator
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ object-reflector
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ recursion-context
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”œâ”€â”€ ğŸ“ type
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ src
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ exception
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ type
â”‚   â”‚   â””â”€â”€ ğŸ“ version
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ spatie
â”‚   â”‚   â””â”€â”€ ğŸ“ array-to-xml
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ staabm
â”‚   â”‚   â””â”€â”€ ğŸ“ side-effects-detector
â”‚   â”‚       â””â”€â”€ ğŸ“ lib
â”‚   â”œâ”€â”€ ğŸ“ symfony
â”‚   â”‚   â”œâ”€â”€ ğŸ“ console
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ CI
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Command
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ CommandLoader
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Completion
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Output
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ DataCollector
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Descriptor
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Event
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ EventListener
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Formatter
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Helper
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Input
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Logger
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Output
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Question
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ bin
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ SignalRegistry
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Style
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Tester
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ Constraint
â”‚   â”‚   â”œâ”€â”€ ğŸ“ deprecation-contracts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ DependencyInjection
â”‚   â”‚   â”œâ”€â”€ ğŸ“ event-dispatcher-contracts
â”‚   â”‚   â”œâ”€â”€ ğŸ“ filesystem
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ finder
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Comparator
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Iterator
â”‚   â”‚   â”œâ”€â”€ ğŸ“ options-resolver
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Debug
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Exception
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-ctype
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-grapheme
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-intl-normalizer
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â”œâ”€â”€ ğŸ“ stubs
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-mbstring
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ unidata
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php80
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php81
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ polyfill-php84
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Resources
â”‚   â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ process
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Messenger
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Pipes
â”‚   â”‚   â”œâ”€â”€ ğŸ“ service-contracts
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“ Attribute
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Test
â”‚   â”‚   â”œâ”€â”€ ğŸ“ stopwatch
â”‚   â”‚   â””â”€â”€ ğŸ“ string
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Inflector
â”‚   â”‚       â”œâ”€â”€ ğŸ“ Resources
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ bin
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ data
â”‚   â”‚       â””â”€â”€ ğŸ“ Slugger
â”‚   â”œâ”€â”€ ğŸ“ theseer
â”‚   â”‚   â””â”€â”€ ğŸ“ tokenizer
â”‚   â”‚       â””â”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“ vimeo
â”‚   â”‚   â””â”€â”€ ğŸ“ psalm
â”‚   â”‚       â”œâ”€â”€ ğŸ“ dictionaries
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ autogen
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ override
â”‚   â”‚       â”œâ”€â”€ ğŸ“ docs
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ annotating_code
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ type_syntax
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ contributing
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ manipulating_code
â”‚   â”‚       â”‚   â”œâ”€â”€ ğŸ“ running_psalm
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ issues
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ plugins
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ security_analysis
â”‚   â”‚       â”œâ”€â”€ ğŸ“ src
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ Psalm
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ CodeLocation
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Config
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Exception
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Internal
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Algebra
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Analyzer
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ FunctionLike
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Statements
â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ ğŸ“ Block
â”‚   â”‚       â”‚       â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ IfElse
â”‚   â”‚       â”‚       â”‚   â”‚       â”‚       â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ ğŸ“ Expression
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Assignment
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â”œâ”€â”€ ğŸ“ Call
â”‚   â”‚       â”‚       â”‚   â”‚           â”‚   â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”‚           â””â”€â”€ ğŸ“ Fetch
â”‚   â”‚       â”‚       â”‚   â”‚               â””â”€â”€ ... (depth limit reached)
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Cli
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Codebase
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ DataFlow
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Diff
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ ExecutionEnvironment
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ FileManipulation
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Fork
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Json
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ LanguageServer
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Client
â”‚   â”‚       â”‚       â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“ Progress
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Server
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpTraverser
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PhpVisitor
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Reflector
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ PluginManager
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Command
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Provider
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ AddRemoveTaints
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ ParamsProvider
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ PropertyTypeProvider
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ ReturnTypeProvider
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scanner
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ UnresolvedConstant
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scope
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Stubs
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Generator
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Type
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ Comparator
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ ParseTree
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ TypeAlias
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ TypeVisitor
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Issue
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Node
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Expr
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ AssignOp
â”‚   â”‚       â”‚       â”‚   â”‚   â”œâ”€â”€ ğŸ“ BinaryOp
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ Cast
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Name
â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ ğŸ“ Scalar
â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ ğŸ“ MagicConst
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Stmt
â”‚   â”‚       â”‚       â”‚       â””â”€â”€ ğŸ“ TraitUseAdaptation
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Plugin
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ EventHandler
â”‚   â”‚       â”‚       â”‚       â””â”€â”€ ğŸ“ Event
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Progress
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Report
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ SourceControl
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Git
â”‚   â”‚       â”‚       â”œâ”€â”€ ğŸ“ Storage
â”‚   â”‚       â”‚       â”‚   â””â”€â”€ ğŸ“ Assertion
â”‚   â”‚       â”‚       â””â”€â”€ ğŸ“ Type
â”‚   â”‚       â”‚           â””â”€â”€ ğŸ“ Atomic
â”‚   â”‚       â””â”€â”€ ğŸ“ stubs
â”‚   â”‚           â””â”€â”€ ğŸ“ extensions
â”‚   â””â”€â”€ ğŸ“ webmozart
â”‚       â””â”€â”€ ğŸ“ assert
â”‚           â””â”€â”€ ğŸ“ src
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ composer.json
â”œâ”€â”€ ğŸ“„ DEPENDENCIES.md
â”œâ”€â”€ ğŸ“„ llms.sh
â”œâ”€â”€ ğŸ“„ phpstan.neon.dist
â”œâ”€â”€ ğŸ“„ phpunit.xml.dist
â”œâ”€â”€ ğŸ“„ psalm.xml
â””â”€â”€ ğŸ“„ README.md


<documents>
<document index="1">
<source>.gitignore</source>
<document_content>
._*
.cache/
.classpath
.DS_Store
.DS_Store?
.phpunit.result.cache
.project
.settings/
.Spotlight-V100
.Trashes
*.backup
*.bak
*.cache
*.log
*.orig
*.phar
*.pid
*.pid.lock
*.rej
*.seed
*.sublime-project
*.sublime-workspace
*.swo
*.swp
*.temp
*.tmp
*~
/.idea/
/.php-cs-fixer.cache
/.phpstorm.meta.php/
/.phpunit.cache/
/.psalm-cache/
/.vscode/
/build/
/config/paragra.php
/coverage/
/docs/_build/
/docs/.doctrees/
/test-output/
/test-results/
/vendor/
$RECYCLE.BIN/
composer.phar
desktop.ini
ehthumbs.db
llms.txt
phpunit-events.log
Thumbs.db
</document_content>
</document>

<document index="2">
<source>.php-cs-fixer.dist.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/.php-cs-fixer.dist.php

use PhpCsFixer\Config;
use PhpCsFixer\Finder;

$finder = Finder::create()
    ->in(__DIR__ . '/src')
    ->in(__DIR__ . '/tests')
    ->name('*.php')
    ->files();

return (new Config())
    ->setRiskyAllowed(true)
    ->setRules([
        '@PSR12' => true,
        'array_syntax' => ['syntax' => 'short'],
        'strict_param' => true,
    ])
    ->setFinder($finder);
</document_content>
</document>

<document index="3">
<source>DEPENDENCIES.md</source>
<document_content>
---
this_file: paragra-php/DEPENDENCIES.md
---

# ParaGra Dependencies

| Package | Why we need it | Notes |
| --- | --- | --- |
| `ragie/ragie-php` | Primary Ragie client SDK; ParaGra wraps it to serve Ragie-backed pools. | Pulled via local path repository; tracks `dev-main` until v0.4.0 is tagged. |
| `neuron-core/neuron-ai` | Battle-tested (>1K â­) agentic/LLM abstraction for PHP that already handles provider selection, streaming, and adapters. | Avoids building LLM plumbing from scratch; extends our scope beyond OpenAI. |
| `google/cloud-ai-platform` | Official Google Cloud PHP client that surfaces Gemini File Search and Vertex AI models. | Maintained by Google; part of the google-cloud-php suite (~2k â­). |
| `google-gemini-php/client` | 344â­ community SDK for Gemini's v1beta API, used by `GeminiEmbeddingProvider` to hit `text-embedding-004`/`embedding-001` without hand-rolled HTTP plumbing. | Works with any PSR-18 client (Guzzle already present) and exposes batch embedding helpers we can fake in tests. |
| `guzzlehttp/guzzle` | Lightweight HTTP client for AskYoda/Gemini REST adapters and future providers. | Matches ragie-php requirements; keeps HTTP plumbing consistent. |
| `openai-php/client` | Official OpenAI PHP SDK powering `OpenAiChatClient` and `OpenAiModerator`. | Shared with ragie-php for compatibility; now declared explicitly. |
| `symfony/process` | Battle-tested process runner for launching the `twat-search` CLI with timeouts, retries, and captured output. | Standard Symfony component (>10k â­) so we avoid writing custom `proc_open()` plumbing. |
| `friendsofphp/php-cs-fixer` | Formatting/linting to keep contributions consistent. | Dev dependency. |
| `phpstan/phpstan` | Static analysis (level 7 baseline). | Dev dependency. |
| `phpunit/phpunit` | Primary test runner (11.x). | Dev dependency. |
| `vimeo/psalm` | Deeper static analysis to catch flow/typing issues (err level 3). | Dev dependency. |
| `dg/bypass-finals` | Enables PHPUnit to mock final classes (OpenAiChatClient, RagAnswerer dependencies) without removing `final`. | Loaded via `tests/bootstrap.php` before running the suite. |
</document_content>
</document>

<document index="4">
<source>README.md</source>
<document_content>
---
this_file: paragra-php/README.md
---

# ParaGra PHP Toolkit

ParaGra is a provider-agnostic PHP toolkit for orchestrating Retrieval-Augmented Generation (RAG) and LLM calls across Ragie, Gemini File Search, AskYoda, and future providers.

## Project Status

- **Phase:** Early scaffolding (see ../PLAN.md Â§12-13)
- **Goal:** Universal RAG+LLM coordinator that keeps Ragie-specific logic inside `ragie-php`

## Quick Start

Working in `/Users/adam/Developer/vcs/github.twardoch/pub/rag-projects/paragra-php`:

1. Copy the template config and fill in `.env` secrets.
   ```bash
   cp config/paragra.example.php config/paragra.php
   ```
2. (Optional) swap in one of the scenario configs under `examples/config/`.
3. Install dependencies + run tests.
   ```bash
   composer install
   composer test
   ```
4. Call ParaGra from your app:
   ```php
   use ParaGra\ParaGra;
   use ParaGra\Moderation\OpenAiModerator;

   $config = require __DIR__ . '/config/paragra.php';
   $paragra = ParaGra::fromConfig($config)
       ->withModeration(OpenAiModerator::fromEnv());

   $answer = $paragra->answer('Explain ParaGra', [
       'retrieval' => ['top_k' => 8],
       'generation' => ['temperature' => 0.2],
   ]);
   ```
5. Wire the same instance into `ask.vexy.art/public/{rag,text}` to keep endpoints slim.

## Directory Layout

```
paragra-php/
â”œâ”€â”€ src/            # Library source (PSR-4, namespace ParaGra\)
â”œâ”€â”€ tests/          # PHPUnit test suite
â”œâ”€â”€ docs/           # Design notes and future architecture docs
â”œâ”€â”€ examples/       # Usage snippets + smoke tests
â”œâ”€â”€ config/         # Example pool/provider configuration files
â”œâ”€â”€ composer.json   # Project metadata + dependencies
```

## Getting Started

```bash
cd paragra-php
composer install
composer test
```

Need a smoke test? Run `php examples/moderated_answer.php "What is Ragie?"` after exporting the relevant API keys.

## ParaGra Client (Rotation + Fallback)

```php
<?php

use ParaGra\Moderation\OpenAiModerator;
use ParaGra\ParaGra;

$config = require __DIR__ . '/config/paragra.php';
$paragra = ParaGra::fromConfig($config);
$paragra->withModeration(OpenAiModerator::fromEnv());

$retrieval = $paragra->retrieve('What is Ragie?', ['top_k' => 6]);

$answer = $paragra->answer('Explain ParaGra', [
    'retrieval' => ['top_k' => 8],
    'generation' => ['temperature' => 0.2],
]);

echo $answer['answer'];
```

- Automatic key rotation and fallback are powered by `PriorityPool`, `KeyRotator`, and `FallbackStrategy`. Free-tier pools attempt every key before falling back, hybrid pools default to two attempts, and hosted pools take a single shot, with hashed key fingerprints logged when ParaGra rotates providers.
- `retrieve()` returns a `UnifiedResponse` so your app can inspect normalized chunks, metadata, cost, and usage.
- `answer()` wraps retrieval + `NeuronAiAdapter` to build a prompt from the chunk text and call the configured LLM provider.

Copy `config/paragra.example.php` to `config/paragra.php` and fill in the relevant API keys (`CEREBRAS_API_KEY_*`, `RAGIE_API_KEY`, `OPENAI_API_KEY`, `GOOGLE_API_KEY`, etc.). Each pool groups one or more provider specs, letting free-tier keys handle most load while paid tiers stand by as fallbacks.

### Provider catalog shortcuts

Run `php tools/sync_provider_catalog.php` to refresh `config/providers/catalog.php`, then set `'provider_catalog' => __DIR__ . '/config/providers/catalog.php'` inside `config/paragra.php`. ParaGra will load any entry that includes `catalog`/`catalog_slug` and hydrate the provider spec from the catalog metadata:

```php
return [
    'provider_catalog' => __DIR__ . '/config/providers/catalog.php',
    'priority_pools' => [
        [
            [
                'catalog' => [
                    'slug' => 'cerebras',
                    'model_type' => 'generation',
                    'overrides' => [
                        'api_key' => (string) getenv('CEREBRAS_API_KEY_1'),
                        'solution' => [
                            'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                        ],
                    ],
                ],
                'latency_tier' => 'low',
                'cost_ceiling' => 0.00,
                'compliance' => ['internal'],
                'metadata_overrides' => ['notes' => 'Preferred free tier slot'],
            ],
        ],
    ],
];
```

Top-level keys such as `latency_tier`, `cost_ceiling`, `compliance`, and `metadata_overrides` merge into the catalog metadata so downstream dashboards can reason about tiers, budgets, and compliance posture without duplicating boilerplate.

### Pool presets with PoolBuilder

Tired of hand-writing rotation pools? Use the new `ParaGra\Planner\PoolBuilder` helper and CLI:

```bash
cd paragra-php
php tools/pool_builder.php --preset=free-tier --format=json
```

`PoolBuilder` reads `config/providers/catalog.php`, inspects your environment variables (`RAGIE_API_KEY`, `GOOGLE_API_KEY`, `GEMINI_DATASTORE_ID` or `GEMINI_CORPUS_ID`, `GROQ_API_KEY`, `OPENAI_API_KEY`, `EDENAI_*`, etc.), and emits ready-to-use `priority_pools` tuned for:

| Preset | Composition |
| --- | --- |
| `free-tier` | Gemini Flash Lite + Groq backed by Ragie, optional Cerebras rotation when `CEREBRAS_API_KEYS` is present. |
| `hybrid` | Free rotation plus OpenAI/Pinecone fallback for paid workloads. |
| `hosted` | AskYoda fallback annotated with Vectara + AWS Bedrock Knowledge Base recommendations. |

You can also consume it directly inside `config/paragra.php`:

```php
use ParaGra\Planner\PoolBuilder;
use ParaGra\ProviderCatalog\ProviderDiscovery;

$catalog = ProviderDiscovery::fromFile(__DIR__ . '/providers/catalog.php');
$builder = PoolBuilder::fromGlobals($catalog);

$options = [
    'ragie_partition' => getenv('RAGIE_PARTITION') ?: 'default',
    'ragie_defaults' => ['top_k' => 8],
];

$config = [
    'provider_catalog' => __DIR__ . '/providers/catalog.php',
    'priority_pools' => $builder->build(PoolBuilder::PRESET_FREE, $options),
];
```

All overrides are optional; `PoolBuilder` automatically merges env-driven values and throws descriptive errors when a required key (Gemini File Search now insists on `GEMINI_DATASTORE_ID`, `GEMINI_CORPUS_ID`, or `GEMINI_VECTOR_STORE`) or catalog slug is missing so you can address misconfiguration early.

### Composer integration (vendor vs vendor-local)

Inside `ask.vexy.art/private` we keep two copies:

| Path | Purpose |
| --- | --- |
| `vendor/` | Composer-managed release build used for deployments. |
| `vendor-local/` | Path repository pointing at `../../paragra-php` for local hacking. |

`composer.json` already declares the path repository, so `composer install` pulls fresh sources into both directories. Update `vendor-local/` when iterating locally; run `composer update vexy/paragra-php` to refresh the production `vendor/` copy once you're ready to deploy.

## Scripts

- `composer test` â€” PHPUnit test suite
- `composer stan` â€” PHPStan (level 7)
- `composer psalm` â€” Psalm (error level 3)
- `composer lint` â€” php-cs-fixer dry-run
- `composer qa` â€” Runs lint+stan+psalm+test sequentially
- `php tools/sync_provider_catalog.php [--source=../vexy-co-model-catalog]` â€” ingest the Python catalog outputs (`external/dump_models.py` + `models/*.json`) and regenerate `config/providers/catalog.{json,php}` with capability presets and recommended models.

## Components

- **Assistant** â€” `ParaGra\Assistant\RagAnswerer` and `RagAnswer` now mirror the proven Ragie workflows (retrieval â†’ prompt building â†’ OpenAI/AskYoda fallback) while remaining free to orchestrate other providers.
- **LLM** â€” `ParaGra\Llm` hosts the chat DTOs, `OpenAiChatClient/Config`, `PromptBuilder`, plus the EdenAI AskYoda client/response for pool-based fallbacks.
- **Moderation** â€” `ParaGra\Moderation\OpenAiModerator` (with result/exception DTOs) enables optional safety checks before running retrieval/LLM steps.
- **Utilities** â€” `ParaGra\Util\ConfigValidator` and `ParaGra\Support\ExceptionEnhancer` centralize environment validation + error messaging so ask.vexy.art endpoints and future ParaGra clients share consistent helpers.
- **Embedding** â€” `ParaGra\Embedding\EmbeddingRequest`, `EmbeddingProviderInterface`, and the ready-made `OpenAiEmbeddingConfig/Provider`, `CohereEmbeddingConfig/Provider`, `GeminiEmbeddingConfig/Provider`, and `VoyageEmbeddingConfig/Provider` deliver a shared contract for vector generation with batch controls, metadata passthrough, and optional normalization.
- **Vector store** â€” `ParaGra\VectorStore\VectorNamespace` and `VectorStoreInterface` define how Pinecone, Weaviate, Qdrant, Chroma, or Gemini File Search adapters will describe namespaces, upserts, deletes, and queries with consistency hints.
- **External search** â€” `ParaGra\ExternalSearch\TwatSearchRetriever` shells out to the [`twat-search`](https://github.com/twardoch/twat-search) CLI so ParaGra can enrich empty contexts with multi-engine snippets (Brave, DuckDuckGo, Tavily, SerpAPI) and emit normalized chunks with attribution metadata.
- **Media** â€” `ParaGra\Media\MediaRequest`, `MediaResult`, and the new `ChutesImageProvider` + `FalImageProvider` turn Ragie answers into art prompts and call the matching REST APIs (Chutes `/generate` JSON/binary responses, Fal.ai async job polling) so image/video enrichments can run behind feature flags without touching the core Ragie flows.
- **Provider Catalog** â€” `ProviderCatalog\CapabilityMap`, `ProviderCatalog\ProviderSummary`, and `ProviderCatalog\ProviderDiscovery` wrap the generated catalog so you can filter providers by capability, inspect embedding/vector-store support, and turn catalog slugs (`openai`, `groq`, `gemini`, etc.) into ready-to-use `ProviderSpec` instances.

### OpenAI embedding provider

ParaGra ships the first concrete embedding adapter via `ParaGra\Embedding\OpenAiEmbeddingProvider`. It wraps OpenAI's `text-embedding-3` family (and legacy `text-embedding-ada-002`) with batch-size enforcement, vector normalization, dimension hints, and metadata pass-through so you can push normalized vectors straight to Pinecone/Qdrant.

```php
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\OpenAiEmbeddingConfig;
use ParaGra\Embedding\OpenAiEmbeddingProvider;

$config = OpenAiEmbeddingConfig::fromEnv();
$provider = new OpenAiEmbeddingProvider($config);

$request = new EmbeddingRequest(
    inputs: [
        ['id' => 'doc-1', 'text' => 'Searchable text', 'metadata' => ['source' => 'kb']],
        'Plain string works too',
    ],
    normalize: true,
);

$result = $provider->embed($request);
// $result['vectors'] => list of ['id', 'values', 'metadata'] ready for vector stores.
```

Environment variables:

| Variable | Purpose |
| --- | --- |
| `OPENAI_API_KEY` | Required OpenAI key shared with chat/moderation features. |
| `OPENAI_EMBED_MODEL` | Defaults to `text-embedding-3-small`. |
| `OPENAI_EMBED_BASE_URL` | Optional proxy/base URL override. |
| `OPENAI_EMBED_DIMENSIONS` | Optional override when you want a custom `dimensions` payload. |
| `OPENAI_EMBED_MAX_BATCH` | Defaults to `2048` inputs per request (OpenAI's documented ceiling). |

If you omit `OPENAI_EMBED_DIMENSIONS`, ParaGra auto-picks the canonical dimension (1536 for `text-embedding-3-small`, 3072 for `text-embedding-3-large`). Requests can also specify `dimensions` directly through `EmbeddingRequest`. All vectors are optionally L2-normalized (`normalize: true`) so downstream cosine-search stores behave consistently.

### Cohere embedding provider

`ParaGra\Embedding\CohereEmbeddingProvider` hits Cohere's `embed-*-v3.0` family via raw HTTP (the official PHP SDKs are unmaintained and sit below the 200-star bar), so ParaGra leans on the existing `guzzlehttp/guzzle` dependency with tight env-driven defaults.

```php
use ParaGra\Embedding\CohereEmbeddingConfig;
use ParaGra\Embedding\CohereEmbeddingProvider;
use ParaGra\Embedding\EmbeddingRequest;

$config = CohereEmbeddingConfig::fromEnv();
$provider = new CohereEmbeddingProvider($config);

$request = new EmbeddingRequest(
    inputs: [
        ['id' => 'doc-1', 'text' => 'Search document', 'metadata' => ['tier' => 'gold']],
        'Another chunk that defaults to null metadata',
    ],
    normalize: false, // Cohere already outputs normalized floats
);

$result = $provider->embed($request);
// $result['vectors'] now mirrors ParaGra's embedding contract.
```

Environment variables:

| Variable | Purpose |
| --- | --- |
| `COHERE_API_KEY` | Required Cohere key. |
| `COHERE_EMBED_MODEL` | Defaults to `embed-english-v3.0` (1024 dims) but supports `*-light` (384) and multilingual variants. |
| `COHERE_EMBED_INPUT_TYPE` | Defaults to `search_document`; override with `search_query`, `classification`, etc. |
| `COHERE_EMBED_TRUNCATE` | Optional `START`/`END` toggle for long inputs. Leave empty to let Cohere reject oversize payloads. |
| `COHERE_EMBED_TYPES` | Comma list of embedding formats (`float`, `int8`, `binary`). ParaGra converts everything back to floats for downstream compatibility. |
| `COHERE_EMBED_MAX_BATCH` | Defaults to 96 texts per API call. |
| `COHERE_EMBED_BASE_URL` / `COHERE_EMBED_ENDPOINT` | Override when routing through a proxy/backplane. |

The provider enforces Cohere's 96-text ceiling, auto-infers the correct output dimension metadata (1024 or 384), and rejects manual `dimensions` overrides because Cohere's embeddings are fixed per model. Usage metadata exposes the `billed_units` block from Cohere's response so you can track consumption per batch.

### Gemini embedding provider

`ParaGra\Embedding\GeminiEmbeddingProvider` builds on the community-maintained (344â­) [`google-gemini-php/client`](https://github.com/google-gemini-php/client) SDK so ParaGra can batch against Google's `text-embedding-004` and `embedding-001` models without hand-rolling HTTP plumbing. The provider enforces Gemini's documented 250-item ceiling, wires optional `taskType` hints, and only sends `outputDimensionality` when the target model supports it.

```php
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\GeminiEmbeddingConfig;
use ParaGra\Embedding\GeminiEmbeddingProvider;

$config = GeminiEmbeddingConfig::fromEnv();
$provider = new GeminiEmbeddingProvider($config);

$request = new EmbeddingRequest(
    inputs: [
        ['id' => 'doc-1', 'text' => 'Gemini corpus entry', 'metadata' => ['region' => 'us']],
        'Query chunk that inherits null metadata',
    ],
    dimensions: 512, // only supported for text-embedding-004
    normalize: true,
);

$result = $provider->embed($request);
// $result['vectors'] => normalized Gemini vectors ready for Pinecone/Qdrant/etc.
```

Environment variables:

| Variable | Purpose |
| --- | --- |
| `GEMINI_EMBED_API_KEY` | Preferred Gemini API key for embeddings. Falls back to `GOOGLE_API_KEY` when unset. |
| `GEMINI_EMBED_MODEL` | Defaults to `text-embedding-004`. Set to `embedding-001` when you need the legacy 3072-dim output. |
| `GEMINI_EMBED_DIMENSIONS` | Optional override for `text-embedding-004` (128-3072). Ignored for models that don't support overrides. |
| `GEMINI_EMBED_MAX_BATCH` | Defaults to `250` inputs per call, matching Gemini's `batchEmbedContents` limit. |
| `GEMINI_EMBED_TASK_TYPE` | Optional TaskType hint (`retrieval_query`, `retrieval_document`, etc.) for improved embeddings. |
| `GEMINI_EMBED_TITLE` | Optional title passed to Gemini for analytics/debugging. |
| `GEMINI_EMBED_BASE_URL` | Override the API host (rare, mostly for proxies). |

If you leave `GEMINI_EMBED_API_KEY` empty ParaGra automatically reuses `GOOGLE_API_KEY`, which is already required for Gemini File Search retrieval pools. Regardless of the override, ParaGra records the canonical dimension metadata so downstream vector stores know what to expect.

### Voyage embedding provider

`ParaGra\Embedding\VoyageEmbeddingProvider` keeps the same contract but targets Voyage AI's `v1/embeddings` endpoint directly through `guzzlehttp/guzzle` (Voyage doesn't ship a PHP SDK with the >200â­ bar yet). The adapter enforces Voyage's 128-text batch ceiling, wires the documented `input_type`/`truncate` toggles, lets callers override output dimensions via Matryoshka learning, and normalizes the returned vectors so they drop into Pinecone/Qdrant without extra math.

```php
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\VoyageEmbeddingConfig;
use ParaGra\Embedding\VoyageEmbeddingProvider;

$config = VoyageEmbeddingConfig::fromEnv();
$provider = new VoyageEmbeddingProvider($config);

$request = new EmbeddingRequest(
    inputs: [
        ['id' => 'kb-1', 'text' => 'Voyage document embedding', 'metadata' => ['provider' => 'voyage']],
        'Query chunk that defaults to null metadata',
    ],
    normalize: true,
);

$result = $provider->embed($request);
// Contains normalized embeddings + usage metadata from Voyage's response.
```

Environment variables:

| Variable | Purpose |
| --- | --- |
| `VOYAGE_API_KEY` | Required Voyage AI key. |
| `VOYAGE_EMBED_MODEL` | Defaults to `voyage-3` (1024 dims). Supports `voyage-3-large` (2048), `voyage-3-lite` (512), `voyage-2`, and `voyage-2-lite`. |
| `VOYAGE_EMBED_INPUT_TYPE` | `document` (default) or `query`. Set to `none`/blank to omit the hint entirely. |
| `VOYAGE_EMBED_TRUNCATE` | Boolean toggle (`true`/`false`) for the API's truncation behavior. Defaults to `true`. |
| `VOYAGE_EMBED_DIMENSIONS` | Optional Matryoshka override (positive integer). Falls back to the model's canonical dimension when omitted. |
| `VOYAGE_EMBED_MAX_BATCH` | Defaults to `128` inputs per batch, matching Voyage's documented ceiling. |
| `VOYAGE_EMBED_TIMEOUT` | Request timeout in seconds (defaults to `30`). |
| `VOYAGE_EMBED_ENCODING` | Currently only accepts `float`, keeping Voyage payloads numeric so ParaGra can normalize them. |
| `VOYAGE_EMBED_BASE_URL` / `VOYAGE_EMBED_ENDPOINT` | Override when routing through an internal proxy. |

ParaGra always requests `encoding_format=float` today so downstream vector/vector-store tooling can safely treat the payloads as numeric lists. The provider rejects larger batches before hitting the network, converts Voyage's `data` or `embeddings` shapes back into ParaGra's canonical vector structure, and surfaces the upstream `usage` block verbatim for cost tracking.

### Pinecone vector store adapter

`ParaGra\VectorStore\PineconeVectorStore` speaks Pinecone's 2024 data plane API directly through Guzzle because no maintained PHP SDK clears the 200â­ threshold yet. Instantiate it with the data plane host, API key, and index name, then pass `VectorNamespace` instances to scope namespaces/filters.

```php
use ParaGra\VectorStore\PineconeVectorStore;
use ParaGra\VectorStore\VectorNamespace;

$store = new PineconeVectorStore(
    baseUrl: 'https://my-index.svc.us-west1-aws.pinecone.io',
    apiKey: getenv('PINECONE_API_KEY'),
    indexName: 'docs-index',
    defaultNamespace: new VectorNamespace('public-kb'),
);

$store->upsert(
    new VectorNamespace('public-kb'),
    [
        ['id' => 'doc-1', 'values' => [0.1, 0.2], 'metadata' => ['text' => 'Chunk body', 'source' => 'kb']],
    ],
);

$response = $store->query(new VectorNamespace('public-kb'), $queryVector, ['top_k' => 8]);
foreach ($response->getChunks() as $chunk) {
    // UnifiedResponse chunks include text, Pinecone scores, and normalized metadata.
}
```

Key parameters:

- `baseUrl` â€” Your index host (`https://{index}-{project}.svc.{env}.pinecone.io`).
- `apiKey` â€” Pinecone data plane key (`PINECONE_API_KEY` in most deployments).
- `indexName` â€” Friendly name shown in `UnifiedResponse::getModel()`.
- `defaultNamespace` â€” Optional `VectorNamespace` for `getDefaultNamespace()`. Additional metadata entries become Pinecone JSON filters (scalars â†’ `$eq`, lists â†’ `$in`).

ParaGra always requests metadata, normalizes chunk text (`metadata.text` or `metadata.content`), and propagates namespace diagnostics through `UnifiedResponse` metadata for observability.

### Weaviate vector store adapter

`ParaGra\VectorStore\WeaviateVectorStore` wraps Weaviateâ€™s REST + GraphQL APIs without pulling the low-star PHP community SDKs into the tree. Provide the cluster base URL (without `/v1`), the collection/class name, and optional API key/default namespace metadata so ParaGra can batch upserts, deletes, and vector queries with tenant-aware filters.

```php
use ParaGra\VectorStore\VectorNamespace;
use ParaGra\VectorStore\WeaviateVectorStore;

$namespace = new VectorNamespace(
    name: 'kb',
    collection: 'Articles',
    metadata: ['tenant' => 'tenant-a', 'source' => 'docs'],
);

$store = new WeaviateVectorStore(
    baseUrl: 'https://demo.weaviate.network',
    className: 'Articles',
    apiKey: getenv('WEAVIATE_API_KEY'),
    defaultNamespace: $namespace,
    defaultProperties: ['text', 'title', 'url'],
);

$store->upsert($namespace, [
    ['id' => 'doc-1', 'values' => [0.1, 0.2], 'metadata' => ['text' => 'Chunk body', 'url' => 'https://example']],
]);

$response = $store->query(
    $namespace,
    $queryVector,
    [
        'top_k' => 5,
        'include_vectors' => true, // requests `_additional.vector`
        'properties' => ['text', 'title', 'url'], // GraphQL projection override
    ],
);
```

Highlights:

- **Multi-tenancy + consistency:** Namespace metadata (or per-call options) can set `tenant` and `consistency_level`; the adapter threads them through the `X-Weaviate-Tenant` header, REST `consistency_level` query param, and GraphQL arguments automatically.
- **Metadata filters:** `VectorNamespace` metadata becomes a GraphQL `WhereFilter` (`Equal` for scalars, `ContainsAny` for list metadata). You can still pass a custom `filter` array to `query()` when you need compound predicates.
- **Property selection:** Because GraphQL requires explicit property lists, the constructor accepts `defaultProperties` and `query()` exposes a `properties` override. ParaGra always asks for `_additional { id score distance certainty [vector] }` so `UnifiedResponse` keeps scores/document IDs while your code chooses which object fields become metadata.

### Qdrant vector store adapter

`ParaGra\VectorStore\QdrantVectorStore` targets Qdrant's REST API using the same contract. Provide the base URL (e.g., `http://localhost:6333` or your managed endpoint), collection name, and optional API key.

```php
use ParaGra\VectorStore\QdrantVectorStore;
use ParaGra\VectorStore\VectorNamespace;

$store = new QdrantVectorStore(
    baseUrl: 'http://localhost:6333',
    collection: 'docs',
    apiKey: getenv('QDRANT_API_KEY'),
);

$store->upsert(
    new VectorNamespace('docs'),
    [
        ['id' => 'doc-1', 'values' => [0.4, 0.5], 'metadata' => ['text' => 'Payload body', 'tier' => 'gold']],
    ],
    ['wait_for_sync' => true],
);

$response = $store->query(new VectorNamespace('docs'), $queryVector, ['top_k' => 5]);
```

Important knobs:

- `wait_for_sync` (upsert/delete options) toggles Qdrant's `wait` flag.
- `VectorNamespace` metadata becomes Qdrant filters (`must` clauses with scalar/`any` matches).
- `include_vectors` query option controls `with_vector`.

The adapter preserves Qdrant payload fields as chunk metadata (minus the extracted `text`/`content`) so downstream prompt builders can keep URLs, titles, or custom attributes intact.

### Chroma vector store adapter

`ParaGra\VectorStore\ChromaVectorStore` covers ChromaDB v2's REST interface (`/api/v2/tenants/{tenant}/databases/{database}/collections/{collection}`) directly through Guzzle because the only public PHP clients (`theogibbons/chroma-php` @ 2â­ and `CodeWithKyrian/chromadb-php` @ 73â­) sit well below the >200â­ support bar. Supply the base URL (without `/api/v2`), Chroma tenant/database names, the collection/namespace you want to target, and (optionally) a bearer token.

```php
use ParaGra\VectorStore\ChromaVectorStore;
use ParaGra\VectorStore\VectorNamespace;

$namespace = new VectorNamespace('kb', 'kb', metadata: ['source' => 'manual']);

$store = new ChromaVectorStore(
    baseUrl: 'http://localhost:8000',
    tenant: 'default_tenant',
    database: 'default_database',
    collection: 'kb',
    defaultNamespace: $namespace,
    authToken: getenv('CHROMA_API_TOKEN') ?: null,
);

$store->upsert($namespace, [
    ['id' => 'doc-1', 'values' => [0.1, 0.2], 'metadata' => ['text' => 'Chunk body', 'url' => 'https://example']],
]);

$response = $store->query(
    $namespace,
    $queryVector,
    [
        'top_k' => 5,
        // Optional: pass additional filters understood by Chroma's `where` syntax.
        'filter' => ['$and' => [['tier' => 'public']]],
    ],
);
```

Chroma highlights:

- **Tenant + database aware:** Constructor arguments feed every REST path so ParaGra can talk to multi-tenant deployments, while `VectorNamespace::getCollection()` lets you override the collection per namespace.
- **Metadata-driven filters:** Namespace metadata automatically becomes a Chroma `where` clause (scalars become `['field' => 'value']`, lists become `['$and' => [['field' => ['$in' => [...]]]]]`). You can always pass a custom `filter` array to `query()` for advanced predicates.
- **Document extraction:** Upserts automatically populate Chroma's `documents` field when metadata already includes `text`/`content`, and queries turn `documents` (or fallback metadata) back into `UnifiedResponse` chunks with `tenant`/`database`/`collection` diagnostics included.
- **Document extraction:** Upserts automatically populate Chroma's `documents` field when metadata already includes `text`/`content`, and queries turn `documents` (or fallback metadata) back into `UnifiedResponse` chunks with `tenant`/`database`/`collection` diagnostics included.

### Gemini File Search vector adapter

`ParaGra\VectorStore\GeminiFileSearchVectorStore` targets the Gemini File Search REST API, which exposes either `projects/.../corpora/...` resources or simplified `fileSearchStores/...` names. Google manages the chunking/vector math internally, so ParaGra focuses on uploading chunk text + metadata and issuing semantic queries that return normalized `UnifiedResponse` chunks.

```php
use ParaGra\VectorStore\GeminiFileSearchVectorStore;
use ParaGra\VectorStore\VectorNamespace;

$resource = getenv('GEMINI_DATASTORE_ID') ?: getenv('GEMINI_CORPUS_ID') ?: getenv('GEMINI_VECTOR_STORE');
if (!is_string($resource) || $resource === '') {
    throw new RuntimeException('Set GEMINI_DATASTORE_ID (preferred) or GEMINI_CORPUS_ID for Gemini File Search.');
}

$store = new GeminiFileSearchVectorStore(
    apiKey: getenv('GOOGLE_API_KEY'),
    resourceName: $resource,
);

$namespace = new VectorNamespace('internal-kb', $resource, metadata: ['source' => 'kb']);

$store->upsert($namespace, [
    [
        'id' => 'doc-1',
        'values' => [], // Gemini ignores embedding values
        'metadata' => [
            'text' => 'Chunk body content',
            'display_name' => 'Knowledge Base Doc',
            'tags' => ['kb'],
        ],
    ],
]);

$response = $store->query(
    $namespace,
    [],
    [
        'query' => 'Summarize the knowledge base doc',
        'top_k' => 4,
    ],
);
```

Key behaviors:

- **Text required:** Each record passed to `upsert()` must include `metadata['text']` (or `body`/`content`). Gemini uses this text to build a document; the `values` array is ignored because vectors are computed server-side.
- **Stable IDs:** Provide deterministic `id` values so `delete()` can remove or replace individual documents. ParaGra slugifies IDs automatically to satisfy Gemini's character rules.
- **Query contract:** `query()` ignores the `$vector` parameterâ€”pass a natural-language prompt via `options['query']`. Namespace metadata (or `options['filter']`) becomes Gemini's metadata filters.
- **Resource flexibility:** `resourceName` can be either `fileSearchStores/{store}` (Gemini API), `projects/{project}/locations/{location}/collections/default_collection/dataStores/{datastore}` (Vertex AI Search), or the legacy `projects/{project}/locations/{location}/corpora/{corpus}` string. ParaGra mirrors whatever identifier you configure in Google AI Studio.

### Hybrid Ragie + vector store pipeline

`ParaGra\Pipeline\HybridRetrievalPipeline` blends Ragie retrieval (keyword/KB) with semantic matches from any vector store adapter. It accepts a callable retriever (usually `[$paragra, 'retrieve']`), an embedding provider, the vector store adapter, and the namespace to target. The pipeline exposes two entry points:

- `ingestFromRagie(string $query, array $options = [])` â€” fetch Ragie chunks, embed them, and upsert into the vector store.
- `hybridRetrieve(string $query, array $options = [])` â€” query Ragie + the vector store, rerank/deduplicate results, and return raw + merged `UnifiedResponse` objects.

```php
use ParaGra\Embedding\OpenAiEmbeddingConfig;
use ParaGra\Embedding\OpenAiEmbeddingProvider;
use ParaGra\ParaGra;
use ParaGra\Pipeline\HybridRetrievalPipeline;
use ParaGra\VectorStore\PineconeVectorStore;
use ParaGra\VectorStore\VectorNamespace;

$paragra = ParaGra::fromConfig(require __DIR__ . '/config/paragra.php');
$embedding = new OpenAiEmbeddingProvider(OpenAiEmbeddingConfig::fromEnv());
$namespace = new VectorNamespace('ragie-hybrid');
$vectorStore = new PineconeVectorStore(
    baseUrl: getenv('PINECONE_BASE_URL'),
    apiKey: getenv('PINECONE_API_KEY'),
    indexName: getenv('PINECONE_INDEX'),
    defaultNamespace: $namespace,
);

$pipeline = new HybridRetrievalPipeline([$paragra, 'retrieve'], $embedding, $vectorStore, $namespace);
$pipeline->ingestFromRagie('What does ParaGra do?', ['retrieval' => ['top_k' => 6]]);

$result = $pipeline->hybridRetrieve('What does ParaGra do?', [
    'retrieval' => ['top_k' => 6],
    'vector_store' => ['top_k' => 6],
    'hybrid_limit' => 8,
]);

$combinedChunks = $result['combined']->getChunks(); // ready for prompt builders
```

See `examples/vector-stores/hybrid_pipeline.php` for an end-to-end CLI that supports Pinecone, Qdrant, Weaviate, Chroma, and Gemini File Search via environment variables (`HYBRID_STORE`, `HYBRID_SEED_FIRST`, etc.).

### External search fallback (twat-search)

`ParaGra\ExternalSearch\TwatSearchRetriever` lets ParaGra execute the [`twat-search`](https://github.com/twardoch/twat-search) CLI (multi-engine Brave/DuckDuckGo/Tavily/SerpAPI) whenever Ragie or another catalog provider fails to return context. The retriever:

- Builds `twat-search web q --json ...` commands with engine selection (`-e brave,duckduckgo`), per-engine result counts, and a configurable binary (`TWAT_SEARCH_BIN`).
- Uses `symfony/process` to enforce timeouts, capture stdout/stderr cleanly, and retry transient failures (exit code â‰  0) before surfacing an `ExternalSearchException`.
- Normalizes JSON output into `UnifiedResponse` chunks with `text`, `score`, `document_id` (URL), and metadata (engine, title, snippet, timestamp, raw/extra_info payloads).
- Caches responses in-memory (`TWAT_SEARCH_CACHE_TTL`, default 90s) so repeated questions hit the CLI once per TTL window while exposing `cache_hit`, `duration_ms`, and `engines` metadata for logging.

Usage example:

```php
use ParaGra\ExternalSearch\TwatSearchRetriever;

$twat = new TwatSearchRetriever(
    defaultEngines: explode(',', getenv('TWAT_SEARCH_ENGINES') ?: 'brave,duckduckgo'),
    environment: array_filter([
        'BRAVE_API_KEY' => getenv('BRAVE_API_KEY') ?: null,
        'TAVILY_API_KEY' => getenv('TAVILY_API_KEY') ?: null,
        'YOU_API_KEY' => getenv('YOU_API_KEY') ?: null,
        'SERPAPI_API_KEY' => getenv('SERPAPI_API_KEY') ?: null,
    ]),
);

$context = $paragra->retrieve($question);
if ($context->isEmpty()) {
    $search = $twat->search($question, ['num_results' => 4, 'max_results' => 6]);
    $chunks = $search->getChunks();
    // Feed chunks into PromptBuilder or append to fallback prompts.
}
```

See `examples/external-search/twat_search_fallback.php` for a CLI script that prints Ragie chunks alongside twat-search snippets plus metadata. Environment knobs:

| Env var | Default | Purpose |
| --- | --- | --- |
| `TWAT_SEARCH_BIN` | `twat-search` | Path to the CLI binary (`pip install "twat-search[all]"`). |
| `TWAT_SEARCH_ENGINES` | `brave,duckduckgo` | Comma-separated engine IDs passed to `-e`. |
| `TWAT_SEARCH_NUM_RESULTS` | `4` | Per-engine result count sent to `--num_results`. |
| `TWAT_SEARCH_MAX_RESULTS` | `6` | Combined snippet limit after normalization. |
| `TWAT_SEARCH_CACHE_TTL` | `90` | Cache duration (seconds) for CLI responses. |
| `TAVILY_API_KEY`, `BRAVE_API_KEY`, `YOU_API_KEY`, `SERPAPI_API_KEY` | â€” | Optional API keys enabling premium engines. |

### Provider catalog & discovery workflow

1. Run `php tools/sync_provider_catalog.php` from `paragra-php/` (or point `--source` at another checkout of `vexy-co-model-catalog`). The script parses `external/dump_models.py`, ingests the latest `models/*.json`, merges ParaGra-specific capability presets, and writes `config/providers/catalog.json` plus a PHP array version.
2. Load catalog data inside your app:
   ```php
   use ParaGra\Config\ProviderSpec;
   use ParaGra\ProviderCatalog\ProviderDiscovery;

   $catalog = ProviderDiscovery::fromFile(__DIR__ . '/config/providers/catalog.php');

   // Filter for providers that can embed
   $embeddingProviders = $catalog->filterByCapability('embeddings');

   // Build a ProviderSpec for OpenAI using env vars + default solution metadata
   putenv('OPENAI_API_KEY=sk-...');
   $openAiSpec = $catalog->buildProviderSpec('openai'); // ProviderSpec
   ```
3. Feed the returned `ProviderSpec` objects into your `PriorityPool` definitions (or ParaGra factories) instead of hard-coding provider metadata. The discovery helper surfaces embedding dimensions, preferred vector stores, and recommended models so you can rotate Cerebras/Groq/OpenAI/Gemini pools with a single slug.

## Dependencies

See `DEPENDENCIES.md` for justification of every runtime + dev dependency.

## Documentation

- `docs/configuration.md` â€” Step-by-step config + env var reference.
- `docs/architecture.md` â€” Priority pools, rotation, and fallback diagrams.
- `docs/examples.md` â€” Scenario configs + moderation script usage.
- `docs/migration.md` â€” How to replace old ragie-php helpers with ParaGra.
- `docs/api.md` â€” Quick reference for core classes and methods.
</document_content>
</document>

<document index="5">
<source>composer.json</source>
<document_content>
{
  "name": "vexy/paragra-php",
  "description": "Provider-agnostic PHP toolkit for orchestrating multi-provider RAG and LLM pipelines",
  "type": "library",
  "license": "MIT",

... (Data file content truncated to first 5 lines)
</document_content>
</document>

<document index="6">
<source>config/paragra.example.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/config/paragra.example.php

/**
 * Example priority pool configuration for ParaGra. Copy this file to
 * config/paragra.php and replace the placeholder getenv() values with your
 * actual API keys + metadata.
 */
return [
    'provider_catalog' => __DIR__ . '/providers/catalog.php',
    'priority_pools' => [
        // Pool 1: free-tier Cerebras keys rotating every second
        [
            [
                'catalog' => [
                    'slug' => 'cerebras',
                    'model_type' => 'generation',
                    'overrides' => [
                        'api_key' => (string) getenv('CEREBRAS_API_KEY_1'),
                        'model' => 'llama-3.3-70b',
                        'solution' => [
                            'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                            'ragie_partition' => getenv('RAGIE_PARTITION') ?: 'default',
                        ],
                    ],
                ],
                'latency_tier' => 'low',
                'cost_ceiling' => 0.00,
                'compliance' => ['internal'],
                'metadata_overrides' => [
                    'notes' => 'Preferred pool for low-cost traffic',
                ],
            ],
            [
                'catalog_slug' => 'cerebras',
                'catalog_overrides' => [
                    'api_key' => (string) getenv('CEREBRAS_API_KEY_2'),
                    'model' => 'llama-3.3-70b',
                    'solution' => [
                        'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                    ],
                ],
                'latency_tier' => 'low',
                'cost_ceiling' => 0.00,
                'compliance' => ['internal'],
                'metadata_overrides' => [
                    'notes' => 'Companion key for rotation',
                ],
            ],
        ],

        // Pool 2: paid OpenAI fallback
        [
            [
                'catalog' => [
                    'slug' => 'openai',
                    'overrides' => [
                        'api_key' => (string) getenv('OPENAI_API_KEY'),
                        'model' => 'gpt-4o-mini',
                        'solution' => [
                            'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                            'default_options' => [
                                'top_k' => 8,
                                'rerank' => true,
                            ],
                        ],
                    ],
                ],
                'latency_tier' => 'medium',
                'cost_ceiling' => 0.12,
                'compliance' => ['soc2', 'gdpr'],
                'metadata_overrides' => [
                    'notes' => 'Highly reliable fallback',
                ],
            ],
        ],

        // Pool 3: Gemini File Search (native Google retrieval)
        [
            [
                'catalog' => [
                    'slug' => 'gemini',
                    'model_type' => 'generation',
                    'overrides' => [
                        'api_key' => (string) getenv('GOOGLE_API_KEY'),
                        'solution' => [
                        'vector_store' => [
                            'datastore' => (string) (getenv('GEMINI_DATASTORE_ID') ?: getenv('GEMINI_CORPUS_ID')),
                        ],
                            'generation' => [
                                'safety_settings' => 'block_few',
                                'temperature' => 0.4,
                            ],
                            'metadata' => [
                                'notes' => 'Use when Ragie corpora miss',
                            ],
                        ],
                    ],
                ],
                'latency_tier' => 'paid',
                'cost_ceiling' => 0.20,
                'compliance' => ['iso27001'],
            ],
        ],
    ],
];
</document_content>
</document>

<document index="7">
<source>config/providers/catalog.json</source>
<document_content>
{
    "generated_at": "2025-11-16T02:05:15+00:00",
    "source": "/Users/adam/Developer/vcs/github.vexyart/vexy-co-model-catalog",
    "providers": [
        {

... (Data file content truncated to first 5 lines)
</document_content>
</document>

<document index="8">
<source>config/providers/catalog.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/config/providers/catalog.php

return array (
  'generated_at' => '2025-11-16T02:05:15+00:00',
  'source' => '/Users/adam/Developer/vcs/github.vexyart/vexy-co-model-catalog',
  'providers' => 
  array (
    0 => 
    array (
      'slug' => 'aihorde',
      'display_name' => 'Aihorde',
      'description' => '',
      'api_key_env' => 'AIHORDE_KEY',
      'base_url' => 'https://oai.aihorde.net/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    1 => 
    array (
      'slug' => 'anthropic',
      'display_name' => 'Anthropic',
      'description' => '',
      'api_key_env' => 'ANTHROPIC_API_KEY',
      'base_url' => 'https://api.anthropic.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    2 => 
    array (
      'slug' => 'arliai',
      'display_name' => 'Arliai',
      'description' => '',
      'api_key_env' => 'ARLIAI_TEXT_API_KEY',
      'base_url' => 'https://api.arliai.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    3 => 
    array (
      'slug' => 'askyoda',
      'display_name' => 'EdenAI AskYoda',
      'description' => 'Full retrieval + answer pipeline via EdenAI AskYoda.',
      'api_key_env' => 'EDENAI_API_KEY',
      'base_url' => 'https://api.edenai.run/v2',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'askyoda',
      'default_models' => 
      array (
        'generation' => 'askyoda:gemini-2.5-flash-lite',
      ),
      'default_solution' => 
      array (
        'type' => 'askyoda',
        'defaults' => 
        array (
          'k' => 10,
          'min_score' => 0.3,
        ),
      ),
      'metadata' => 
      array (
        'tier' => 'hosted',
        'latency' => 'medium',
        'latency_tier' => 'hosted',
        'insights' => 
        array (
          'eden-askyoda' => 
          array (
            'slug' => 'eden-askyoda',
            'name' => 'Eden AI AskYoda Hosted Workflow',
            'category' => 'hosted_rag',
            'reset_window' => 'per_minute_plan_tiers',
            'commercial_use' => 'Starter tier is free for testing; Personal/Professional plans unlock higher renewable RPM and production support.',
            'notes' => 'AskYoda runs on Eden AI\'s hosted workflow engine, routes to multiple LLMs, exposes fallback_providers, and surfaces latency/response-time telemetry in the monitoring dashboard so operators can keep responses in the sub-3-second tier.',
            'modalities' => 
            array (
              0 => 'rag',
              1 => 'llm_router',
              2 => 'workflow',
            ),
            'recommended_roles' => 
            array (
              0 => 'hosted_fallback_rag',
              1 => 'edenai_pool',
              2 => 'latency_guardrail',
            ),
            'free_tier' => 
            array (
              'starter_requests_per_minute' => 60,
              'personal_requests_per_minute' => 300,
              'professional_requests_per_minute' => 1000,
              'http_429_response' => 'Returns HTTP 429 when tier limit exceeded',
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-rag/ragres-14.md',
                'sha256' => '73dff8f43d637610bb2b1c4a94825771c6d8e4422809f4ea554962b17913ba26',
                'start_line' => 10,
                'end_line' => 16,
              ),
              1 => 
              array (
                'path' => 'reference/research-rag/ragres-14.md',
                'sha256' => '73dff8f43d637610bb2b1c4a94825771c6d8e4422809f4ea554962b17913ba26',
                'start_line' => 18,
                'end_line' => 19,
              ),
            ),
          ),
        ),
      ),
    ),
    4 => 
    array (
      'slug' => 'atlascloud',
      'display_name' => 'Atlascloud',
      'description' => '',
      'api_key_env' => 'ATLASCLOUD_API_KEY',
      'base_url' => NULL,
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    5 => 
    array (
      'slug' => 'avian',
      'display_name' => 'Avian',
      'description' => '',
      'api_key_env' => 'AVIAN_API_KEY',
      'base_url' => 'https://api.avian.io/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    6 => 
    array (
      'slug' => 'baseten',
      'display_name' => 'Baseten',
      'description' => '',
      'api_key_env' => 'BASETEN_API_KEY',
      'base_url' => 'https://inference.baseten.co/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    7 => 
    array (
      'slug' => 'bedrock-kb',
      'display_name' => 'AWS Bedrock Knowledge Bases',
      'description' => 'Managed retrieval layer that pairs OpenSearch Serverless with AWS-hosted LLMs.',
      'api_key_env' => NULL,
      'base_url' => NULL,
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => true,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'managed',
        'latency' => 'dependent',
        'insights' => 
        array (
          'aws-bedrock-knowledge-bases' => 
          array (
            'slug' => 'aws-bedrock-knowledge-bases',
            'name' => 'AWS Bedrock Knowledge Bases',
            'category' => 'managed_rag',
            'reset_window' => 'monthly',
            'commercial_use' => 'AWS enterprise workloads with IAM + audit trails; billed monthly alongside OpenSearch/Neptune usage.',
            'notes' => 'Bedrock Knowledge Bases couple OpenSearch Serverless with optional Neptune GraphRAG pipelines so enterprises can load content, pick Anthropic/Meta/Amazon models, and ship retrieval flows without bespoke infrastructure.',
            'modalities' => 
            array (
              0 => 'rag',
              1 => 'vector_store',
              2 => 'graph',
            ),
            'recommended_roles' => 
            array (
              0 => 'managed_graph_rag',
              1 => 'enterprise_handoff',
            ),
            'free_tier' => 
            array (
              'monthly_cost_usd' => 500,
              'setup_days' => 5,
              'includes_vector_db' => false,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-rag/ragres-05.md',
                'sha256' => 'b359d75121ad8ea1562fc2b49282fe480f80674c89e80ec38b946de503de7489',
                'start_line' => 62,
                'end_line' => 70,
              ),
              1 => 
              array (
                'path' => 'reference/research-rag/ragres-05.md',
                'sha256' => 'b359d75121ad8ea1562fc2b49282fe480f80674c89e80ec38b946de503de7489',
                'start_line' => 96,
                'end_line' => 132,
              ),
            ),
          ),
        ),
      ),
    ),
    8 => 
    array (
      'slug' => 'cerebras',
      'display_name' => 'Cerebras',
      'description' => 'Fast, low-cost Llama-3.3 hosting and generous free tier.',
      'api_key_env' => 'CEREBRAS_API_KEY',
      'base_url' => 'https://api.cerebras.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'ragie',
      'default_models' => 
      array (
        'generation' => 'llama-3.3-70b',
        'fast_generation' => 'llama-3.1-8b',
      ),
      'default_solution' => 
      array (
        'type' => 'ragie',
        'ragie_partition' => 'default',
        'metadata' => 
        array (
          'tier' => 'free',
        ),
      ),
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
      ),
    ),
    9 => 
    array (
      'slug' => 'chutes',
      'display_name' => 'Chutes',
      'description' => '',
      'api_key_env' => 'CHUTES_API_KEY',
      'base_url' => 'https://llm.chutes.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    10 => 
    array (
      'slug' => 'cloudflare',
      'display_name' => 'Cloudflare Workers AI',
      'description' => 'Edge-hosted inference with EmbeddingGemma and 10k neuron daily renewals.',
      'api_key_env' => 'CLOUDFLARE_API_TOKEN',
      'base_url' => 'https://api.cloudflare.com/client/v4',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => true,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'workers-ai',
      'default_models' => 
      array (
        'generation' => '@cf/meta/llama-3.1-8b-instruct',
        'embedding' => '@cf/google/gemma-embedding-002',
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'low',
        'insights' => 
        array (
          'cloudflare-workers-ai' => 
          array (
            'slug' => 'cloudflare-workers-ai',
            'name' => 'Cloudflare Workers AI â€“ EmbeddingGemma',
            'category' => 'edge_ai',
            'reset_window' => 'daily',
            'commercial_use' => 'Covered by Workers AI free plan; commercial usage allowed within neuron allocation.',
            'notes' => 'Workers AI hosts EmbeddingGemma-300m plus BGE family models with 10,000 free neurons per day (~5â€“10M tokens). Paid overages cost $0.011 per 1,000 neurons and run at Cloudflare\'s global edge.',
            'modalities' => 
            array (
              0 => 'embedding',
              1 => 'llm',
              2 => 'vector',
            ),
            'recommended_roles' => 
            array (
              0 => 'edge_embeddings',
              1 => 'latency_sensitive_rag',
            ),
            'free_tier' => 
            array (
              'neurons_per_day' => 10000,
              'approx_tokens_per_day' => 5000000,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-embedding/emb-cla.md',
                'sha256' => 'be957503605ddc97af43a28adde1a95240ef549297d783e2240049239a4a59bf',
                'start_line' => 205,
                'end_line' => 217,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/02-gem.md',
                'sha256' => '77c5d13b3146293f609cb47811f22848b814e83d2d8ad83e46e5831a1831d4e4',
                'start_line' => 22,
                'end_line' => 24,
              ),
            ),
          ),
        ),
      ),
    ),
    11 => 
    array (
      'slug' => 'deepinfra',
      'display_name' => 'Deepinfra',
      'description' => '',
      'api_key_env' => 'DEEPINFRA_API_KEY',
      'base_url' => 'https://api.deepinfra.com/v1/openai',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    12 => 
    array (
      'slug' => 'deepseek',
      'display_name' => 'Deepseek',
      'description' => '',
      'api_key_env' => 'DEEPSEEK_API_KEY',
      'base_url' => 'https://api.deepseek.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    13 => 
    array (
      'slug' => 'dify',
      'display_name' => 'Dify Orchestrator',
      'description' => 'Self-hostable RAG + automation builder with visual flows.',
      'api_key_env' => NULL,
      'base_url' => NULL,
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => true,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => 
      array (
        'type' => 'dify',
      ),
      'metadata' => 
      array (
        'tier' => 'self_hosted',
        'latency' => 'dependent',
        'insights' => 
        array (
          'dify-platform' => 
          array (
            'slug' => 'dify-platform',
            'name' => 'Dify Open-Source Orchestrator',
            'category' => 'rag_platform',
            'reset_window' => 'n/a',
            'commercial_use' => 'MIT-licensed self-host; infra costs ($50-200/month) govern production deployments.',
            'notes' => 'Dify ships a Docker-deployable UI with 90k+ GitHub stars, drag-and-drop pipelines, and connectors for 100+ LLM providers. Recommended for teams needing a no-code/low-code RAG builder they can self-host.',
            'modalities' => 
            array (
              0 => 'workflow_builder',
              1 => 'rag',
            ),
            'recommended_roles' => 
            array (
              0 => 'hosted_rag_builder',
              1 => 'visual_pipeline',
            ),
            'free_tier' => 
            array (
              'notes' => 'No vendor-enforced API quota; cost is the underlying Docker/Railway/Render infrastructure.',
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-rag/ragres-07.md',
                'sha256' => '7a3dfd6b76169a6ac833c2005bbd818cd8c29b9739f78a1a815ecb0239b297cd',
                'start_line' => 70,
                'end_line' => 79,
              ),
              1 => 
              array (
                'path' => 'reference/research-rag/ragres-02.md',
                'sha256' => 'fca0ce92dab93bc939ce7301a281a03a1fa023152c50182ccbeea31dd331b105',
                'start_line' => 70,
                'end_line' => 116,
              ),
            ),
          ),
        ),
      ),
    ),
    14 => 
    array (
      'slug' => 'enfer',
      'display_name' => 'Enfer',
      'description' => '',
      'api_key_env' => 'ENFER_API_KEY',
      'base_url' => 'https://api.enfer.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    15 => 
    array (
      'slug' => 'featherless',
      'display_name' => 'Featherless',
      'description' => '',
      'api_key_env' => 'FEATHERLESS_API_KEY',
      'base_url' => 'https://api.featherless.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    16 => 
    array (
      'slug' => 'fireworks',
      'display_name' => 'Fireworks',
      'description' => '',
      'api_key_env' => 'FIREWORKS_API_KEY',
      'base_url' => 'https://api.fireworks.ai/inference/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    17 => 
    array (
      'slug' => 'friendli',
      'display_name' => 'Friendli',
      'description' => '',
      'api_key_env' => 'FRIENDLI_TOKEN',
      'base_url' => 'https://api.friendli.ai/serverless/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    18 => 
    array (
      'slug' => 'gemini',
      'display_name' => 'Google Gemini',
      'description' => 'Gemini API with File Search and text-embedding-004.',
      'api_key_env' => 'GOOGLE_API_KEY',
      'base_url' => 'https://generativelanguage.googleapis.com/v1beta/openai',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => true,
        'byok' => true,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
        'text-embedding-004' => 3072,
      ),
      'preferred_vector_store' => 'gemini-file-search',
      'default_models' => 
      array (
        'generation' => 'gemini-2.0-flash-exp',
        'embedding' => 'text-embedding-004',
      ),
      'default_solution' => 
      array (
        'type' => 'gemini-file-search',
        'vector_store' => 
        array (
          'corpus' => 'default',
        ),
      ),
      'metadata' => 
      array (
        'tier' => 'paid',
        'latency' => 'medium',
        'insights' => 
        array (
          'google-gemini-flash' => 
          array (
            'slug' => 'google-gemini-flash',
            'name' => 'Google AI Studio â€“ Gemini 2.5 Flash',
            'category' => 'llm',
            'reset_window' => 'daily_midnight_pt',
            'commercial_use' => 'Permits production prototyping without a credit card; governed by Gemini API ToS.',
            'notes' => 'Gemini 2.5 Flash leads the renewable free tier list with 250 RPD, 10 RPM, and a multimodal 2M-token context. Gemini 2.5 Pro and Gemma models stay available under the same API key for heavier jobs.',
            'modalities' => 
            array (
              0 => 'text',
              1 => 'vision',
              2 => 'audio',
            ),
            'recommended_roles' => 
            array (
              0 => 'frontline_free_llm',
              1 => 'fallback_multimodal',
            ),
            'free_tier' => 
            array (
              'requests_per_day' => 250,
              'requests_per_minute' => 10,
              'tokens_per_minute' => 250000,
              'context_tokens' => 2000000,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/01-gem.md',
                'sha256' => '861c4f4e4f5fef6d088fa1a1987b0084c3e6f0b1aa28e7a6d0d03e87a7559832',
                'start_line' => 110,
                'end_line' => 125,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/01-cla.md',
                'sha256' => 'cb1512796cd191d08bd422eeb56dd112139c6f691eefd988d57f09d3cd675a03',
                'start_line' => 13,
                'end_line' => 16,
              ),
            ),
          ),
          'google-gemini-embedding' => 
          array (
            'slug' => 'google-gemini-embedding',
            'name' => 'Google Gemini Embedding API (gemini-embedding-001)',
            'category' => 'embedding',
            'reset_window' => 'daily',
            'commercial_use' => 'Allowed under Gemini API policies with renewable limits for production workloads.',
            'notes' => 'Google advertises completely free embedding throughput; practical rate limits are 1,000 RPD and 100 RPM, easily covering 20k+ daily embeddings.',
            'modalities' => 
            array (
              0 => 'embedding',
            ),
            'recommended_roles' => 
            array (
              0 => 'frontline_embeddings',
              1 => 'zero_cost_embeddings',
            ),
            'free_tier' => 
            array (
              'requests_per_day' => 1000,
              'requests_per_minute' => 100,
              'tokens_per_minute' => 30000,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/02-gpt.md',
                'sha256' => '590f026b4ff8e485756a5f03d5df1535369a1c9860f72f8ce13f7280921a71fa',
                'start_line' => 158,
                'end_line' => 165,
              ),
              1 => 
              array (
                'path' => 'reference/research-embedding/emb-cla.md',
                'sha256' => 'be957503605ddc97af43a28adde1a95240ef549297d783e2240049239a4a59bf',
                'start_line' => 205,
                'end_line' => 227,
              ),
            ),
          ),
          'google-gemini-file-search' => 
          array (
            'slug' => 'google-gemini-file-search',
            'name' => 'Google Gemini API â€“ File Search Tool',
            'category' => 'rag_tool',
            'reset_window' => 'project_storage_limits',
            'commercial_use' => 'Available to Gemini API projects without additional contracts; follows Gemini API ToS.',
            'notes' => 'File Search is a fully managed RAG pipeline that handles chunking, Gemini Embedding generation, retrieval, and inline citations. Storage plus query-time embeddings are free; only the initial indexing embeddings incur costs, and stores keep latency low when under ~20 GB.',
            'modalities' => 
            array (
              0 => 'rag',
              1 => 'vector_store',
              2 => 'tool',
            ),
            'recommended_roles' => 
            array (
              0 => 'managed_file_rag',
              1 => 'gemini_pool_seed',
              2 => 'citation_first',
            ),
            'free_tier' => 
            array (
              'max_file_mb' => 100,
              'store_quota_gb_free' => 1,
              'store_quota_gb_tier1' => 10,
              'store_quota_gb_tier2' => 100,
              'store_quota_gb_tier3' => 1000,
              'embedding_index_cost_per_million_tokens_usd' => '$0.15',
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-rag/ragres-13.md',
                'sha256' => 'bc9b8d398315e7aecff0cef10d6a39498848d03d2473d394f52c34293ed20005',
                'start_line' => 9,
                'end_line' => 16,
              ),
            ),
          ),
        ),
      ),
    ),
    19 => 
    array (
      'slug' => 'groq',
      'display_name' => 'Groq',
      'description' => 'Ultra-low latency OpenAI-compatible endpoint for Llama/Mixtral.',
      'api_key_env' => 'GROQ_API_KEY',
      'base_url' => 'https://api.groq.com/openai/v1',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => true,
      ),
      'model_count' => 21,
      'models' => 
      array (
        0 => 'allam-2-7b',
        1 => 'deepseek-r1-distill-llama-70b',
        2 => 'gemma2-9b-it',
        3 => 'groq/compound',
        4 => 'groq/compound-mini',
        5 => 'llama-3.1-8b-instant',
        6 => 'llama-3.3-70b-versatile',
        7 => 'meta-llama/llama-4-maverick-17b-128e-instruct',
        8 => 'meta-llama/llama-4-scout-17b-16e-instruct',
        9 => 'meta-llama/llama-guard-4-12b',
        10 => 'meta-llama/llama-prompt-guard-2-22m',
        11 => 'meta-llama/llama-prompt-guard-2-86m',
        12 => 'moonshotai/kimi-k2-instruct',
        13 => 'moonshotai/kimi-k2-instruct-0905',
        14 => 'openai/gpt-oss-20b',
        15 => 'openai/gpt-oss-120b',
        16 => 'playai-tts',
        17 => 'playai-tts-arabic',
        18 => 'qwen/qwen3-32b',
        19 => 'whisper-large-v3',
        20 => 'whisper-large-v3-turbo',
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'ragie',
      'default_models' => 
      array (
        'generation' => 'llama-3.1-70b-versatile',
        'fast_generation' => 'llama-3.1-8b-instant',
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'low',
        'insights' => 
        array (
          'groq-llama' => 
          array (
            'slug' => 'groq-llama',
            'name' => 'Groq Cloud â€“ Llama family',
            'category' => 'llm',
            'reset_window' => 'daily',
            'commercial_use' => 'Explicitly allowed for production once workloads fit inside free tiers; higher paid tiers available.',
            'notes' => 'Groq\'s LPU-backed inference prioritizes speed with 14,400 RPD for Llama 3.1 8B, 1,000 RPD for Llama 3.3 70B, and 2,000 RPD for Whisper v3 transcription, all resetting daily.',
            'modalities' => 
            array (
              0 => 'text',
              1 => 'audio',
            ),
            'recommended_roles' => 
            array (
              0 => 'latency_critical_llm',
              1 => 'fallback_llm',
            ),
            'free_tier' => 
            array (
              'requests_per_minute' => 40,
              'models' => 
              array (
                0 => 
                array (
                  'model' => 'llama-3.1-8b',
                  'requests_per_day' => 14400,
                  'tokens_per_minute' => 6000,
                ),
                1 => 
                array (
                  'model' => 'llama-3.3-70b',
                  'requests_per_day' => 1000,
                  'tokens_per_minute' => 12000,
                ),
              ),
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/01-gem.md',
                'sha256' => '861c4f4e4f5fef6d088fa1a1987b0084c3e6f0b1aa28e7a6d0d03e87a7559832',
                'start_line' => 152,
                'end_line' => 160,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/01-cla.md',
                'sha256' => 'cb1512796cd191d08bd422eeb56dd112139c6f691eefd988d57f09d3cd675a03',
                'start_line' => 15,
                'end_line' => 19,
              ),
            ),
          ),
        ),
      ),
    ),
    20 => 
    array (
      'slug' => 'huggingface',
      'display_name' => 'Huggingface',
      'description' => '',
      'api_key_env' => 'HUGGINGFACEHUB_API_TOKEN',
      'base_url' => 'https://router.huggingface.co/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    21 => 
    array (
      'slug' => 'hyperbolic',
      'display_name' => 'Hyperbolic',
      'description' => '',
      'api_key_env' => 'HYPERBOLIC_API_KEY',
      'base_url' => 'https://api.hyperbolic.xyz/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    22 => 
    array (
      'slug' => 'inference',
      'display_name' => 'Inference',
      'description' => '',
      'api_key_env' => 'INFERENCENET_API_KEY',
      'base_url' => 'https://api.inference.net/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    23 => 
    array (
      'slug' => 'infermatic',
      'display_name' => 'Infermatic',
      'description' => '',
      'api_key_env' => 'INFERMATIC_API_KEY',
      'base_url' => 'https://api.totalgpt.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    24 => 
    array (
      'slug' => 'litellm',
      'display_name' => 'Litellm',
      'description' => '',
      'api_key_env' => NULL,
      'base_url' => 'https://raw.githubusercontent.com/BerriAI/litellm/main/model_prices_and_context_window.json',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    25 => 
    array (
      'slug' => 'llm7',
      'display_name' => 'Llm7',
      'description' => '',
      'api_key_env' => 'LLM7_API_KEY',
      'base_url' => 'https://api.llm7.io/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    26 => 
    array (
      'slug' => 'lmstudio',
      'display_name' => 'Lmstudio',
      'description' => '',
      'api_key_env' => 'LMSTUDIO_API_KEY',
      'base_url' => 'http://othello.local:1234/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    27 => 
    array (
      'slug' => 'mancer',
      'display_name' => 'Mancer',
      'description' => '',
      'api_key_env' => 'MANCER_API_KEY',
      'base_url' => 'https://neuro.mancer.tech/oai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    28 => 
    array (
      'slug' => 'mistral',
      'display_name' => 'Mistral AI',
      'description' => 'La Plateforme access to Mixtral + Large models under the experiment tier.',
      'api_key_env' => 'MISTRAL_API_KEY',
      'base_url' => 'https://api.mistral.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'ragie',
      'default_models' => 
      array (
        'generation' => 'mistral-large-latest',
        'fast_generation' => 'mistral-small-latest',
        'embedding' => 'mistral-embed',
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
        'insights' => 
        array (
          'mistral-la-plateforme' => 
          array (
            'slug' => 'mistral-la-plateforme',
            'name' => 'Mistral La Plateforme â€“ Experiment tier',
            'category' => 'llm',
            'reset_window' => 'hybrid_daily_monthly',
            'commercial_use' => 'Free tier restricted to prototyping with opt-in data training; production traffic requires upgrade.',
            'notes' => 'Mistral confirms a renewable but restrictive experiment tier (~1B tokens/day, 500K TPM, 1 RPS) plus a Codestral-specific cap of 2,000 RPD. Actual dashboards hide precise per-model numbers until signup.',
            'modalities' => 
            array (
              0 => 'text',
              1 => 'code',
              2 => 'vision',
            ),
            'recommended_roles' => 
            array (
              0 => 'eu_resident_llm',
              1 => 'evaluation_only',
            ),
            'free_tier' => 
            array (
              'tokens_per_day' => 1000000000,
              'tokens_per_minute' => 500000,
              'requests_per_second' => 1,
              'codestral_requests_per_day' => 2000,
              'codestral_requests_per_minute' => 30,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/01-gem.md',
                'sha256' => '861c4f4e4f5fef6d088fa1a1987b0084c3e6f0b1aa28e7a6d0d03e87a7559832',
                'start_line' => 134,
                'end_line' => 140,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/02-gem.md',
                'sha256' => '77c5d13b3146293f609cb47811f22848b814e83d2d8ad83e46e5831a1831d4e4',
                'start_line' => 15,
                'end_line' => 21,
              ),
            ),
          ),
        ),
      ),
    ),
    29 => 
    array (
      'slug' => 'moonshot',
      'display_name' => 'Moonshot',
      'description' => '',
      'api_key_env' => 'MOONSHOT_API_KEY',
      'base_url' => 'https://api.moonshot.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    30 => 
    array (
      'slug' => 'morphllm',
      'display_name' => 'Morphllm',
      'description' => '',
      'api_key_env' => 'MORPHLLM_API_KEY',
      'base_url' => 'https://api.morphllm.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    31 => 
    array (
      'slug' => 'nebius',
      'display_name' => 'Nebius',
      'description' => '',
      'api_key_env' => 'NEBIUS_API_KEY',
      'base_url' => 'https://api.studio.nebius.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    32 => 
    array (
      'slug' => 'nineteenai',
      'display_name' => 'Nineteenai',
      'description' => '',
      'api_key_env' => 'NINETEENAI_API_KEY',
      'base_url' => 'https://api.nineteen.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    33 => 
    array (
      'slug' => 'novita',
      'display_name' => 'Novita',
      'description' => '',
      'api_key_env' => 'NOVITA_API_KEY',
      'base_url' => 'https://api.novita.ai/v3/openai',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    34 => 
    array (
      'slug' => 'openai',
      'display_name' => 'OpenAI',
      'description' => 'Flagship GPT-4o/4.1 models plus moderation + embeddings.',
      'api_key_env' => 'OPENAI_API_KEY',
      'base_url' => 'https://api.openai.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => false,
        'moderation' => true,
        'image_generation' => true,
        'byok' => false,
      ),
      'model_count' => 83,
      'models' => 
      array (
        0 => 'babbage-002',
        1 => 'chatgpt-4o-latest',
        2 => 'dall-e-2',
        3 => 'dall-e-3',
        4 => 'davinci-002',
        5 => 'gpt-3.5-turbo',
        6 => 'gpt-3.5-turbo-0125',
        7 => 'gpt-3.5-turbo-16k',
        8 => 'gpt-3.5-turbo-1106',
        9 => 'gpt-3.5-turbo-instruct',
        10 => 'gpt-3.5-turbo-instruct-0914',
        11 => 'gpt-4',
        12 => 'gpt-4-0125-preview',
        13 => 'gpt-4-0613',
        14 => 'gpt-4-1106-preview',
        15 => 'gpt-4-turbo',
        16 => 'gpt-4-turbo-2024-04-09',
        17 => 'gpt-4-turbo-preview',
        18 => 'gpt-4.1',
        19 => 'gpt-4.1-2025-04-14',
        20 => 'gpt-4.1-mini',
        21 => 'gpt-4.1-mini-2025-04-14',
        22 => 'gpt-4.1-nano',
        23 => 'gpt-4.1-nano-2025-04-14',
        24 => 'gpt-4o',
        25 => 'gpt-4o-2024-05-13',
        26 => 'gpt-4o-2024-08-06',
        27 => 'gpt-4o-2024-11-20',
        28 => 'gpt-4o-audio-preview',
        29 => 'gpt-4o-audio-preview-2024-10-01',
        30 => 'gpt-4o-audio-preview-2024-12-17',
        31 => 'gpt-4o-audio-preview-2025-06-03',
        32 => 'gpt-4o-mini',
        33 => 'gpt-4o-mini-2024-07-18',
        34 => 'gpt-4o-mini-audio-preview',
        35 => 'gpt-4o-mini-audio-preview-2024-12-17',
        36 => 'gpt-4o-mini-realtime-preview',
        37 => 'gpt-4o-mini-realtime-preview-2024-12-17',
        38 => 'gpt-4o-mini-search-preview',
        39 => 'gpt-4o-mini-search-preview-2025-03-11',
        40 => 'gpt-4o-mini-transcribe',
        41 => 'gpt-4o-mini-tts',
        42 => 'gpt-4o-realtime-preview',
        43 => 'gpt-4o-realtime-preview-2024-10-01',
        44 => 'gpt-4o-realtime-preview-2024-12-17',
        45 => 'gpt-4o-realtime-preview-2025-06-03',
        46 => 'gpt-4o-search-preview',
        47 => 'gpt-4o-search-preview-2025-03-11',
        48 => 'gpt-4o-transcribe',
        49 => 'gpt-5',
        50 => 'gpt-5-2025-08-07',
        51 => 'gpt-5-chat-latest',
        52 => 'gpt-5-mini',
        53 => 'gpt-5-mini-2025-08-07',
        54 => 'gpt-5-nano',
        55 => 'gpt-5-nano-2025-08-07',
        56 => 'gpt-audio',
        57 => 'gpt-audio-2025-08-28',
        58 => 'gpt-image-1',
        59 => 'gpt-realtime',
        60 => 'gpt-realtime-2025-08-28',
        61 => 'o1',
        62 => 'o1-2024-12-17',
        63 => 'o1-mini',
        64 => 'o1-mini-2024-09-12',
        65 => 'o1-pro',
        66 => 'o1-pro-2025-03-19',
        67 => 'o3',
        68 => 'o3-2025-04-16',
        69 => 'o3-mini',
        70 => 'o3-mini-2025-01-31',
        71 => 'o4-mini',
        72 => 'o4-mini-2025-04-16',
        73 => 'omni-moderation-2024-09-26',
        74 => 'omni-moderation-latest',
        75 => 'text-embedding-3-large',
        76 => 'text-embedding-3-small',
        77 => 'text-embedding-ada-002',
        78 => 'tts-1',
        79 => 'tts-1-1106',
        80 => 'tts-1-hd',
        81 => 'tts-1-hd-1106',
        82 => 'whisper-1',
      ),
      'embedding_dimensions' => 
      array (
        'text-embedding-3-small' => 1536,
        'text-embedding-3-large' => 3072,
      ),
      'preferred_vector_store' => 'ragie',
      'default_models' => 
      array (
        'generation' => 'gpt-4o-mini',
        'fast_generation' => 'gpt-4o-mini',
        'embedding' => 'text-embedding-3-small',
        'moderation' => 'omni-moderation-latest',
      ),
      'default_solution' => 
      array (
        'type' => 'ragie',
        'ragie_partition' => 'default',
        'default_options' => 
        array (
          'top_k' => 8,
          'rerank' => true,
        ),
      ),
      'metadata' => 
      array (
        'tier' => 'paid',
        'latency' => 'medium',
      ),
    ),
    35 => 
    array (
      'slug' => 'openrouter',
      'display_name' => 'OpenRouter',
      'description' => 'Router for 60+ hosted LLMs with renewable communal credits.',
      'api_key_env' => 'OPENROUTER_API_KEY',
      'base_url' => 'https://openrouter.ai/api/v1',
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => true,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
        'generation' => 'meta-llama/llama-3.1-70b-instruct',
        'fast_generation' => 'qwen/qwen-2.5-14b-instruct',
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
        'insights' => 
        array (
          'openrouter' => 
          array (
            'slug' => 'openrouter',
            'name' => 'OpenRouter Free Aggregator',
            'category' => 'llm_router',
            'reset_window' => 'daily_utc',
            'commercial_use' => 'Allowed but subject to each upstream model license; aggregator enforces data-usage disclosures.',
            'notes' => 'OpenRouter routes to 50+ sponsor-backed models (DeepSeek, Llama, Mistral, Qwen, Gemma). Rate limits apply across the shared :free pool, making it ideal for comparative testing.',
            'modalities' => 
            array (
              0 => 'text',
              1 => 'vision',
              2 => 'audio',
            ),
            'recommended_roles' => 
            array (
              0 => 'multi_model_experiments',
              1 => 'fallback_llm',
            ),
            'free_tier' => 
            array (
              'requests_per_day' => 50,
              'requests_per_minute' => 20,
              'upgrade_requests_per_day' => 1000,
              'upgrade_condition' => '$10 lifetime top-up unlocks 1,000 RPD across :free endpoints',
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/01-cla.md',
                'sha256' => 'cb1512796cd191d08bd422eeb56dd112139c6f691eefd988d57f09d3cd675a03',
                'start_line' => 18,
                'end_line' => 21,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/02-gem.md',
                'sha256' => '77c5d13b3146293f609cb47811f22848b814e83d2d8ad83e46e5831a1831d4e4',
                'start_line' => 13,
                'end_line' => 20,
              ),
            ),
          ),
        ),
      ),
    ),
    36 => 
    array (
      'slug' => 'parasail',
      'display_name' => 'Parasail',
      'description' => '',
      'api_key_env' => 'PARASAIL_API_KEY',
      'base_url' => 'https://api.parasail.io/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    37 => 
    array (
      'slug' => 'perplexity',
      'display_name' => 'Perplexity',
      'description' => '',
      'api_key_env' => 'PERPLEXITYAI_API_KEY',
      'base_url' => 'https://api.perplexity.ai',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    38 => 
    array (
      'slug' => 'pinecone',
      'display_name' => 'Pinecone',
      'description' => 'Managed vector store with starter pods for prototypes.',
      'api_key_env' => 'PINECONE_API_KEY',
      'base_url' => 'https://controller.us-east1-gcp.pinecone.io',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'pinecone',
      'default_models' => 
      array (
      ),
      'default_solution' => 
      array (
        'type' => 'pinecone',
      ),
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
        'insights' => 
        array (
          'pinecone-starter' => 
          array (
            'slug' => 'pinecone-starter',
            'name' => 'Pinecone Starter Vector DB',
            'category' => 'vector_database',
            'reset_window' => 'monthly',
            'commercial_use' => 'Starter tier supports production prototypes; additional throughput available via paid serverless tiers.',
            'notes' => 'Pinecone\'s Starter tier offers 2 GB storage, around a million 768-d vectors, and millions of monthly read/write units focused on AWS us-east-1. Ideal for validating retrieval pipelines before upgrading.',
            'modalities' => 
            array (
              0 => 'vector_store',
            ),
            'recommended_roles' => 
            array (
              0 => 'primary_vector_store',
              1 => 'starter_rag_stack',
            ),
            'free_tier' => 
            array (
              'storage_gb' => 2,
              'indexes' => 1,
              'write_units_per_month' => 2000000,
              'read_units_per_month' => 1000000,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/02-gpt.md',
                'sha256' => '590f026b4ff8e485756a5f03d5df1535369a1c9860f72f8ce13f7280921a71fa',
                'start_line' => 166,
                'end_line' => 174,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/02-gem.md',
                'sha256' => '77c5d13b3146293f609cb47811f22848b814e83d2d8ad83e46e5831a1831d4e4',
                'start_line' => 73,
                'end_line' => 78,
              ),
            ),
          ),
        ),
      ),
    ),
    39 => 
    array (
      'slug' => 'poe',
      'display_name' => 'Poe',
      'description' => '',
      'api_key_env' => 'POE_API_KEY',
      'base_url' => 'https://api.poe.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    40 => 
    array (
      'slug' => 'pollinations',
      'display_name' => 'Pollinations',
      'description' => '',
      'api_key_env' => 'POLLINATIONS_API_KEY',
      'base_url' => 'https://text.pollinations.ai/openai',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    41 => 
    array (
      'slug' => 'qdrant',
      'display_name' => 'Qdrant Serverless',
      'description' => 'Fully-managed vector store with forever-free tier.',
      'api_key_env' => 'QDRANT_API_KEY',
      'base_url' => 'https://api.qdrant.tech',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'qdrant',
      'default_models' => 
      array (
      ),
      'default_solution' => 
      array (
        'type' => 'qdrant',
      ),
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
        'insights' => 
        array (
          'qdrant-cloud-free' => 
          array (
            'slug' => 'qdrant-cloud-free',
            'name' => 'Qdrant Cloud Free Cluster',
            'category' => 'vector_database',
            'reset_window' => 'permanent',
            'commercial_use' => 'Free forever for active clusters; production allowed while usage stays within limits.',
            'notes' => 'Qdrant Cloud\'s 1 GB permanent tier covers roughly one million 768-d vectors and needs periodic traffic to avoid suspension, making it a perfect safety net for budget RAG deployments.',
            'modalities' => 
            array (
              0 => 'vector_store',
            ),
            'recommended_roles' => 
            array (
              0 => 'forever_free_vector',
              1 => 'fallback_vector_store',
            ),
            'free_tier' => 
            array (
              'storage_gb' => 1,
              'vector_capacity' => 1000000,
              'suspension_policy' => 'Clusters pause after ~7 idle days and purge after ~4 weeks of inactivity',
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-ai-api/02-gpt.md',
                'sha256' => '590f026b4ff8e485756a5f03d5df1535369a1c9860f72f8ce13f7280921a71fa',
                'start_line' => 171,
                'end_line' => 175,
              ),
              1 => 
              array (
                'path' => 'reference/research-ai-api/02-gem.md',
                'sha256' => '77c5d13b3146293f609cb47811f22848b814e83d2d8ad83e46e5831a1831d4e4',
                'start_line' => 75,
                'end_line' => 78,
              ),
            ),
          ),
        ),
      ),
    ),
    42 => 
    array (
      'slug' => 'ragie',
      'display_name' => 'Ragie',
      'description' => 'Primary retrieval layer powering ParaGra.',
      'api_key_env' => 'RAGIE_API_KEY',
      'base_url' => 'https://api.ragie.ai',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => 'ragie',
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'paid',
        'latency' => 'medium',
      ),
    ),
    43 => 
    array (
      'slug' => 'redpill',
      'display_name' => 'Redpill',
      'description' => '',
      'api_key_env' => 'REDPILL_API_KEY',
      'base_url' => 'https://api.redpill.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    44 => 
    array (
      'slug' => 'sambanova',
      'display_name' => 'Sambanova',
      'description' => '',
      'api_key_env' => 'SAMBANOVA_API_KEY',
      'base_url' => 'https://api.sambanova.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    45 => 
    array (
      'slug' => 'siliconflow',
      'display_name' => 'Siliconflow',
      'description' => '',
      'api_key_env' => 'SILICONFLOW_API_KEY',
      'base_url' => 'https://api.siliconflow.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    46 => 
    array (
      'slug' => 'targon',
      'display_name' => 'Targon',
      'description' => '',
      'api_key_env' => 'TARGON_API_KEY',
      'base_url' => 'https://api.targon.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    47 => 
    array (
      'slug' => 'togetherai',
      'display_name' => 'Togetherai',
      'description' => '',
      'api_key_env' => 'TOGETHERAI_API_KEY',
      'base_url' => 'https://api.together.xyz/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    48 => 
    array (
      'slug' => 'vectara',
      'display_name' => 'Vectara',
      'description' => 'Managed RAG stack with ingestion, hallucination defense, and Cerebras/OpenAI routing.',
      'api_key_env' => NULL,
      'base_url' => NULL,
      'capabilities' => 
      array (
        'llm_chat' => true,
        'embeddings' => true,
        'vector_store' => true,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'hosted',
        'latency' => 'medium',
        'insights' => 
        array (
          'vectara-platform' => 
          array (
            'slug' => 'vectara-platform',
            'name' => 'Vectara Managed RAG Platform',
            'category' => 'hosted_rag',
            'reset_window' => 'subscription',
            'commercial_use' => 'SOC 2/ISO-ready managed service with 30-day evaluation followed by paid contracts.',
            'notes' => 'Vectara bundles ingestion, hallucination defenses, and routing into Cerebras/OpenAI stacks so teams can deploy full RAG chatbots in hours. The managed backend handles chunking, citation UX, and autoscaling once the paid tier activates.',
            'modalities' => 
            array (
              0 => 'rag',
              1 => 'llm_router',
            ),
            'recommended_roles' => 
            array (
              0 => 'hosted_enterprise_rag',
              1 => 'hallucination_guardrails',
            ),
            'free_tier' => 
            array (
              'trial_days' => 30,
              'estimated_monthly_cost_usd_min' => 500,
              'estimated_monthly_cost_usd_max' => 2000,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-rag/ragres-07.md',
                'sha256' => '7a3dfd6b76169a6ac833c2005bbd818cd8c29b9739f78a1a815ecb0239b297cd',
                'start_line' => 70,
                'end_line' => 80,
              ),
              1 => 
              array (
                'path' => 'reference/research-rag/ragres-07.md',
                'sha256' => '7a3dfd6b76169a6ac833c2005bbd818cd8c29b9739f78a1a815ecb0239b297cd',
                'start_line' => 185,
                'end_line' => 210,
              ),
            ),
          ),
        ),
      ),
    ),
    49 => 
    array (
      'slug' => 'voyage',
      'display_name' => 'Voyage AI',
      'description' => 'High-quality embeddings + rerankers tuned for reasoning tasks.',
      'api_key_env' => 'VOYAGE_API_KEY',
      'base_url' => 'https://api.voyageai.com/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => true,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
        'voyage-3-large' => 3072,
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
        'embedding' => 'voyage-3-large',
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
        'tier' => 'free',
        'latency' => 'medium',
        'insights' => 
        array (
          'voyage-embeddings' => 
          array (
            'slug' => 'voyage-embeddings',
            'name' => 'Voyage AI Embedding API',
            'category' => 'embedding',
            'reset_window' => 'one_time_credit_then_payg',
            'commercial_use' => 'Allowed; generous starter credit encourages production migrations after testing.',
            'notes' => 'Voyage grants 200M free tokens on signup, then charges roughly $0.10â€“$0.40 per million tokens for voyage-3-large, making it ideal for massive initial indexing jobs before pay-as-you-go kicks in.',
            'modalities' => 
            array (
              0 => 'embedding',
              1 => 'rerank',
            ),
            'recommended_roles' => 
            array (
              0 => 'high_volume_embeddings',
              1 => 'code_search',
            ),
            'free_tier' => 
            array (
              'one_time_tokens' => 200000000,
              'paid_rate_per_million_tokens_usd_min' => 0,
              'paid_rate_per_million_tokens_usd_max' => 0,
            ),
            'sources' => 
            array (
              0 => 
              array (
                'path' => 'reference/research-embedding/emb-gro.md',
                'sha256' => '79fbcaffbd639353efd330596d8d5c1421df7df2d2b2724f69770816b3effa3b',
                'start_line' => 55,
                'end_line' => 70,
              ),
            ),
          ),
        ),
      ),
    ),
    50 => 
    array (
      'slug' => 'xai',
      'display_name' => 'Xai',
      'description' => '',
      'api_key_env' => 'XAI_API_KEY',
      'base_url' => 'https://api.x.ai/v1',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
    51 => 
    array (
      'slug' => 'zai',
      'display_name' => 'Zai',
      'description' => '',
      'api_key_env' => 'ZAI_API_KEY',
      'base_url' => 'https://api.z.ai/api/paas/v4',
      'capabilities' => 
      array (
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
      ),
      'model_count' => 0,
      'models' => 
      array (
      ),
      'embedding_dimensions' => 
      array (
      ),
      'preferred_vector_store' => NULL,
      'default_models' => 
      array (
      ),
      'default_solution' => NULL,
      'metadata' => 
      array (
      ),
    ),
  ),
);
</document_content>
</document>

<document index="9">
<source>docs/api.md</source>
<document_content>
---
this_file: paragra-php/docs/api.md
---

# ParaGra API Reference

This summary covers the primary entry points exposed by `/Users/adam/Developer/vcs/github.twardoch/pub/rag-projects/paragra-php`.

## ParaGra\ParaGra

| Method | Description |
| --- | --- |
| `__construct(PriorityPool $pools, ProviderFactory $factory, ?FallbackStrategy $fallback = null)` | Usually created via `fromConfig()`. Accepts injected factories for testing. |
| `static fromConfig(array $config): self` | Parses the `priority_pools` structure and builds default factories. |
| `withModeration(ModeratorInterface $moderator): self` | Enables moderation before every `retrieve()`/`answer()` call. Returns `$this` for chaining. |
| `retrieve(string $query, array $options = []): UnifiedResponse` | Sanitizes input, enforces moderation, runs fallback strategy, and returns normalized chunks. |
| `answer(string $question, array $options = []): array` | Runs retrieval, builds the prompt, calls `NeuronAiAdapter`, and returns `['answer','prompt','context','metadata']`. |

## Config layer

- `ParaGra\Config\PriorityPool::fromArray(array $pools): self` â€” Validates the nested pool definition.
- `ParaGra\Config\ProviderSpec::fromArray(array $spec): self` â€” Validates provider name, model, API key, and solution metadata.

## ProviderFactory & adapters

- `ProviderFactory::createProvider(ProviderSpec $spec): ProviderInterface`
  - Returns one of:
    - `RagieProvider` â€” Wraps `ragie/ragie-php` retrieval.
    - `GeminiFileSearchProvider` â€” Calls Google AI Platform File Search.
    - `AskYodaProvider` â€” Hits EdenAI AskYoda endpoints.
- `ProviderFactory::createLlmClient(ProviderSpec $spec): NeuronAiAdapter`
  - Builds a chat client for OpenAI, Gemini, Anthropic, Groq, etc., based on `provider` + `model`.

## Router utilities

- `Router\KeyRotator::currentProvider(PriorityPool $pool): ProviderSpec` â€” Deterministic rotation among providers in a single pool.
- `Router\FallbackStrategy::execute(Closure $handler): mixed` â€” Invokes `$handler(ProviderSpec)` for each provider until one succeeds, rotating through pool members according to their metadata-derived family policy (free = exhaust all keys, hybrid = two attempts, hosted = single shot) before escalating to the next pool.

## Response objects

- `Response\UnifiedResponse`
  - `getChunks(): array` â€” Normalized chunk payloads.
  - `getChunkTexts(): array` â€” Memoized list of chunk texts (used by PromptBuilder).
  - `getProviderMetadata(): array` â€” Provider + tier metadata (used by endpoints).
  - `getCost()/getUsage()` â€” Optional runtime reporting.

## Assistant utilities

- `Assistant\RagAnswerer::answer()` â€” Mirrors the historical Ragie helper but now lives in ParaGra so it can reuse rotation, moderation, and AskYoda fallback.
- `Assistant\AskYodaHostedAdapter::ask()` â€” Wraps `Llm\AskYodaClient`, records duration/chunk telemetry, and feeds the hosted fallback data back into `RagAnswerer`.
- `Assistant\AskYodaHostedResult` â€” Convenience DTO returned by the adapter (`getResponse()`, `getDurationMs()`, `getChunkCount()`), making it easy to log fallback telemetry.

## LLM helpers

- `Llm\PromptBuilder::build(string $question, array $chunkTexts): string` â€” Minimal prompt builder used by `answer()`.
- `Llm\NeuronAiAdapter::generate(string $prompt, array $options = []): string` â€” Thin wrapper around `neuron-core/neuron-ai` chat completions.
- `Llm\OpenAiChatConfig::fromEnv()` / `Llm\AskYodaClient::fromEnv()` remain available for low-level use but ParaGra defaults to provider specs.

## Moderation

- `Moderation\OpenAiModerator::fromEnv()` â€” Instantiates the moderation client using `OPENAI_API_KEY`.
- `Moderation\ModeratorInterface::moderate(string $text): ModerationResult` â€” Implement to add alternative moderation suppliers.
- `Moderation\NullModerator` â€” Pass-through helper for tests or trusted deployments.

## Exceptions

- `Exception\ConfigurationException` â€” Thrown when required provider metadata is missing.
- Standard `InvalidArgumentException` is raised when config arrays are malformed or question strings are empty.

Refer to `tests/` for concrete usage of each class; every function in the table is covered by PHPUnit to serve as living documentation.
</document_content>
</document>

<document index="10">
<source>docs/architecture.md</source>
<document_content>
---
this_file: paragra-php/docs/architecture.md
---

# ParaGra Architecture Primer

The ParaGra toolkit in `/Users/adam/Developer/vcs/github.twardoch/pub/rag-projects/paragra-php` keeps orchestration logic outside of app code so Ragie + Gemini + AskYoda stacks share the same runtime guarantees.

```
[User Query]
     |
     v
ParaGra::retrieve()/::answer()
     |
     v
PriorityPool -> KeyRotator -> ProviderFactory
     |
     v
ProviderInterface (Ragie / Gemini / AskYoda)
     |
     v
UnifiedResponse + Optional NeuronAiAdapter completion
```

## Priority pools

- `ParaGra\Config\PriorityPool` parses the nested config array and exposes an ordered list of `ProviderSpec` objects.
- Each **priority pool** represents a pricing/latency tier. Pool `0` typically contains free-tier keys; higher indices are progressively more expensive or more reliable.
- Provider metadata is preserved so responses can expose tier + model info downstream.

## Deterministic rotation

- `ParaGra\Router\KeyRotator` accepts the pool definition plus an optional clock.
- Rotation uses `(timestamp >> 1) + index` to keep even distribution, meaning two keys in the same pool should each receive ~50% of requests over time.
- Tests live in `tests/Router/KeyRotatorTest.php` demonstrating evenness across 2/3/5-key pools.

## Fallback execution

- `ParaGra\Router\FallbackStrategy` takes a `PriorityPool` and `KeyRotator`, then walks each provider in the current pool through a closure you supply.
- Pools inherit attempt budgets from metadata: free-tier pools rotate through every key before falling back, hybrid pools default to two attempts, and hosted pools take a single shot (all of which can be overridden via policy overrides).
- Each failure logs a hashed key fingerprint plus provider/model so you can audit rotation decisions; once a pool exhausts its budget, the next pool is attempted. If all pools fail, the final exception is re-thrown with prior errors attached in `metadata['fallback_errors']`.

## Retrieval pipeline

1. ParaGra sanitizes the question and optionally runs `ModeratorInterface::moderate()`.
2. FallbackStrategy calls the configured provider's `retrieve()` implementation:
   - `RagieProvider` â†’ uses `Ragie\Client` to fetch `RetrievalResult`.
   - `GeminiFileSearchProvider` â†’ issues HTTP requests against Google AI Platform.
   - `AskYodaProvider` â†’ hits EdenAI AskYoda endpoints.
3. Each provider returns a `UnifiedResponse` object so chunk metadata stays consistent.

## Answer pipeline

When you call `ParaGra::answer()`:

1. Retrieval runs as above and yields a `UnifiedResponse`.
2. `PromptBuilder` builds a prompt from the clean question + chunk texts.
3. `ProviderFactory::createLlmClient()` hands back a `NeuronAiAdapter`, which wraps `neuron-core/neuron-ai` to talk to the LLM provider indicated by the current `ProviderSpec`.
4. The final payload contains `answer`, `prompt`, `context`, and combined metadata.

## Moderation

- The optional `withModeration(OpenAiModerator::fromEnv())` call enforces OpenAI moderation before retrieval.
- You can implement your own `ModeratorInterface` if you need a different policy.

## Data flow in ask.vexy.art

1. `/public/rag/index.php` loads `private/config/paragra.php`.
2. ParaGra handles provider selection and returns normalized metadata.
3. The endpoint simply serializes `UnifiedResponse` + `answer`, so no provider-specific logic remains in the minisite.

Use this doc alongside `docs/configuration.md` to reason about where to add new providers or rotation strategies without touching application code.
</document_content>
</document>

<document index="11">
<source>docs/configuration.md</source>
<document_content>
---
this_file: paragra-php/docs/configuration.md
---

# ParaGra Configuration Guide

Working within `paragra-php`, this guide explains how to populate `config/paragra.php` so ParaGra can rotate keys and fail over across multiple Retrieval-Augmented Generation (RAG) providers.

## 1. Copy the template

```bash
cd paragra-php
cp config/paragra.example.php config/paragra.php
```

Keep the new file out of git and load secrets via `getenv()` or your secrets manager. ParaGra expects `return [...]` at the end of the file.

## 2. Understand the schema

`ParaGra::fromConfig()` receives an array with a `priority_pools` key and, optionally, a pointer to the provider catalog generated by `tools/sync_provider_catalog.php`:

```php
return [
    'provider_catalog' => __DIR__ . '/providers/catalog.php', // optional but recommended
    'priority_pools' => [
        // Pool definitions...
    ],
];
```

### Manual provider specs

Legacy (and still supported) configs can inline the `provider`, `model`, `api_key`, and `solution` keys:

```php
return [
    'priority_pools' => [
        // Pool #1 (free tier keys)
        [
            [
                'provider' => 'cerebras',
                'model' => 'llama-3.3-70b',
                'api_key' => getenv('CEREBRAS_API_KEY_1'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => getenv('RAGIE_API_KEY'),
                ],
            ],
            // add more keys to the same pool for rotation
        ],
        // Pool #2 (paid fallback) ...
    ],
];
```

- **Pools** are ordered lists. Pool `0` is tried first, pool `1` only runs when all providers in pool `0` fail.
- **Providers inside a pool** form a rotation set. `KeyRotator` walks them in a deterministic order (timestamp+index) to keep usage even.
- `provider`, `model`, and `api_key` describe the target LLM host. `solution` configures the retrieval strategy.

### Catalog-backed provider entries

You can now reference any slug from `config/providers/catalog.php` (OpenAI, Cerebras, Gemini, AskYoda, etc.) instead of repeating boilerplate:

```php
return [
    'provider_catalog' => __DIR__ . '/providers/catalog.php',
    'priority_pools' => [
        [
            [
                'catalog' => [
                    'slug' => 'cerebras',
                    'model_type' => 'generation', // optional, defaults to `generation`
                    'overrides' => [
                        'api_key' => (string) getenv('CEREBRAS_API_KEY_1'), // rotate multiple keys
                        'solution' => [
                            'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                        ],
                    ],
                ],
                'latency_tier' => 'low',
                'cost_ceiling' => 0.00,
                'compliance' => ['internal'],
                'metadata_overrides' => ['notes' => 'Preferred free tier slot'],
            ],
        ],
    ],
];
```

`catalog` may also be declared with helper keys:

| Key | Purpose |
| --- | --- |
| `catalog_slug` | Shortcut for `['catalog' => ['slug' => 'openai']]`. |
| `catalog_model_type` | Override the model preset to pull from catalog metadata (`generation`, `embedding`, `fast_generation`, etc.). |
| `catalog_overrides` | Same as `catalog.overrides` but top-level for readability. |

Every catalog-backed entry inherits metadata from the catalog (tier, provider name, capability hints). Use these overrides to tailor responses:

| Key | Effect |
| --- | --- |
| `latency_tier` | Adds/overrides `solution.metadata.latency_tier`. |
| `cost_ceiling` | Adds `solution.metadata.cost_ceiling` so dashboards know when to escalate. |
| `compliance` | Array/string describing regulatory requirements satisfied by the pool. |
| `metadata_overrides` | Free-form metadata merged into the catalog metadata block. |

ParaGra resolves the provider API key using catalog metadata unless you supply `overrides.api_key`. That pattern lets you rotate multiple Cerebras or Ragie keys even when the shared slug points at a single env var.

### Auto-generated pools via PoolBuilder

Maintaining nested arrays is tedious, so a `ParaGra\Planner\PoolBuilder` now ships with presets:

```php
use ParaGra\Planner\PoolBuilder;
use ParaGra\ProviderCatalog\ProviderDiscovery;

$catalogPath = __DIR__ . '/providers/catalog.php';
$catalog = ProviderDiscovery::fromFile($catalogPath);
$builder = PoolBuilder::fromGlobals($catalog);

$options = [
    'ragie_partition' => getenv('RAGIE_PARTITION') ?: 'default',
    'ragie_defaults' => ['top_k' => 8],
];

$config = [
    'provider_catalog' => $catalogPath,
    'priority_pools' => $builder->build(PoolBuilder::PRESET_FREE, $options),
];
```

Available presets:

| Preset | Description | Required env |
| --- | --- | --- |
| `free-tier` | Gemini Flash + Groq rotation with optional Cerebras keys, all backed by Ragie. | `RAGIE_API_KEY`, `GOOGLE_API_KEY`, `GROQ_API_KEY` |
| `hybrid` | Free rotation plus OpenAI/Pinecone fallback. | `RAGIE_API_KEY`, `GOOGLE_API_KEY`, `GROQ_API_KEY`, `OPENAI_API_KEY` |
| `hosted` | AskYoda hosted fallback annotated with Vectara + Bedrock KB insights. | `EDENAI_API_KEY`, `EDENAI_ASKYODA_PROJECT` |

`PoolBuilder` automatically surfaces catalog metadata (free-tier quotas, recommended roles) and throws descriptive exceptions when something is missing, making it a natural fit for configs that live inside `ask.vexy.art` or other apps. The matching CLI (`php tools/pool_builder.php --preset=hybrid --format=json`) emits JSON/PHP payloads when you need to commit a generated config to disk.

## 3. Provider-specific solution keys

| Solution type | Required keys | Optional keys |
| --- | --- | --- |
| `ragie` | `ragie_api_key` | `ragie_base_url`, `ragie_partition`, `default_options.top_k`, `default_options.filter`, `default_options.rerank`, `metadata` |
| `gemini-file-search` | `vector_store.corpus` (from Google AI Platform), `api_key` (defaults to provider `api_key`) | `generation.temperature`, `generation.maxOutputTokens`, `safety.safetySettings`, `metadata` |
| `askyoda` | `askyoda_api_key`, `project_id` | `default_options.k`, `default_options.min_score`, `default_options.temperature`, `default_options.max_tokens`, `llm.provider`, `llm.model`, `metadata` |

Each provider inherits `solution.metadata` so ParaGra can emit tier info (`free`, `paid`, etc.) in responses.

## 4. Environment variables to define

| Env var | Purpose |
| --- | --- |
| `RAGIE_API_KEY`, `RAGIE_PARTITION` | Authenticates Ragie retrieval for all Ragie-backed pools. |
| `CEREBRAS_API_KEY_*` | Publish multiple Cerebras keys (e.g., `_1`, `_2`, `_3`) so pool #1 can rotate across free-tier capacity. |
| `OPENAI_API_KEY` | Paid fallback for Ragie + OpenAI completions. |
| `GOOGLE_API_KEY`, `GEMINI_DATASTORE_ID` (preferred) or `GEMINI_CORPUS_ID`/`GEMINI_VECTOR_STORE` | Access Gemini File Search retrieval + generation. |
| `GEMINI_EMBED_API_KEY`, `GEMINI_EMBED_MODEL`, `GEMINI_EMBED_DIMENSIONS`, `GEMINI_EMBED_MAX_BATCH`, `GEMINI_EMBED_TASK_TYPE`, `GEMINI_EMBED_TITLE` | Optional Gemini embedding provider controls. ParaGra falls back to `GOOGLE_API_KEY` when `GEMINI_EMBED_API_KEY` is unset; overrides are only respected for models that support custom dimensions (`text-embedding-004`). |
| `EDENAI_API_KEY`, `EDENAI_ASKYODA_PROJECT` | Drive AskYoda retrieval fallback. |
| `OPENAI_MODERATION_TRUE` | Set to `1` when hooking `withModeration(OpenAiModerator::fromEnv())`. |

Follow the naming already used inside `ask.vexy.art/private/.env.example` to keep local development and production in sync.

When enriching empty contexts with the `twat-search` fallback, add:

| Env var | Purpose |
| --- | --- |
| `TWAT_SEARCH_BIN` | Path to the `twat-search` binary (defaults to `twat-search`). |
| `TWAT_SEARCH_ENGINES` | Comma-separated engine identifiers (e.g., `brave,duckduckgo,tavily`). |
| `TWAT_SEARCH_NUM_RESULTS`, `TWAT_SEARCH_MAX_RESULTS` | Default per-engine and combined snippet counts used by `TwatSearchRetriever`. |
| `TWAT_SEARCH_CACHE_TTL` | Seconds to keep CLI responses in memory (guards repeated debug calls). |
| `TAVILY_API_KEY`, `BRAVE_API_KEY`, `YOU_API_KEY`, `SERPAPI_API_KEY` | Optional API keys enabling the matching engines inside `twat-search`. |

When enabling optional media providers, add:

| Env var | Purpose |
| --- | --- |
| `CHUTES_API_KEY` | Required Bearer token for your chute. |
| `CHUTES_BASE_URL` | Base URL (e.g., `https://artist-demo.chutes.ai`). |
| `CHUTES_MODEL`, `CHUTES_GUIDANCE`, `CHUTES_STEPS`, `CHUTES_ASPECT_RATIO`, `CHUTES_IMAGES` | Optional overrides passed to `ChutesImageProvider`. |
| `FAL_KEY` | Fal.ai API key. |
| `FAL_MODEL` | Fal model endpoint (e.g., `fal-ai/flux/dev`). |
| `FAL_IMAGES`, `FAL_GUIDANCE`, `FAL_STEPS` | Optional overrides passed to `FalImageProvider`. |

## 5. Validate the configuration

1. Run ParaGra's QA suite:
   ```bash
   cd paragra-php
   composer qa
   ```
2. When wiring ParaGra into `ask.vexy.art`, execute the smoke test:
   ```bash
   php ask.vexy.art/tests/paragra_config_test.php
   ```
3. Keep `config/paragra.php` under 200 lines by extracting repeated provider specs to helper functions if necessary.

ParaGra throws `InvalidArgumentException` when `priority_pools` is missing or malformed, and `ConfigurationException` if a provider spec lacks the required keys. Fix these errors before deploying.

## 6. Secrets hygiene checklist

- Store `.env` under `ask.vexy.art/private/` and load values via `getenv()` inside `config/paragra.php`.
- Avoid dumping API keys inside logs; ParaGra metadata intentionally excludes raw keys.
- If you depend on multiple Ragie partitions, pass `['partition' => 'support']` inside the `default_options` for that provider.

With this structure in place, ParaGra can execute retrieval + answer flows purely from configuration without manual branching in your endpoints.
</document_content>
</document>

<document index="12">
<source>docs/examples.md</source>
<document_content>
---
this_file: paragra-php/docs/examples.md
---

# Configuration & Usage Examples

All examples live inside `/Users/adam/Developer/vcs/github.twardoch/pub/rag-projects/paragra-php/examples`. Copy whichever file matches your deployment and customize the environment variables.

| Scenario | File |
| --- | --- |
| Ragie retrieval + Cerebras rotation | `examples/config/ragie_cerebras.php` |
| Ragie retrieval + OpenAI fallback | `examples/config/ragie_openai.php` |
| Gemini File Search fallback | `examples/config/gemini_file_search.php` |
| EdenAI AskYoda fallback | `examples/config/askyoda.php` |
| Moderated answer flow | `examples/moderated_answer.php` |
| Ragie + twat-search fallback | `examples/external-search/twat_search_fallback.php` |
| Hybrid Ragie + vector store pipeline | `examples/vector-stores/hybrid_pipeline.php` |
| Answer + Chutes illustration | `examples/media/chutes_answer_with_image.php` |
| Answer + Fal.ai illustration | `examples/media/fal_answer_with_image.php` |

## Ragie + Cerebras rotation

```php
return [
    'priority_pools' => [
        [
            [
                'provider' => 'cerebras',
                'model' => 'llama-3.3-70b',
                'api_key' => getenv('CEREBRAS_API_KEY_1'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => getenv('RAGIE_API_KEY'),
                    'default_options' => ['top_k' => 6, 'rerank' => true],
                    'metadata' => ['tier' => 'free'],
                ],
            ],
            [
                'provider' => 'cerebras',
                'model' => 'llama-3.3-70b',
                'api_key' => getenv('CEREBRAS_API_KEY_2'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => getenv('RAGIE_API_KEY'),
                    'metadata' => ['tier' => 'free'],
                ],
            ],
        ],
    ],
];
```

Pool `0` receives all requests. `KeyRotator` alternates between `_1` and `_2` keys, keeping the free tier hot while logs still show which key took each request.

## Ragie + OpenAI fallback

```php
return [
    'priority_pools' => [
        [
            [
                'provider' => 'openai',
                'model' => 'gpt-4o-mini',
                'api_key' => getenv('OPENAI_API_KEY'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => getenv('RAGIE_API_KEY'),
                    'default_options' => ['top_k' => 8, 'rerank' => true],
                    'metadata' => ['tier' => 'paid', 'notes' => 'High reliability'],
                ],
            ],
        ],
    ],
];
```

Use this as pool `1` after the Cerebras pool when you want a fast failover path that still reuses Ragie's corpus.

## Gemini File Search fallback

```php
return [
    'priority_pools' => [
        [
            [
                'provider' => 'gemini',
                'model' => 'gemini-2.0-flash-exp',
                'api_key' => getenv('GOOGLE_API_KEY'),
                'solution' => [
                    'type' => 'gemini-file-search',
                    'vector_store' => [
                        'datastore' => getenv('GEMINI_DATASTORE_ID') ?: getenv('GEMINI_CORPUS_ID'),
                    ],
                    'generation' => ['temperature' => 0.4],
                    'metadata' => ['tier' => 'paid'],
                ],
            ],
        ],
    ],
];
```

This example shows how to bypass Ragie entirely when you want to leverage Google-native corpora as the fallback tier.

## AskYoda fallback

```php
return [
    'priority_pools' => [
        [
            [
                'provider' => 'edenai',
                'model' => 'askyoda',
                'api_key' => getenv('EDENAI_API_KEY'),
                'solution' => [
                    'type' => 'askyoda',
                    'askyoda_api_key' => getenv('EDENAI_API_KEY'),
                    'project_id' => getenv('EDENAI_ASKYODA_PROJECT'),
                    'default_options' => ['k' => 10, 'min_score' => 0.35],
                    'llm' => ['provider' => 'google', 'model' => 'gemini-1.5-flash'],
                    'metadata' => ['tier' => 'paid'],
                ],
            ],
        ],
    ],
];
```

Pair this pool with Ragie pools so the system automatically switches to AskYoda when Ragie returns HTTP 429 or when you explicitly move traffic there.

## Moderated answer flow

Run the example script to see moderation hooked into ParaGra:

```bash
cd paragra-php
php examples/moderated_answer.php "Summarize the ParaGra roadmap"
```

The script:

- Loads the Ragie + Cerebras config.
- Builds `ParaGra` + `OpenAiModerator`.
- Prints the answer plus provider metadata as JSON.

Use it to confirm moderation flags work before wiring the same pattern into `ask.vexy.art/public/rag/index.php`.

## Hybrid Ragie + vector store pipeline

```
HYBRID_STORE=pinecone \\
PINECONE_BASE_URL=https://example.svc.us-west1-aws.pinecone.io \\
PINECONE_API_KEY=pcn-xxxx \\
PINECONE_INDEX=ragie-demo \\
php examples/vector-stores/hybrid_pipeline.php "Summarize ParaGra" examples/config/ragie_cerebras.php
```

The `examples/vector-stores/hybrid_pipeline.php` script orchestrates `HybridRetrievalPipeline`: Ragie retrieval supplies keyword/KB context, OpenAI embeddings feed a vector store, and both signals are reranked into a single payload. Set `HYBRID_STORE` to `pinecone`, `qdrant`, `weaviate`, `chroma`, or `gemini-file-search` and provide the corresponding environment variables:

- **Pinecone:** `PINECONE_BASE_URL`, `PINECONE_API_KEY`, `PINECONE_INDEX`, optional `PINECONE_NAMESPACE`.
- **Qdrant:** `QDRANT_URL`, `QDRANT_COLLECTION`, optional `QDRANT_API_KEY`.
- **Weaviate:** `WEAVIATE_URL`, `WEAVIATE_CLASS`, optional `WEAVIATE_API_KEY`, `WEAVIATE_TENANT`, `WEAVIATE_CONSISTENCY`.
- **Chroma:** `CHROMA_URL`, `CHROMA_TENANT`, `CHROMA_DATABASE`, `CHROMA_COLLECTION`, optional `CHROMA_TOKEN`.
- **Gemini File Search:** `GOOGLE_API_KEY`, `GEMINI_DATASTORE_ID` (preferred) or `GEMINI_CORPUS_ID`, optional `GEMINI_NAMESPACE`.

Flags:

- `HYBRID_SEED_FIRST=1` â€” call `ingestFromRagie()` before querying, useful when seeding new namespaces.
- `HYBRID_RETRIEVAL_TOPK`, `HYBRID_VECTOR_TOPK`, `HYBRID_LIMIT` â€” override Ragie topK, vector-store topK, and combined chunk limits (defaults: 6/6/8).

The script prints a JSON payload containing the question, the selected store, and reranked chunks with provenance metadata so you can feed them into ParaGraâ€™s prompt builder or other pipelines.

## Ragie + twat-search fallback

Install the [twat-search](https://github.com/twardoch/twat-search) CLI once:

```bash
pip install "twat-search[all]"
```

Then run the example to see Ragie retrieval augmented with multi-engine web search snippets:

```bash
TWAT_SEARCH_ENGINES="brave,duckduckgo" \
TAVILY_API_KEY=tvly-key \
BRAVE_API_KEY=brv-key \
php examples/external-search/twat_search_fallback.php "Latest ParaGra roadmap" examples/config/ragie_cerebras.php
```

The script:

- Retrieves chunks with ParaGra (Ragie provider) and prints them verbatim.
- Executes `twat-search web q --json ...` via `TwatSearchRetriever` to source attributed snippets (url/title/snippet/engine). Engines default to Brave + DuckDuckGo, but you can set `TWAT_SEARCH_ENGINES`, `TWAT_SEARCH_NUM_RESULTS`, and `TWAT_SEARCH_MAX_RESULTS` to tune payload size.
- Accepts API keys via `TAVILY_API_KEY`, `BRAVE_API_KEY`, `YOU_API_KEY`, or `SERPAPI_API_KEY` so paid engines activate when available.
- Emits JSON summarizing Ragie vs external chunks plus metadata (`cache_hit`, `duration_ms`, engine list) for debugging fallback decisions.

Use this as a blueprint for ParaGra deployments where an external search pass should run when Ragie (or any catalog provider) returns no context. The retriever caches results in-memory for `TWAT_SEARCH_CACHE_TTL` seconds so repeated questions hit the CLI only once per TTL window.

## Answer + image generation (Chutes / Fal.ai)

Need a quick hero shot after generating an answer? The media scripts summarize the Ragie answer into an art direction prompt, then call either Chutes or Fal.ai using the new `MediaRequest` + provider adapters.

### Chutes cinematic still

```bash
CHUTES_API_KEY=chutes_live_xxx \
CHUTES_BASE_URL=https://brandstudio-yourchute.chutes.ai \
CHUTES_MODEL=flux.1-pro \
php examples/media/chutes_answer_with_image.php \
  "Stage a futuristic ParaGra help desk" \
  examples/config/ragie_cerebras.php
```

| Env var | Purpose |
| --- | --- |
| `CHUTES_API_KEY` | Required Bearer token for your chute deployment. |
| `CHUTES_BASE_URL` | Base URL for the chute (defaults to `https://myuser-my-image-gen.chutes.ai`). |
| `CHUTES_MODEL` | Optional model slug (Flux, SDXL, LoRA, etc.). |
| `CHUTES_GUIDANCE` | Float guidance scale override (default 7.2). |
| `CHUTES_STEPS` | `num_inference_steps` override (default 28). |
| `CHUTES_ASPECT_RATIO` | `W:H` string (e.g., `16:9`, `9:16`). |
| `CHUTES_IMAGES` | Number of frames to request (capped at 4). |

The script prints the answer, image artifact metadata (URL/base64/mime), and the provider metadata block so ask.vexy.art can embed the same payload when image mode is enabled.

### Fal.ai async image job

```bash
FAL_KEY=fal_test_xxx \
FAL_MODEL="fal-ai/flux/dev" \
php examples/media/fal_answer_with_image.php \
  "Illustrate the Ragie + ParaGra ecosystem" \
  examples/config/ragie_cerebras.php
```

| Env var | Purpose |
| --- | --- |
| `FAL_KEY` | Required API key from https://fal.ai. |
| `FAL_MODEL` | Model endpoint (Flux Dev, Fooocus, GPT-Image-1, etc.). |
| `FAL_IMAGES` | Parallel image count (default 1). |
| `FAL_GUIDANCE` | Guidance scale override. |
| `FAL_STEPS` | Optional inference steps passed through to the Fal payload. |

`FalImageProvider` handles asynchronous polling and timeouts, so the script simply emits the CDN URLs/base64 payloads once Fal marks the job `COMPLETED`. Swap either script into your endpoints when you want optional image enrichments without bloating the main Ragie flow.
</document_content>
</document>

<document index="13">
<source>docs/migration.md</source>
<document_content>
---
this_file: paragra-php/docs/migration.md
---

# Migrating from ragie-php Helpers to ParaGra

Both projects live inside `/Users/adam/Developer/vcs/github.twardoch/pub/rag-projects`, but ParaGra now owns the orchestration logic. Follow the steps below to move existing Ragie-based stacks over.

## 1. Update Composer requirements

```bash
cd ask.vexy.art/private
composer req vexy/paragra-php:@dev
```

The private Composer path already points to `../../paragra-php`, so `composer update` will symlink (or copy) the local sources into `vendor-local/`. Keep the release build inside `vendor/` for production deployments.

## 2. Replace legacy helpers

| Legacy ragie-php helper | ParaGra replacement |
| --- | --- |
| `Ragie\Assistant\RagAnswerer::fromEnv()` | `ParaGra\ParaGra::fromConfig(require 'config/paragra.php')` |
| `Ragie\Llm\OpenAiChatClient` usage | `ParaGra\Llm\NeuronAiAdapter` (resolved automatically per provider) |
| `Ragie\Moderation\OpenAiModerator` | `ParaGra\Moderation\OpenAiModerator` (same public API) |
| AskYoda fallback glue | `ParaGra\Providers\AskYodaProvider` + pool ordering |

Remove direct calls to Ragie's `Client::retrieve()` where business logic no longer needs to differentiate providers. ParaGra hands back a `UnifiedResponse` with normalized chunks and metadata.

## 3. Move configuration into `config/paragra.php`

Instead of wiring API keys across multiple entry points, centralize them:

```php
// ask.vexy.art/private/config/paragra.php
return [
    'priority_pools' => require __DIR__ . '/../../paragra-php/examples/config/ragie_cerebras.php',
];
```

Each endpoint can now do:

```php
use ParaGra\ParaGra;
use ParaGra\Moderation\OpenAiModerator;

$config = require __DIR__ . '/../config/paragra.php';
$paragra = (ParaGra::fromConfig($config))
    ->withModeration(OpenAiModerator::fromEnv());

$response = $paragra->answer($_GET['text'] ?? '');
```

## 4. Validate behavior

1. Run `php ask.vexy.art/tests/paragra_config_test.php` to ensure config + Composer wiring work.
2. Hit `/public/rag/?text=hello&debug=1` and `/public/text/?text=hello&debug=1` to confirm metadata now lists `provider`, `model`, and `tier`.
3. Force failures by temporarily revoking the free-tier key; ParaGra should automatically step into the next pool.

## 5. Decommission bespoke glue

Once ParaGra owns rotation, fallback, moderation, and AskYoda integration, you can delete the redundant Ragie helper code paths inside your endpoints. This keeps `ragie-php` focused on being the retrieval SDK while ParaGra evolves as the multi-provider orchestrator.
</document_content>
</document>

<document index="14">
<source>examples/config/askyoda.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/config/askyoda.php

return [
    'priority_pools' => [
        [
            [
                'provider' => 'edenai',
                'model' => 'askyoda',
                'api_key' => (string) getenv('EDENAI_API_KEY'),
                'solution' => [
                    'type' => 'askyoda',
                    'askyoda_api_key' => (string) getenv('EDENAI_API_KEY'),
                    'project_id' => (string) getenv('EDENAI_ASKYODA_PROJECT'),
                    'default_options' => [
                        'k' => 10,
                        'min_score' => 0.35,
                        'temperature' => 0.9,
                        'max_tokens' => 6000,
                    ],
                    'llm' => [
                        'provider' => 'google',
                        'model' => 'gemini-1.5-flash',
                    ],
                    'metadata' => [
                        'tier' => 'paid',
                        'notes' => 'EdenAI AskYoda fallback when Ragie rate-limits',
                    ],
                ],
            ],
        ],
    ],
];
</document_content>
</document>

<document index="15">
<source>examples/config/gemini_file_search.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/config/gemini_file_search.php

return [
    'priority_pools' => [
        [
            [
                'provider' => 'gemini',
                'model' => 'gemini-2.0-flash-exp',
                'api_key' => (string) getenv('GOOGLE_API_KEY'),
                'solution' => [
                    'type' => 'gemini-file-search',
                    'vector_store' => [
                        'datastore' => (string) (getenv('GEMINI_DATASTORE_ID') ?: getenv('GEMINI_CORPUS_ID')),
                    ],
                    'generation' => [
                        'temperature' => 0.4,
                        'maxOutputTokens' => 2048,
                    ],
                    'safety' => [
                        'confidence' => 'block_low_and_above',
                    ],
                    'metadata' => [
                        'tier' => 'paid',
                        'notes' => 'Native Gemini File Search fallback',
                    ],
                ],
            ],
        ],
    ],
];
</document_content>
</document>

<document index="16">
<source>examples/config/ragie_cerebras.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/config/ragie_cerebras.php

return [
    'priority_pools' => [
        [
            [
                'provider' => 'cerebras',
                'model' => 'llama-3.3-70b',
                'api_key' => (string) getenv('CEREBRAS_API_KEY_1'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                    'ragie_partition' => getenv('RAGIE_PARTITION') ?: 'default',
                    'default_options' => [
                        'top_k' => 6,
                        'rerank' => true,
                    ],
                    'metadata' => [
                        'tier' => 'free',
                        'notes' => 'Primary Cerebras key',
                    ],
                ],
            ],
            [
                'provider' => 'cerebras',
                'model' => 'llama-3.3-70b',
                'api_key' => (string) getenv('CEREBRAS_API_KEY_2'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                    'metadata' => [
                        'tier' => 'free',
                        'notes' => 'Backup Cerebras key for rotation',
                    ],
                ],
            ],
        ],
    ],
];
</document_content>
</document>

<document index="17">
<source>examples/config/ragie_openai.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/config/ragie_openai.php

return [
    'priority_pools' => [
        [
            [
                'provider' => 'openai',
                'model' => 'gpt-4o-mini',
                'api_key' => (string) getenv('OPENAI_API_KEY'),
                'solution' => [
                    'type' => 'ragie',
                    'ragie_api_key' => (string) getenv('RAGIE_API_KEY'),
                    'default_options' => [
                        'top_k' => 8,
                        'rerank' => true,
                        'partition' => getenv('RAGIE_PARTITION') ?: null,
                    ],
                    'metadata' => [
                        'tier' => 'paid',
                        'notes' => 'High-reliability Ragie + OpenAI fallback',
                    ],
                ],
            ],
        ],
    ],
];
</document_content>
</document>

<document index="18">
<source>examples/external-search/twat_search_fallback.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/external-search/twat_search_fallback.php

use ParaGra\ExternalSearch\TwatSearchRetriever;
use ParaGra\ParaGra;
use ParaGra\Response\UnifiedResponse;

use function array_filter;
use function explode;
use function getenv;
use function is_file;
use function json_encode;
use function max;
use function sprintf;
use function trim;

require __DIR__ . '/../../vendor/autoload.php';

$question = $argv[1] ?? 'Where can I learn more about ParaGra?';
$configFile = $argv[2] ?? __DIR__ . '/../config/ragie_cerebras.php';

if (!is_file($configFile)) {
    fwrite(STDERR, sprintf("Config file not found: %s\n", $configFile));
    exit(1);
}

$config = require $configFile;
$paragra = ParaGra::fromConfig($config);

$defaultEngines = parseEngines(getenv('TWAT_SEARCH_ENGINES') ?: 'brave,duckduckgo');
$defaultNumResults = max(1, (int) (getenv('TWAT_SEARCH_NUM_RESULTS') ?: 4));
$defaultMaxResults = max(1, (int) (getenv('TWAT_SEARCH_MAX_RESULTS') ?: 6));
$cacheTtl = max(10, (int) (getenv('TWAT_SEARCH_CACHE_TTL') ?: 90));

$twatSearch = new TwatSearchRetriever(
    binary: getenv('TWAT_SEARCH_BIN') ?: 'twat-search',
    defaultEngines: $defaultEngines,
    defaultNumResults: $defaultNumResults,
    defaultMaxResults: $defaultMaxResults,
    cacheTtlSeconds: $cacheTtl,
    environment: array_filter([
        'TAVILY_API_KEY' => getenv('TAVILY_API_KEY') ?: null,
        'BRAVE_API_KEY' => getenv('BRAVE_API_KEY') ?: null,
        'YOU_API_KEY' => getenv('YOU_API_KEY') ?: null,
        'SERPAPI_API_KEY' => getenv('SERPAPI_API_KEY') ?: null,
    ]),
);

/** @var UnifiedResponse $ragieContext */
$ragieContext = $paragra->retrieve($question, [
    'top_k' => (int) (getenv('TWAT_RAGIE_TOPK') ?: 6),
]);

$external = $ragieContext->isEmpty()
    ? $twatSearch->search($question, ['allow_cache' => true])
    : $twatSearch->search($question, ['max_results' => 3]);

$output = [
    'question' => $question,
    'ragie_chunks' => $ragieContext->getChunks(),
    'external_chunks' => $external->getChunks(),
    'external_metadata' => $external->getProviderMetadata(),
];

fwrite(STDOUT, json_encode($output, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL);

/**
 * @return list<string>
 */
function parseEngines(string $value): array
{
    $parts = array_filter(array_map(
        static fn(string $engine): string => trim($engine),
        explode(',', $value)
    ));

    return $parts === [] ? ['brave', 'duckduckgo'] : $parts;
}
</document_content>
</document>

<document index="19">
<source>examples/media/chutes_answer_with_image.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/media/chutes_answer_with_image.php

use GuzzleHttp\Client;
use ParaGra\Media\ChutesImageProvider;
use ParaGra\Media\MediaRequest;
use ParaGra\ParaGra;

use function array_filter;
use function getenv;
use function is_file;
use function json_encode;
use function max;
use function sprintf;
use function trim;

require __DIR__ . '/../../vendor/autoload.php';

$question = $argv[1] ?? 'Design a welcoming lobby for the Ragie + ParaGra SDK';
$configFile = $argv[2] ?? __DIR__ . '/../config/ragie_cerebras.php';

if (!is_file($configFile)) {
    fwrite(STDERR, sprintf("Config file not found: %s\n", $configFile));
    exit(1);
}

$apiKey = trim((string) getenv('CHUTES_API_KEY'));
if ($apiKey === '') {
    fwrite(STDERR, "CHUTES_API_KEY must be set to use this example.\n");
    exit(1);
}

$baseUrl = trim((string) (getenv('CHUTES_BASE_URL') ?: 'https://myuser-my-image-gen.chutes.ai'));
$model = trim((string) (getenv('CHUTES_MODEL') ?: 'flux.1-pro'));
$guidance = (float) (getenv('CHUTES_GUIDANCE') ?: 7.2);
$steps = max(10, (int) (getenv('CHUTES_STEPS') ?: 28));

$paragra = ParaGra::fromConfig(require $configFile);
$answer = $paragra->answer($question);

$summaryPrompt = sprintf(
    'Illustrate the following Ragie answer with a cinematic still: %s',
    $answer['answer']
);

$request = new MediaRequest(
    prompt: $summaryPrompt,
    negativePrompt: 'blurry, watermark, signature, text',
    aspectRatio: getenv('CHUTES_ASPECT_RATIO') ?: '16:9',
    images: max(1, (int) (getenv('CHUTES_IMAGES') ?: 1)),
    metadata: ['script' => 'chutes_answer_with_image']
);

$provider = new ChutesImageProvider(
    http: new Client(['timeout' => 60]),
    baseUrl: $baseUrl,
    apiKey: $apiKey,
    defaults: array_filter([
        'model' => $model,
        'guidance_scale' => $guidance,
    ])
);

$result = $provider->generate($request, [
    'payload' => ['num_inference_steps' => $steps],
]);

fwrite(STDOUT, json_encode([
    'question' => $question,
    'answer' => $answer['answer'],
    'image' => $result->getArtifacts()[0],
    'metadata' => $result->getMetadata(),
], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL);
</document_content>
</document>

<document index="20">
<source>examples/media/fal_answer_with_image.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/media/fal_answer_with_image.php

use GuzzleHttp\Client;
use ParaGra\Media\FalImageProvider;
use ParaGra\Media\MediaRequest;
use ParaGra\ParaGra;

use function getenv;
use function is_file;
use function json_encode;
use function max;
use function sprintf;
use function trim;

require __DIR__ . '/../../vendor/autoload.php';

$question = $argv[1] ?? 'Show a para-graph describing Ragie knowledge orchestration';
$configFile = $argv[2] ?? __DIR__ . '/../config/ragie_cerebras.php';

if (!is_file($configFile)) {
    fwrite(STDERR, sprintf("Config file not found: %s\n", $configFile));
    exit(1);
}

$falKey = trim((string) getenv('FAL_KEY'));
if ($falKey === '') {
    fwrite(STDERR, "FAL_KEY must be configured for this script.\n");
    exit(1);
}

$modelId = trim((string) (getenv('FAL_MODEL') ?: 'fal-ai/flux/dev'));
$images = max(1, (int) (getenv('FAL_IMAGES') ?: 1));
$guidance = (float) (getenv('FAL_GUIDANCE') ?: 7.5);

$paragra = ParaGra::fromConfig(require $configFile);
$answer = $paragra->answer($question);

$prompt = sprintf(
    'Generate an editorial illustration for this answer: %s',
    $answer['answer']
);

$request = new MediaRequest(
    prompt: $prompt,
    negativePrompt: 'watermark, text, blurry',
    images: $images,
    metadata: ['script' => 'fal_answer_with_image']
);

$provider = new FalImageProvider(
    http: new Client(['timeout' => 60]),
    apiKey: $falKey,
    modelId: $modelId,
    defaults: [
        'guidance_scale' => $guidance,
        'poll_interval_ms' => 250,
    ]
);

$result = $provider->generate($request, [
    'payload' => [
        'num_images' => $images,
        'num_inference_steps' => (int) (getenv('FAL_STEPS') ?: 25),
    ],
]);

fwrite(STDOUT, json_encode([
    'question' => $question,
    'answer' => $answer['answer'],
    'images' => $result->getArtifacts(),
    'metadata' => $result->getMetadata(),
], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL);
</document_content>
</document>

<document index="21">
<source>examples/moderated_answer.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/moderated_answer.php

use ParaGra\Moderation\OpenAiModerator;
use ParaGra\ParaGra;

require __DIR__ . '/../vendor/autoload.php';

$question = $argv[1] ?? 'What does ParaGra do?';
$config = require __DIR__ . '/config/ragie_cerebras.php';

$paragra = ParaGra::fromConfig($config)
    ->withModeration(OpenAiModerator::fromEnv());

$response = $paragra->answer($question);

fwrite(STDOUT, json_encode([
    'question' => $question,
    'answer' => $response['answer'],
    'provider' => $response['metadata']['provider'] ?? null,
    'model' => $response['metadata']['model'] ?? null,
    'tier' => $response['metadata']['tier'] ?? null,
], JSON_PRETTY_PRINT) . PHP_EOL);
</document_content>
</document>

<document index="22">
<source>examples/vector-stores/hybrid_pipeline.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/examples/vector-stores/hybrid_pipeline.php

use ParaGra\Embedding\OpenAiEmbeddingConfig;
use ParaGra\Embedding\OpenAiEmbeddingProvider;
use ParaGra\ParaGra;
use ParaGra\Pipeline\HybridRetrievalPipeline;
use ParaGra\VectorStore\ChromaVectorStore;
use ParaGra\VectorStore\GeminiFileSearchVectorStore;
use ParaGra\VectorStore\PineconeVectorStore;
use ParaGra\VectorStore\QdrantVectorStore;
use ParaGra\VectorStore\VectorNamespace;
use ParaGra\VectorStore\VectorStoreInterface;
use ParaGra\VectorStore\WeaviateVectorStore;
use RuntimeException;

require __DIR__ . '/../../vendor/autoload.php';

$question = $argv[1] ?? 'What does ParaGra do?';
$configPath = $argv[2] ?? __DIR__ . '/../config/ragie_cerebras.php';

if (!is_file($configPath)) {
    throw new RuntimeException(sprintf('Config file not found: %s', $configPath));
}

$config = require $configPath;
$paragra = ParaGra::fromConfig($config);
$embedding = new OpenAiEmbeddingProvider(OpenAiEmbeddingConfig::fromEnv());

$storeType = getenv('HYBRID_STORE') ?: 'pinecone';
$vectorStore = null;
$namespace = null;

switch ($storeType) {
    case 'pinecone':
        $pineconeBaseUrl = getenv('PINECONE_BASE_URL');
        $pineconeApiKey = getenv('PINECONE_API_KEY');
        $pineconeIndex = getenv('PINECONE_INDEX');
        if (!is_string($pineconeBaseUrl) || $pineconeBaseUrl === '') {
            throw new RuntimeException('Set PINECONE_BASE_URL for the Pinecone example.');
        }
        if (!is_string($pineconeApiKey) || $pineconeApiKey === '') {
            throw new RuntimeException('Set PINECONE_API_KEY for the Pinecone example.');
        }
        if (!is_string($pineconeIndex) || $pineconeIndex === '') {
            throw new RuntimeException('Set PINECONE_INDEX for the Pinecone example.');
        }

        $pineconeNamespace = getenv('PINECONE_NAMESPACE') ?: 'ragie-hybrid';
        $namespace = new VectorNamespace($pineconeNamespace);
        $vectorStore = new PineconeVectorStore(
            baseUrl: $pineconeBaseUrl,
            apiKey: $pineconeApiKey,
            indexName: $pineconeIndex,
            defaultNamespace: $namespace,
        );
        break;

    case 'qdrant':
        $qdrantUrl = getenv('QDRANT_URL');
        $qdrantCollection = getenv('QDRANT_COLLECTION');
        if (!is_string($qdrantUrl) || $qdrantUrl === '') {
            throw new RuntimeException('Set QDRANT_URL for the Qdrant example.');
        }
        if (!is_string($qdrantCollection) || $qdrantCollection === '') {
            throw new RuntimeException('Set QDRANT_COLLECTION for the Qdrant example.');
        }

        $namespace = new VectorNamespace($qdrantCollection);
        $vectorStore = new QdrantVectorStore(
            baseUrl: $qdrantUrl,
            collection: $qdrantCollection,
            apiKey: getenv('QDRANT_API_KEY') ?: null,
            defaultNamespace: $namespace,
        );
        break;

    case 'weaviate':
        $weaviateUrl = getenv('WEAVIATE_URL');
        $weaviateClass = getenv('WEAVIATE_CLASS');
        if (!is_string($weaviateUrl) || $weaviateUrl === '') {
            throw new RuntimeException('Set WEAVIATE_URL for the Weaviate example.');
        }
        if (!is_string($weaviateClass) || $weaviateClass === '') {
            throw new RuntimeException('Set WEAVIATE_CLASS for the Weaviate example.');
        }

        $tenant = getenv('WEAVIATE_TENANT');
        $metadata = $tenant !== false && $tenant !== '' ? ['tenant' => $tenant] : [];

        $namespace = new VectorNamespace(
            name: getenv('WEAVIATE_NAMESPACE') ?: 'ragie-hybrid',
            collection: $weaviateClass,
            metadata: $metadata,
        );

        $vectorStore = new WeaviateVectorStore(
            baseUrl: $weaviateUrl,
            className: $weaviateClass,
            apiKey: getenv('WEAVIATE_API_KEY') ?: null,
            defaultNamespace: $namespace,
            consistencyLevel: getenv('WEAVIATE_CONSISTENCY') ?: 'ONE',
        );
        break;

    case 'chroma':
        $chromaUrl = getenv('CHROMA_URL');
        $chromaTenant = getenv('CHROMA_TENANT');
        $chromaDatabase = getenv('CHROMA_DATABASE');
        $chromaCollection = getenv('CHROMA_COLLECTION');
        foreach ([
            'CHROMA_URL' => $chromaUrl,
            'CHROMA_TENANT' => $chromaTenant,
            'CHROMA_DATABASE' => $chromaDatabase,
            'CHROMA_COLLECTION' => $chromaCollection,
        ] as $label => $value) {
            if (!is_string($value) || $value === '') {
                throw new RuntimeException(sprintf('Set %s for the Chroma example.', $label));
            }
        }

        $namespace = new VectorNamespace(
            name: $chromaCollection,
            collection: $chromaCollection,
            metadata: ['source' => 'ragie'],
        );

        $vectorStore = new ChromaVectorStore(
            baseUrl: $chromaUrl,
            tenant: $chromaTenant,
            database: $chromaDatabase,
            collection: $chromaCollection,
            defaultNamespace: $namespace,
            authToken: getenv('CHROMA_TOKEN') ?: null,
        );
        break;

    case 'gemini':
    case 'gemini-file-search':
        $googleApiKey = getenv('GOOGLE_API_KEY');
        $geminiResource = getenv('GEMINI_DATASTORE_ID') ?: getenv('GEMINI_CORPUS_ID');
        if (!is_string($googleApiKey) || $googleApiKey === '') {
            throw new RuntimeException('Set GOOGLE_API_KEY for the Gemini File Search example.');
        }
        if (!is_string($geminiResource) || $geminiResource === '') {
            throw new RuntimeException('Set GEMINI_DATASTORE_ID (or GEMINI_CORPUS_ID) for the Gemini example.');
        }

        $namespace = new VectorNamespace(
            name: getenv('GEMINI_NAMESPACE') ?: 'ragie-hybrid',
            collection: $geminiResource,
            eventuallyConsistent: true,
            metadata: ['source' => 'ragie'],
        );

        $vectorStore = new GeminiFileSearchVectorStore(
            apiKey: $googleApiKey,
            resourceName: $geminiResource,
            defaultNamespace: $namespace,
        );
        $storeType = 'gemini-file-search';
        break;

    default:
        throw new RuntimeException(sprintf('Unsupported HYBRID_STORE value: %s', $storeType));
}

if (!$vectorStore instanceof VectorStoreInterface || !$namespace instanceof VectorNamespace) {
    throw new RuntimeException('Failed to initialize the requested vector store.');
}

$pipeline = new HybridRetrievalPipeline([$paragra, 'retrieve'], $embedding, $vectorStore, $namespace);

$retrievalTopK = (int) (getenv('HYBRID_RETRIEVAL_TOPK') ?: 6);
if ($retrievalTopK <= 0) {
    $retrievalTopK = 6;
}

$vectorTopK = (int) (getenv('HYBRID_VECTOR_TOPK') ?: 6);
if ($vectorTopK <= 0) {
    $vectorTopK = 6;
}

$hybridLimit = (int) (getenv('HYBRID_LIMIT') ?: 8);
if ($hybridLimit <= 0) {
    $hybridLimit = 8;
}

if (getenv('HYBRID_SEED_FIRST') === '1') {
    $seedResult = $pipeline->ingestFromRagie($question, [
        'retrieval' => ['top_k' => $retrievalTopK],
    ]);

    fwrite(
        STDERR,
        sprintf(
            "Seeded %d Ragie chunks into %s (%s)\n",
            $seedResult['ingested_chunks'],
            $storeType,
            $namespace->getName(),
        )
    );
}

$result = $pipeline->hybridRetrieve($question, [
    'retrieval' => ['top_k' => $retrievalTopK],
    'vector_store' => ['top_k' => $vectorTopK],
    'hybrid_limit' => $hybridLimit,
]);

$payload = [
    'question' => $question,
    'store' => $storeType,
    'ragie_provider' => $result['ragie']->getProvider(),
    'vector_store_provider' => $result['vector_store']->getProvider(),
    'combined_chunks' => $result['combined']->getChunks(),
];

fwrite(STDOUT, json_encode($payload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL);
</document_content>
</document>

<document index="23">
<source>llms.sh</source>
<document_content>
#!/usr/bin/env bash

cd "$(dirname "$0")"

llms . "AGENTS.md,CLAUDE.md,GEMINI.md,LLXPRT.md,QWEN.md,WORK.md,external,vendor,vendor-local,build"
</document_content>
</document>

<document index="24">
<source>phpstan.neon.dist</source>
<document_content>
# this_file: paragra-php/phpstan.neon.dist
parameters:
    level: 7
    paths:
        - src
        - tests
    tmpDir: build/phpstan
    bootstrapFiles:
        - vendor/autoload.php
</document_content>
</document>

<document index="25">
<source>phpunit.xml.dist</source>
<document_content>
<?xml version="1.0" encoding="UTF-8"?>
<!-- this_file: paragra-php/phpunit.xml.dist -->
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="https://schema.phpunit.de/11.2/phpunit.xsd"
         bootstrap="tests/bootstrap.php"
         cacheResult="false"
         colors="true">
    <testsuites>
        <testsuite name="ParaGra Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>
</phpunit>
</document_content>
</document>

<document index="26">
<source>psalm.xml</source>
<document_content>
<?xml version="1.0"?>
<!-- this_file: paragra-php/psalm.xml -->
<psalm
    errorLevel="3"
    resolveFromConfigFile="true"
    cacheDirectory=".psalm-cache"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/vimeo/psalm/master/config.xsd"
>
    <projectFiles>
        <directory name="src"/>
        <directory name="tests"/>
    </projectFiles>
    <issueHandlers>
        <UnusedClass>
            <errorLevel type="suppress">
                <directory name="tests"/>
            </errorLevel>
        </UnusedClass>
    </issueHandlers>
</psalm>
</document_content>
</document>

<document index="27">
<source>src/Assistant/AskYodaHostedAdapter.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Assistant/AskYodaHostedAdapter.php

namespace ParaGra\Assistant;

use ParaGra\Llm\AskYodaClient;
use Throwable;

use function array_filter;
use function is_callable;
use function is_numeric;
use function max;
use function microtime;
use function preg_replace;
use function round;
use function substr;
use function trim;

/**
 * Bridges Ragie fallback semantics with the Eden AskYoda hosted workflow.
 * It records timing/counter metadata and optionally emits telemetry events
 * so higher-level orchestrators can log or monitor hosted fallback usage.
 */
final class AskYodaHostedAdapter
{
    /**
     * @param callable(string, array<string, mixed>):void|null $telemetryHook
     */
    public function __construct(
        private readonly AskYodaClient $client,
        private readonly $telemetryHook = null,
    ) {
    }

    /**
     * @param array{
     *     k?: int,
     *     min_score?: float,
     *     temperature?: float,
     *     max_tokens?: int
     * } $options
     * @param callable(string, array<string, mixed>):void|null $telemetry Additional telemetry consumer
     */
    public function ask(
        string $question,
        array $options = [],
        ?callable $telemetry = null
    ): AskYodaHostedResult {
        $start = microtime(true);
        $k = $this->intOption($options, 'k', 10, 1);
        $minScore = $this->floatOption($options, 'min_score', 0.3, 0.0, 1.0);
        $temperature = $this->floatOption($options, 'temperature', 0.99, 0.0, 2.0);
        $maxTokens = $this->intOption($options, 'max_tokens', 8000, 1);

        try {
            $response = $this->client->ask(
                query: $question,
                k: $k,
                minScore: $minScore,
                temperature: $temperature,
                maxTokens: $maxTokens
            );
        } catch (Throwable $exception) {
            $this->emitTelemetry('askyoda.failure', [
                'duration_ms' => $this->elapsed($start),
                'question_preview' => $this->preview($question),
                'error' => $exception->getMessage(),
            ], $telemetry);

            throw $exception;
        }

        $result = new AskYodaHostedResult(
            $response,
            $this->elapsed($start)
        );

        $this->emitTelemetry('askyoda.success', [
            'duration_ms' => $result->getDurationMs(),
            'chunk_count' => $response->getChunkCount(),
            'question_preview' => $this->preview($question),
            'llm_provider' => $response->getLlmProvider(),
            'llm_model' => $response->getLlmModel(),
            'cost' => $response->getCost(),
        ], $telemetry);

        return $result;
    }

    private function emitTelemetry(string $event, array $payload, ?callable $telemetry): void
    {
        $handlers = array_filter([$telemetry, $this->telemetryHook], static fn ($candidate): bool => is_callable($candidate));
        foreach ($handlers as $handler) {
            $handler($event, $payload);
        }
    }

    private function elapsed(float $start): int
    {
        return (int) max(0, round((microtime(true) - $start) * 1000.0));
    }

    private function preview(string $text): string
    {
        $flattened = trim((string) preg_replace('/\s+/u', ' ', $text));
        return substr($flattened, 0, 160);
    }

    /**
     * @param array<string, mixed> $options
     */
    private function intOption(array $options, string $key, int $default, int $min): int
    {
        $value = $options[$key] ?? $default;
        if (!is_numeric($value)) {
            return $default;
        }

        $parsed = (int) $value;
        if ($parsed < $min) {
            return $min;
        }

        return $parsed;
    }

    /**
     * @param array<string, mixed> $options
     */
    private function floatOption(array $options, string $key, float $default, float $min, float $max): float
    {
        $value = $options[$key] ?? $default;
        if (!is_numeric($value)) {
            return $default;
        }

        $parsed = (float) $value;
        if ($parsed < $min) {
            return $min;
        }
        if ($parsed > $max) {
            return $max;
        }

        return $parsed;
    }
}
</document_content>
</document>

<document index="28">
<source>src/Assistant/AskYodaHostedResult.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Assistant/AskYodaHostedResult.php

namespace ParaGra\Assistant;

use ParaGra\Llm\AskYodaResponse;

/**
 * Wraps the AskYoda API response together with duration metadata so
 * RagAnswerer and other callers can emit telemetry consistently.
 */
final class AskYodaHostedResult
{
    public function __construct(
        private readonly AskYodaResponse $response,
        private readonly int $durationMs,
    ) {
    }

    public function getResponse(): AskYodaResponse
    {
        return $this->response;
    }

    public function getDurationMs(): int
    {
        return $this->durationMs;
    }

    public function getChunkCount(): int
    {
        return $this->response->getChunkCount();
    }
}
</document_content>
</document>

<document index="29">
<source>src/Assistant/RagAnswer.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Assistant/RagAnswer.php

namespace ParaGra\Assistant;

use ParaGra\Llm\ChatResponse;
use ParaGra\Llm\ChatUsage;
use Ragie\RetrievalResult;

final class RagAnswer
{
    /**
     * @param array<string, mixed> $metadata Optional metadata (e.g., fallback info)
     */
    public function __construct(
        private string $question,
        private string $answer,
        private RetrievalResult $retrievalResult,
        private ChatResponse $chatResponse,
        private string $prompt,
        private int $executionTimeMs,
        private array $metadata = []
    ) {
    }

    /**
     * @api
     */
    public function getQuestion(): string
    {
        return $this->question;
    }

    public function getAnswer(): string
    {
        return $this->answer;
    }

    /**
     * @api
     */
    public function getRetrievalResult(): RetrievalResult
    {
        return $this->retrievalResult;
    }

    /**
     * @return string[]
     */
    public function getContextTexts(): array
    {
        return $this->retrievalResult->getChunkTexts();
    }

    /**
     * @api
     */
    public function getChatResponse(): ChatResponse
    {
        return $this->chatResponse;
    }

    public function getChatUsage(): ChatUsage
    {
        return $this->chatResponse->getUsage();
    }

    public function getPrompt(): string
    {
        return $this->prompt;
    }

    /**
     * @api
     */
    public function getExecutionTimeMs(): int
    {
        return $this->executionTimeMs;
    }

    /**
     * Get metadata (e.g., fallback information)
     *
     * @return array<string, mixed>
     */
    public function getMetadata(): array
    {
        return $this->metadata;
    }

    /**
     * Check if this answer used a fallback provider
     */
    public function isFallback(): bool
    {
        return isset($this->metadata['fallback_used']) && $this->metadata['fallback_used'] === true;
    }

    /**
     * Get the fallback provider name if fallback was used
     */
    public function getFallbackProvider(): ?string
    {
        return $this->metadata['fallback_provider'] ?? null;
    }
}
</document_content>
</document>

<document index="30">
<source>src/Assistant/RagAnswerer.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Assistant/RagAnswerer.php

namespace ParaGra\Assistant;

use ParaGra\Llm\AskYodaClient;
use ParaGra\Llm\ChatRequestOptions;
use ParaGra\Llm\ChatResponse;
use ParaGra\Llm\ChatUsage;
use ParaGra\Llm\OpenAiChatClient;
use ParaGra\Llm\OpenAiChatConfig;
use ParaGra\Llm\PromptBuilder;
use ParaGra\Moderation\ModerationException;
use ParaGra\Moderation\ModerationResult;
use ParaGra\Moderation\ModeratorInterface;
use ParaGra\Moderation\OpenAiModerator;
use ParaGra\Util\ConfigValidator;
use Ragie\Api\ApiException;
use Ragie\Client as RagieClient;
use Ragie\Logging\StructuredLogger;
use Ragie\Metrics\CostTracker;
use Ragie\Metrics\MetricsCollector;
use Ragie\RetrievalOptions;
use Ragie\RetrievalResult;
use Ragie\Validation\InputSanitizer;

final class RagAnswerer
{
    private PromptBuilder $promptBuilder;

    public function __construct(
        private RagieClient $ragieClient,
        private OpenAiChatClient $chatClient,
        ?PromptBuilder $promptBuilder = null,
        private ?RetrievalOptions $defaultRetrievalOptions = null,
        private ?ChatRequestOptions $defaultChatOptions = null,
        private ?AskYodaClient $askYodaClient = null,
        private ?ModeratorInterface $moderator = null,
        private ?MetricsCollector $metricsCollector = null,
        private ?CostTracker $costTracker = null,
        private ?StructuredLogger $structuredLogger = null,
        private ?AskYodaHostedAdapter $askYodaAdapter = null,
    ) {
        $this->promptBuilder = $promptBuilder ?? new PromptBuilder();
        $this->metricsCollector = $metricsCollector ?? $ragieClient->getMetricsCollector();
        $this->costTracker = $costTracker ?? $ragieClient->getCostTracker();
        $this->structuredLogger = $structuredLogger ?? $ragieClient->getStructuredLogger();
        $this->askYodaClient = $askYodaClient;
        $this->askYodaAdapter = $askYodaAdapter ?? ($askYodaClient !== null ? new AskYodaHostedAdapter($askYodaClient) : null);

        if ($this->structuredLogger !== null) {
            $this->ragieClient->withStructuredLogger($this->structuredLogger);
        }
    }

    /**
     * Create RagAnswerer from environment variables
     *
     * Required environment variables:
     * - RAGIE_API_KEY
     * - OPENAI_API_KEY
     *
     * Optional environment variables:
     * - OPENAI_BASE_URL, OPENAI_API_MODEL, OPENAI_API_TEMPERATURE, etc.
     * - EDENAI_API_KEY, EDENAI_ASKYODA_PROJECT (for AskYoda fallback)
     * - OPENAI_MODERATION_ENABLED=1 (to enable content moderation)
     *
     * @throws \ParaGra\Exception\ConfigurationException if required env vars missing
     */
    public static function fromEnv(): self
    {
        $ragieApiKey = ConfigValidator::requireEnv('RAGIE_API_KEY');
        $ragieClient = new RagieClient($ragieApiKey);

        $chatConfig = OpenAiChatConfig::fromEnv();
        $chatClient = new OpenAiChatClient($chatConfig);

        $promptBuilder = new PromptBuilder();

        // Optional AskYoda client for fallback
        $askYodaClient = null;
        $askYodaAdapter = null;
        try {
            $askYodaClient = AskYodaClient::fromEnv();
            $askYodaAdapter = new AskYodaHostedAdapter($askYodaClient);
        } catch (\RuntimeException $e) {
            // AskYoda not configured, that's ok - fallback won't be available
        }

        // Optional moderation (requires OPENAI_API_KEY and OPENAI_MODERATION_ENABLED=1)
        $moderator = null;
        $moderationEnabled = ConfigValidator::getEnv('OPENAI_MODERATION_ENABLED', '0');
        if ($moderationEnabled === '1' || $moderationEnabled === 'true') {
            try {
                $moderator = OpenAiModerator::fromEnv();
            } catch (\RuntimeException $e) {
                // Moderation not configured, that's ok
            }
        }

        $metricsCollector = new MetricsCollector();
        $costTracker = new CostTracker();
        $ragieClient
            ->withMetricsCollector($metricsCollector)
            ->withCostTracker($costTracker);

        return new self(
            $ragieClient,
            $chatClient,
            $promptBuilder,
            null,
            null,
            $askYodaClient,
            $moderator,
            $metricsCollector,
            $costTracker,
            null,
            $askYodaAdapter
        );
    }

    public function withStructuredLogger(StructuredLogger $logger): self
    {
        $this->structuredLogger = $logger;
        $this->ragieClient->withStructuredLogger($logger);

        return $this;
    }

    public function answer(
        string $question,
        ?RetrievalOptions $retrievalOptions = null,
        ?ChatRequestOptions $chatOptions = null
    ): RagAnswer {
        $cleanQuestion = InputSanitizer::sanitizeAndValidate($question);

        // Optional: Check content moderation before processing
        if ($this->moderator !== null) {
            try {
                $moderationResult = $this->moderator->moderate($cleanQuestion);
                $this->structuredLogger?->logModerationDecision($moderationResult->isFlagged(), $moderationResult->getCategories());
                $this->recordModerationMetrics($moderationResult);
            } catch (ModerationException $e) {
                $this->structuredLogger?->logModerationDecision(true, $e->getFlaggedCategories());
                $this->metricsCollector?->recordModeration(true, $e->getFlaggedCategories());
                throw $e;
            }
        }

        $retrievalOptions = $retrievalOptions ?? $this->defaultRetrievalOptions ?? RetrievalOptions::create();
        $chatOptions = $chatOptions ?? $this->defaultChatOptions ?? new ChatRequestOptions();

        try {
            // Primary path: Ragie + OpenAI/Cerebras
            $start = microtime(true);
            $retrievalResult = $this->ragieClient->retrieve($cleanQuestion, $retrievalOptions);
            $context = $retrievalResult->getChunkTexts();
            $prompt = $this->promptBuilder->build($cleanQuestion, $context);
            $chatStart = microtime(true);
            $chatResponse = $this->chatClient->generateText($prompt, $chatOptions);
            $chatDuration = $this->elapsedMs($chatStart);
            $usage = $chatResponse->getUsage();
            $this->costTracker?->recordOpenAiUsage($usage->promptTokens, $usage->completionTokens);
            $this->structuredLogger?->logChatCompletion(
                $cleanQuestion,
                'openai',
                $chatDuration,
                $usage->promptTokens,
                $usage->completionTokens
            );
            $elapsed = (int) ((microtime(true) - $start) * 1000.0);

            return new RagAnswer(
                question: $cleanQuestion,
                answer: $chatResponse->getText(),
                retrievalResult: $retrievalResult,
                chatResponse: $chatResponse,
                prompt: $prompt,
                executionTimeMs: $elapsed
            );
        } catch (ApiException $e) {
            // Check if this is a rate limit error (429) and fallback is available
            if ($e->getCode() === 429 && $this->askYodaAdapter !== null) {
                return $this->answerWithAskYoda($cleanQuestion);
            }

            $this->structuredLogger?->logError('ragie.answer.api_exception', $e, [
                'question_preview' => $this->preview($cleanQuestion),
            ]);

            throw $e;
        } catch (\Throwable $e) {
            $this->structuredLogger?->logError('ragie.answer.unexpected', $e, [
                'question_preview' => $this->preview($cleanQuestion),
            ]);
            throw $e;
        }
    }

    /**
     * Answer using AskYoda fallback (EdenAI)
     *
     * This is used when Ragie hits rate limits (429 errors).
     * AskYoda is a complete RAG+LLM solution.
     *
     * @param string $question The question to answer
     * @return RagAnswer
     */
    private function answerWithAskYoda(string $question): RagAnswer
    {
        if ($this->askYodaAdapter === null) {
            throw new \RuntimeException('AskYoda fallback is not configured.');
        }

        $telemetry = function (string $event, array $context) use ($question): void {
            $duration = (int) ($context['duration_ms'] ?? 0);
            $chunkCount = (int) ($context['chunk_count'] ?? 0);
            $success = $event === 'askyoda.success';

            $this->metricsCollector?->recordRetrieval('askyoda', $duration, $chunkCount, $success);

            if (!$success && $this->structuredLogger !== null) {
                $message = $context['error'] ?? 'AskYoda fallback failed.';
                $this->structuredLogger->logError('ragie.fallback.askyoda_failed', new \RuntimeException($message), [
                    'question_preview' => $this->preview($question),
                ]);
            }
        };

        $result = $this->askYodaAdapter->ask($question, telemetry: $telemetry);
        $askYodaResponse = $result->getResponse();
        $elapsed = $result->getDurationMs();

        // Create a ChatResponse-compatible object from AskYoda response
        $chatResponse = new ChatResponse(
            text: $askYodaResponse->getResult(),
            usage: new ChatUsage(
                promptTokens: $askYodaResponse->getInputTokens(),
                completionTokens: $askYodaResponse->getOutputTokens(),
                totalTokens: $askYodaResponse->getTotalTokens()
            ),
            rawResponse: $askYodaResponse->toArray()
        );

        // Create a minimal RetrievalResult since AskYoda doesn't provide chunk details
        // We create an empty result with metadata about the fallback
        $retrievalResult = new RetrievalResult(
            new \Ragie\Api\Model\Retrieval([
                'scored_chunks' => [],
            ])
        );

        // Build a pseudo-prompt to maintain consistency
        $prompt = "Fallback to AskYoda: " . $question;

        $answer = new RagAnswer(
            question: $question,
            answer: $askYodaResponse->getResult(),
            retrievalResult: $retrievalResult,
            chatResponse: $chatResponse,
            prompt: $prompt,
            executionTimeMs: $elapsed,
            metadata: [
                'fallback_used' => true,
                'fallback_provider' => 'askyoda',
                'llm_provider' => $askYodaResponse->getLlmProvider(),
                'llm_model' => $askYodaResponse->getLlmModel(),
                'cost' => $askYodaResponse->getCost(),
                'usage' => $askYodaResponse->getUsage(),
                'chunk_count' => $askYodaResponse->getChunkCount(),
                'chunk_ids' => $askYodaResponse->getChunkIds(),
            ]
        );

        $this->structuredLogger?->logFallback('askyoda', $question, [
            'duration_ms' => $elapsed,
            'chunk_count' => $askYodaResponse->getChunkCount(),
            'llm_provider' => $askYodaResponse->getLlmProvider(),
            'llm_model' => $askYodaResponse->getLlmModel(),
        ]);

        $this->structuredLogger?->logChatCompletion(
            $question,
            'askyoda',
            $elapsed,
            $askYodaResponse->getInputTokens(),
            $askYodaResponse->getOutputTokens()
        );

        return $answer;
    }

    private function recordModerationMetrics(ModerationResult $result): void
    {
        $this->metricsCollector?->recordModeration($result->isFlagged(), $result->getCategories());
    }

    private function elapsedMs(float $startTime): int
    {
        return (int) max(0, round((microtime(true) - $startTime) * 1000.0));
    }

    private function preview(string $value): string
    {
        $flattened = trim((string) preg_replace('/\s+/u', ' ', $value));
        return mb_substr($flattened, 0, 120) ?: '';
    }
}
</document_content>
</document>

<document index="31">
<source>src/Config/PriorityPool.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Config/PriorityPool.php

namespace ParaGra\Config;

use InvalidArgumentException;
use ParaGra\ProviderCatalog\ProviderDiscovery;

use function array_key_exists;
use function array_replace;
use function array_values;
use function count;
use function get_debug_type;
use function is_array;
use function is_string;
use function sprintf;
use function trim;

final class PriorityPool
{
    /**
     * @param array<int, array<int, ProviderSpec>> $pools
     */
    public function __construct(private array $pools)
    {
        foreach ($this->pools as $index => $pool) {
            if (!is_array($pool)) {
                throw new InvalidArgumentException(sprintf('Pool "%d" must be an array.', $index));
            }

            foreach ($pool as $spec) {
                if (!$spec instanceof ProviderSpec) {
                    $type = get_debug_type($spec);
                    throw new InvalidArgumentException(sprintf('Pool "%d" contains invalid entry of type "%s".', $index, $type));
                }
            }
        }

        $this->pools = array_values($this->pools);
    }

    /**
     * @param array<int, array<int, array<string, mixed>>> $config
     */
    public static function fromArray(array $config, ?ProviderDiscovery $catalog = null): self
    {
        $pools = [];
        foreach ($config as $poolIndex => $poolSpecs) {
            if (!is_array($poolSpecs)) {
                throw new InvalidArgumentException(sprintf('Pool "%d" must be an array of provider specs.', $poolIndex));
            }

            $pool = [];
            foreach ($poolSpecs as $specIndex => $specData) {
                if (!is_array($specData)) {
                    throw new InvalidArgumentException(sprintf('Pool "%d" entry "%d" must be an array.', $poolIndex, $specIndex));
                }

                $pool[] = self::createSpecFromConfig($specData, $catalog);
            }

            $pools[] = $pool;
        }

        return new self($pools);
    }

    /**
     * @return array<int, ProviderSpec>
     */
    public function getPool(int $priority): array
    {
        return $this->pools[$priority] ?? [];
    }

    public function getPoolCount(): int
    {
        return count($this->pools);
    }

    /**
     * @param array<string, mixed> $specData
     */
    private static function createSpecFromConfig(array $specData, ?ProviderDiscovery $catalog): ProviderSpec
    {
        if (!self::isCatalogReference($specData)) {
            return ProviderSpec::fromArray($specData);
        }

        if ($catalog === null) {
            throw new InvalidArgumentException(
                'Catalog-backed provider entries require a provider catalog. '
                . 'Set "provider_catalog" in your config or pass a ProviderDiscovery instance.'
            );
        }

        return self::buildSpecFromCatalog($specData, $catalog);
    }

    /**
     * @param array<string, mixed> $specData
     */
    private static function isCatalogReference(array $specData): bool
    {
        return array_key_exists('catalog', $specData) || array_key_exists('catalog_slug', $specData);
    }

    /**
     * @param array<string, mixed> $specData
     */
    private static function buildSpecFromCatalog(array $specData, ProviderDiscovery $catalog): ProviderSpec
    {
        $catalogConfig = self::normalizeCatalogConfig($specData);

        $slug = self::extractSlug($catalogConfig);
        $modelType = self::extractModelType($catalogConfig);
        $overrides = self::extractOverrides($catalogConfig);
        $metadataOverrides = self::extractMetadataOverrides($specData, $catalogConfig);

        if ($metadataOverrides !== []) {
            if (!isset($overrides['solution']) || !is_array($overrides['solution'])) {
                $overrides['solution'] = [];
            }

            $existingMetadata = [];
            if (isset($overrides['solution']['metadata']) && is_array($overrides['solution']['metadata'])) {
                $existingMetadata = $overrides['solution']['metadata'];
            }

            $overrides['solution']['metadata'] = array_replace($existingMetadata, $metadataOverrides);
        }

        return $catalog->buildProviderSpec($slug, $modelType, $overrides);
    }

    /**
     * @param array<string, mixed> $specData
     * @return array<string, mixed>
     */
    private static function normalizeCatalogConfig(array $specData): array
    {
        $catalogConfig = [];
        if (array_key_exists('catalog', $specData)) {
            $catalog = $specData['catalog'];
            if (is_array($catalog)) {
                $catalogConfig = $catalog;
            } elseif (is_string($catalog)) {
                $catalogConfig['slug'] = $catalog;
            }
        }

        if (isset($specData['catalog_slug'])) {
            $catalogConfig['slug'] = $specData['catalog_slug'];
        }

        if (isset($specData['catalog_model_type'])) {
            $catalogConfig['model_type'] = $specData['catalog_model_type'];
        } elseif (!isset($catalogConfig['model_type']) && isset($specData['model_type'])) {
            $catalogConfig['model_type'] = $specData['model_type'];
        }

        if (isset($specData['catalog_overrides']) && is_array($specData['catalog_overrides'])) {
            $catalogConfig['overrides'] = $specData['catalog_overrides'];
        } elseif (!isset($catalogConfig['overrides']) && isset($specData['overrides']) && is_array($specData['overrides'])) {
            $catalogConfig['overrides'] = $specData['overrides'];
        }

        if (isset($specData['metadata']) && is_array($specData['metadata'])) {
            $catalogConfig['metadata'] = $specData['metadata'];
        }

        return $catalogConfig;
    }

    /**
     * @param array<string, mixed> $catalogConfig
     */
    private static function extractSlug(array $catalogConfig): string
    {
        if (!isset($catalogConfig['slug']) || trim((string) $catalogConfig['slug']) === '') {
            throw new InvalidArgumentException('Catalog-backed provider entries require a non-empty "slug".');
        }

        return trim((string) $catalogConfig['slug']);
    }

    /**
     * @param array<string, mixed> $catalogConfig
     */
    private static function extractModelType(array $catalogConfig): string
    {
        $modelType = isset($catalogConfig['model_type']) ? trim((string) $catalogConfig['model_type']) : '';
        return $modelType === '' ? 'generation' : $modelType;
    }

    /**
     * @param array<string, mixed> $catalogConfig
     * @return array<string, mixed>
     */
    private static function extractOverrides(array $catalogConfig): array
    {
        if (!isset($catalogConfig['overrides']) || !is_array($catalogConfig['overrides'])) {
            return [];
        }

        return $catalogConfig['overrides'];
    }

    /**
     * @param array<string, mixed> $specData
     * @param array<string, mixed> $catalogConfig
     * @return array<string, mixed>
     */
    private static function extractMetadataOverrides(array $specData, array $catalogConfig): array
    {
        $metadata = [];
        if (isset($catalogConfig['metadata']) && is_array($catalogConfig['metadata'])) {
            $metadata = array_replace($metadata, $catalogConfig['metadata']);
        }

        if (isset($catalogConfig['metadata_overrides']) && is_array($catalogConfig['metadata_overrides'])) {
            $metadata = array_replace($metadata, $catalogConfig['metadata_overrides']);
        }

        if (isset($specData['metadata_overrides']) && is_array($specData['metadata_overrides'])) {
            $metadata = array_replace($metadata, $specData['metadata_overrides']);
        }

        foreach (['tier', 'latency_tier', 'cost_ceiling', 'compliance'] as $key) {
            if (array_key_exists($key, $specData) && $specData[$key] !== null) {
                $metadata[$key] = $specData[$key];
            }
        }

        return $metadata;
    }
}
</document_content>
</document>

<document index="32">
<source>src/Config/ProviderSpec.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Config/ProviderSpec.php

namespace ParaGra\Config;

use InvalidArgumentException;

use function array_key_exists;
use function is_string;
use function sprintf;
use function trim;

final class ProviderSpec
{
    /**
     * @param array<string, mixed> $solution
     */
    public function __construct(
        public readonly string $provider,
        public readonly string $model,
        public readonly string $apiKey,
        public readonly array $solution,
    ) {
    }

    /**
     * Build a specification from raw configuration array.
     *
     * @param array<string, mixed> $data
     */
    public static function fromArray(array $data): self
    {
        self::assertRequiredKeys($data);

        if (!is_array($data['solution'])) {
            throw new InvalidArgumentException('The solution configuration must be an array.');
        }

        return new self(
            provider: self::sanitizeString($data['provider'], 'provider'),
            model: self::sanitizeString($data['model'], 'model'),
            apiKey: self::sanitizeString($data['api_key'], 'api_key'),
            solution: $data['solution'],
        );
    }

    /**
     * Convert back to a normalized array payload.
     *
     * @return array{
     *     provider: string,
     *     model: string,
     *     api_key: string,
     *     solution: array<string, mixed>
     * }
     */
    public function toArray(): array
    {
        return [
            'provider' => $this->provider,
            'model' => $this->model,
            'api_key' => $this->apiKey,
            'solution' => $this->solution,
        ];
    }

    /**
     * @param array<string, mixed> $data
     */
    private static function assertRequiredKeys(array $data): void
    {
        foreach (['provider', 'model', 'api_key', 'solution'] as $key) {
            if (!array_key_exists($key, $data)) {
                throw new InvalidArgumentException(sprintf('Missing required provider spec key "%s".', $key));
            }
        }
    }

    private static function sanitizeString(mixed $value, string $field): string
    {
        if (!is_string($value)) {
            throw new InvalidArgumentException(sprintf('The "%s" field must be a string.', $field));
        }

        $trimmed = trim($value);
        if ($trimmed === '') {
            throw new InvalidArgumentException(sprintf('The "%s" field cannot be empty.', $field));
        }

        return $trimmed;
    }
}
</document_content>
</document>

<document index="33">
<source>src/Embedding/CohereEmbeddingConfig.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/CohereEmbeddingConfig.php

namespace ParaGra\Embedding;

use InvalidArgumentException;
use ParaGra\Util\ConfigValidator;

final class CohereEmbeddingConfig
{
    public const DEFAULT_MODEL = 'embed-english-v3.0';
    public const DEFAULT_INPUT_TYPE = 'search_document';
    public const DEFAULT_BASE_URI = 'https://api.cohere.ai';
    public const DEFAULT_ENDPOINT = '/v1/embed';
    public const DEFAULT_MAX_BATCH = 96;

    /**
     * @var array<string, int>
     */
    public const MODEL_DIMENSIONS = [
        'embed-english-v3.0' => 1024,
        'embed-english-light-v3.0' => 384,
        'embed-multilingual-v3.0' => 1024,
        'embed-multilingual-light-v3.0' => 384,
        'embed-multilingual-v2.0' => 768,
    ];

    private const ALLOWED_TRUNCATE = ['START', 'END', 'NONE'];

    private const ALLOWED_EMBEDDING_TYPES = ['float', 'int8', 'binary'];

    /**
     * @param list<string> $embeddingTypes
     */
    public function __construct(
        public string $apiKey,
        public string $model,
        public string $inputType = self::DEFAULT_INPUT_TYPE,
        public ?string $truncate = null,
        public array $embeddingTypes = ['float'],
        public int $maxBatchSize = self::DEFAULT_MAX_BATCH,
        public string $baseUri = self::DEFAULT_BASE_URI,
        public string $endpoint = self::DEFAULT_ENDPOINT,
        public ?int $defaultDimensions = null,
    ) {
        if ($embeddingTypes === []) {
            throw new InvalidArgumentException('Cohere embedding types must include at least one entry.');
        }
    }

    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::requireEnv('COHERE_API_KEY');
        $model = ConfigValidator::getEnv('COHERE_EMBED_MODEL', self::DEFAULT_MODEL);
        $model = $model !== '' ? $model : self::DEFAULT_MODEL;

        $inputType = ConfigValidator::getEnv('COHERE_EMBED_INPUT_TYPE', self::DEFAULT_INPUT_TYPE);
        $inputType = $inputType !== '' ? strtolower($inputType) : self::DEFAULT_INPUT_TYPE;

        $truncate = ConfigValidator::getEnv('COHERE_EMBED_TRUNCATE', '');
        $truncate = self::normalizeTruncate($truncate);

        $embeddingTypes = self::parseEmbeddingTypes(ConfigValidator::getEnv('COHERE_EMBED_TYPES', 'float'));

        $maxBatchEnv = (int) ConfigValidator::getEnv(
            'COHERE_EMBED_MAX_BATCH',
            (string) self::DEFAULT_MAX_BATCH
        );
        $maxBatchSize = $maxBatchEnv > 0 ? $maxBatchEnv : self::DEFAULT_MAX_BATCH;

        $baseUri = ConfigValidator::getEnv('COHERE_EMBED_BASE_URL', self::DEFAULT_BASE_URI);
        $baseUri = $baseUri !== '' ? $baseUri : self::DEFAULT_BASE_URI;

        $endpoint = ConfigValidator::getEnv('COHERE_EMBED_ENDPOINT', self::DEFAULT_ENDPOINT);
        $endpoint = $endpoint !== '' ? $endpoint : self::DEFAULT_ENDPOINT;

        $dimensions = self::MODEL_DIMENSIONS[$model] ?? null;

        return new self(
            apiKey: $apiKey,
            model: $model,
            inputType: $inputType,
            truncate: $truncate,
            embeddingTypes: $embeddingTypes,
            maxBatchSize: $maxBatchSize,
            baseUri: $baseUri,
            endpoint: $endpoint,
            defaultDimensions: $dimensions,
        );
    }

    private static function normalizeTruncate(string $truncate): ?string
    {
        if ($truncate === '') {
            return null;
        }

        $upper = strtoupper($truncate);
        if (!in_array($upper, self::ALLOWED_TRUNCATE, true)) {
            throw new InvalidArgumentException('COHERE_EMBED_TRUNCATE must be START, END, or NONE.');
        }

        return $upper === 'NONE' ? null : $upper;
    }

    /**
     * @return list<string>
     */
    private static function parseEmbeddingTypes(string $raw): array
    {
        $parts = array_filter(array_map(
            static fn (string $value): string => strtolower(trim($value)),
            explode(',', $raw)
        ), static fn (string $value): bool => $value !== '');

        if ($parts === []) {
            $parts = ['float'];
        }

        $validated = [];
        foreach ($parts as $type) {
            if (!in_array($type, self::ALLOWED_EMBEDDING_TYPES, true)) {
                throw new InvalidArgumentException('COHERE_EMBED_TYPES includes an unsupported value.');
            }
            $validated[] = $type;
        }

        return array_values(array_unique($validated));
    }
}
</document_content>
</document>

<document index="34">
<source>src/Embedding/CohereEmbeddingProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/CohereEmbeddingProvider.php

namespace ParaGra\Embedding;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use InvalidArgumentException;
use RuntimeException;

use function array_is_list;
use function array_map;
use function count;
use function is_array;
use function is_numeric;
use function ltrim;
use function reset;
use function rtrim;
use function sqrt;

final class CohereEmbeddingProvider implements EmbeddingProviderInterface
{
    private CohereEmbeddingConfig $config;

    private ClientInterface $client;

    public function __construct(CohereEmbeddingConfig $config, ?ClientInterface $client = null)
    {
        $this->config = $config;
        $this->client = $client ?? new HttpClient([
            'timeout' => 30,
        ]);
    }

    public function getProvider(): string
    {
        return 'cohere';
    }

    public function getModel(): string
    {
        return $this->config->model;
    }

    /**
     * @return list<int>
     */
    public function getSupportedDimensions(): array
    {
        $dimensions = [];

        foreach (CohereEmbeddingConfig::MODEL_DIMENSIONS as $dimension) {
            $dimensions[] = $dimension;
        }

        if ($this->config->defaultDimensions !== null) {
            $dimensions[] = $this->config->defaultDimensions;
        }

        $dimensions = array_values(array_unique(array_filter(
            $dimensions,
            static fn (int $value): bool => $value > 0
        )));
        sort($dimensions);

        return $dimensions;
    }

    public function getMaxBatchSize(): int
    {
        return $this->config->maxBatchSize;
    }

    public function embed(EmbeddingRequest $request): array
    {
        if ($request->getBatchSize() > $this->config->maxBatchSize) {
            throw new InvalidArgumentException('Embedding batch exceeds the configured batch limit.');
        }

        $requestedDimensions = $request->getDimensions();
        if ($requestedDimensions !== null && $requestedDimensions !== $this->config->defaultDimensions) {
            throw new InvalidArgumentException('Cohere embeddings do not support overriding dimensions.');
        }

        $payload = [
            'model' => $this->config->model,
            'texts' => array_map(
                static fn (array $input): string => $input['text'],
                $request->getInputs()
            ),
            'input_type' => $this->config->inputType,
        ];

        if ($this->config->truncate !== null) {
            $payload['truncate'] = $this->config->truncate;
        }

        if ($this->config->embeddingTypes !== []) {
            $payload['embedding_types'] = $this->config->embeddingTypes;
        }

        $url = $this->buildUrl();

        try {
            $response = $this->client->request('POST', $url, [
                'headers' => [
                    'Authorization' => 'Bearer ' . $this->config->apiKey,
                    'Content-Type' => 'application/json',
                    'Accept' => 'application/json',
                ],
                'json' => $payload,
            ]);
        } catch (GuzzleException $exception) {
            throw new RuntimeException(
                'Cohere embeddings request failed: ' . $exception->getMessage(),
                (int) $exception->getCode(),
                $exception
            );
        }

        try {
            $data = json_decode((string) $response->getBody(), true, flags: JSON_THROW_ON_ERROR);
        } catch (\JsonException $exception) {
            throw new RuntimeException(
                'Failed to decode Cohere embeddings response: ' . $exception->getMessage(),
                0,
                $exception
            );
        }

        $vectors = [];
        $inputs = $request->getInputs();

        foreach ($this->extractVectors($data['embeddings'] ?? null) as $index => $values) {
            $normalized = $request->shouldNormalize()
                ? $this->normalizeVector($values)
                : $this->castToFloatList($values);

            $input = $inputs[$index] ?? ['id' => null, 'metadata' => null];
            $vectors[] = [
                'id' => $input['id'],
                'values' => $normalized,
                'metadata' => $input['metadata'] ?? null,
            ];
        }

        $dimensions = $vectors !== []
            ? count($vectors[0]['values'])
            : ($this->config->defaultDimensions ?? 0);

        $usage = null;
        if (isset($data['meta']['billed_units']) && is_array($data['meta']['billed_units'])) {
            $usage = $data['meta']['billed_units'];
        }

        return [
            'provider' => $this->getProvider(),
            'model' => $this->config->model,
            'dimensions' => $dimensions,
            'vectors' => $vectors,
            'usage' => $usage,
        ];
    }

    private function buildUrl(): string
    {
        return rtrim($this->config->baseUri, '/') . '/' . ltrim($this->config->endpoint, '/');
    }

    /**
     * @param mixed $rawEmbeddings
     * @return list<list<float>>
     */
    private function extractVectors(mixed $rawEmbeddings): array
    {
        if (!is_array($rawEmbeddings)) {
            throw new RuntimeException('Cohere embeddings response missing embeddings payload.');
        }

        if (array_is_list($rawEmbeddings)) {
            return $this->castVectorsList($rawEmbeddings);
        }

        foreach ($this->config->embeddingTypes as $type) {
            if (isset($rawEmbeddings[$type]) && is_array($rawEmbeddings[$type])) {
                return $this->castVectorsList($rawEmbeddings[$type]);
            }
        }

        if (isset($rawEmbeddings['float']) && is_array($rawEmbeddings['float'])) {
            return $this->castVectorsList($rawEmbeddings['float']);
        }

        $first = reset($rawEmbeddings);
        if (is_array($first)) {
            return $this->castVectorsList($first);
        }

        throw new RuntimeException('Cohere embeddings response contained no usable vector data.');
    }

    /**
     * @param list<mixed> $vectors
     * @return list<list<float>>
     */
    private function castVectorsList(array $vectors): array
    {
        $results = [];

        foreach ($vectors as $vector) {
            if (!is_array($vector)) {
                throw new RuntimeException('Cohere embeddings vector entry must be an array of numbers.');
            }
            $results[] = $this->castToFloatList($vector);
        }

        return $results;
    }

    /**
     * @param list<float|int|string> $values
     * @return list<float>
     */
    private function castToFloatList(array $values): array
    {
        return array_map(
            static function ($value): float {
                if (!is_numeric($value)) {
                    throw new RuntimeException('Cohere embeddings vector must contain numeric values.');
                }

                return (float) $value;
            },
            $values
        );
    }

    /**
     * @param list<float> $vector
     * @return list<float>
     */
    private function normalizeVector(array $vector): array
    {
        $norm = 0.0;
        foreach ($vector as $value) {
            $norm += $value * $value;
        }
        $norm = sqrt($norm);

        if ($norm === 0.0) {
            return $vector;
        }

        return array_map(
            static fn (float $value): float => $value / $norm,
            $vector
        );
    }
}
</document_content>
</document>

<document index="35">
<source>src/Embedding/EmbeddingProviderInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/EmbeddingProviderInterface.php

namespace ParaGra\Embedding;

/**
 * Standard contract for providers that expose embedding endpoints.
 *
 * Providers should implement batch-friendly logic (OpenAI, Cohere, Gemini,
 * Voyage, etc.) and honour the metadata filtering conventions captured
 * in {@see EmbeddingRequest}.
 */
interface EmbeddingProviderInterface
{
    /**
     * Machine-friendly provider slug such as "openai" or "cohere".
     */
    public function getProvider(): string;

    /**
     * Returns the upstream model identifier (e.g. text-embedding-3-large).
     */
    public function getModel(): string;

    /**
     * Report supported output dimensions for validation/tuning.
     *
     * @return list<int>
     */
    public function getSupportedDimensions(): array;

    /**
     * Maximum number of inputs accepted by a single API call.
     */
    public function getMaxBatchSize(): int;

    /**
     * Generate embeddings for the provided batch.
     *
     * @return array{
     *     provider: string,
     *     model: string,
     *     dimensions: int,
     *     vectors: list<array{
     *         id: string|null,
     *         values: list<float>,
     *         metadata: array<string, mixed>|null
     *     }>,
     *     usage: array<string, mixed>|null
     * }
     */
    public function embed(EmbeddingRequest $request): array;
}
</document_content>
</document>

<document index="36">
<source>src/Embedding/EmbeddingRequest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/EmbeddingRequest.php

namespace ParaGra\Embedding;

use InvalidArgumentException;

use function array_is_list;
use function array_key_exists;
use function count;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_string;
use function sprintf;
use function trim;

/**
 * Immutable value object describing a batch embedding request.
 *
 * Inspired by the `vector-search-apis` research, this structure models
 * batch-friendly inputs, metadata filters, and dimension hints so
 * downstream providers can share the same contract.
 */
final class EmbeddingRequest
{
    /**
     * @var list<array{
     *     id: string|null,
     *     text: string,
     *     metadata: array<string, string|int|float|bool|list<string|int|float|bool>>|null
     * }>
     */
    private array $inputs;

    /**
     * @var array<string, string|int|float|bool|list<string|int|float|bool>>|null
     */
    private ?array $metadataFilter;

    public function __construct(
        array $inputs,
        private readonly ?int $dimensions = null,
        private readonly bool $normalize = true,
        ?array $metadataFilter = null,
    ) {
        $this->inputs = $this->normalizeInputs($inputs);
        $this->metadataFilter = $metadataFilter !== null
            ? $this->validateMetadataMap($metadataFilter, 'metadata filter')
            : null;

        if ($this->dimensions !== null && $this->dimensions <= 0) {
            throw new InvalidArgumentException('Dimensions must be positive when provided.');
        }
    }

    /**
     * @return list<array{
     *     id: string|null,
     *     text: string,
     *     metadata: array<string, string|int|float|bool|list<string|int|float|bool>>|null
     * }>
     */
    public function getInputs(): array
    {
        return $this->inputs;
    }

    public function getDimensions(): ?int
    {
        return $this->dimensions;
    }

    public function shouldNormalize(): bool
    {
        return $this->normalize;
    }

    /**
     * @return array<string, string|int|float|bool|list<string|int|float|bool>>|null
     */
    public function getMetadataFilter(): ?array
    {
        return $this->metadataFilter;
    }

    public function getBatchSize(): int
    {
        return count($this->inputs);
    }

    /**
     * @return array{
     *     inputs: list<array{
     *         id: string|null,
     *         text: string,
     *         metadata: array<string, string|int|float|bool|list<string|int|float|bool>>|null
     *     }>,
     *     dimensions: int|null,
     *     normalize: bool,
     *     metadata_filter: array<string, string|int|float|bool|list<string|int|float|bool>>|null
     * }
     */
    public function toArray(): array
    {
        return [
            'inputs' => $this->inputs,
            'dimensions' => $this->dimensions,
            'normalize' => $this->normalize,
            'metadata_filter' => $this->metadataFilter,
        ];
    }

    /**
     * @param list<array{id?: string|null, text: string, metadata?: array<string, mixed>}|string> $inputs
     *
     * @return list<array{
     *     id: string|null,
     *     text: string,
     *     metadata: array<string, string|int|float|bool|list<string|int|float|bool>>|null
     * }>
     */
    private function normalizeInputs(array $inputs): array
    {
        if ($inputs === []) {
            throw new InvalidArgumentException('EmbeddingRequest requires at least one input.');
        }

        $normalized = [];
        foreach ($inputs as $index => $input) {
            if (is_string($input)) {
                $normalized[] = [
                    'id' => null,
                    'text' => $this->normalizeText($input, $index),
                    'metadata' => null,
                ];
                continue;
            }

            if (!is_array($input)) {
                throw new InvalidArgumentException('Embedding inputs must be strings or arrays.');
            }

            if (!array_key_exists('text', $input) || !is_string($input['text'])) {
                throw new InvalidArgumentException(sprintf('Embedding input %d must include non-empty text.', $index));
            }

            $id = null;
            if (array_key_exists('id', $input)) {
                $id = $this->sanitizeId($input['id']);
            }

            $metadata = null;
            if (array_key_exists('metadata', $input)) {
                if (!is_array($input['metadata'])) {
                    throw new InvalidArgumentException(
                        sprintf('Embedding input %d metadata must be an array.', $index)
                    );
                }

                $metadata = $this->validateMetadataMap(
                    $input['metadata'],
                    sprintf('input %d metadata', $index)
                );
            }

            $normalized[] = [
                'id' => $id,
                'text' => $this->normalizeText($input['text'], $index),
                'metadata' => $metadata,
            ];
        }

        return $normalized;
    }

    private function normalizeText(string $text, int $index): string
    {
        $clean = trim($text);
        if ($clean === '') {
            throw new InvalidArgumentException(sprintf('Embedding input %d must include non-empty text.', $index));
        }

        return $clean;
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     *
     * @return array<string, string|int|float|bool|list<string|int|float|bool>>
     */
    private function validateMetadataMap(array $metadata, string $context): array
    {
        $validated = [];
        foreach ($metadata as $key => $value) {
            if (!is_string($key)) {
                throw new InvalidArgumentException(sprintf('Every %s key must be a non-empty string.', $context));
            }

            $cleanKey = trim($key);
            if ($cleanKey === '') {
                throw new InvalidArgumentException(sprintf('Every %s key must be a non-empty string.', $context));
            }

            $validated[$cleanKey] = $this->normalizeMetadataValue($value, $context, $cleanKey);
        }

        return $validated;
    }

    /**
     * @return string|int|float|bool|list<string|int|float|bool>
     */
    private function normalizeMetadataValue(mixed $value, string $context, string $key): string|int|float|bool|array
    {
        if ($this->isScalar($value)) {
            return $value;
        }

        if (!is_array($value) || $value === []) {
            throw new InvalidArgumentException(
                sprintf('Metadata values must be scalar or a non-empty list (%s:%s).', $context, $key)
            );
        }

        if (!array_is_list($value)) {
            throw new InvalidArgumentException(
                sprintf('Metadata lists must be indexed sequentially (%s:%s).', $context, $key)
            );
        }

        $list = [];
        foreach ($value as $entry) {
            if (!$this->isScalar($entry)) {
                throw new InvalidArgumentException(
                    sprintf('Metadata list entries must be scalar (%s:%s).', $context, $key)
                );
            }
            $list[] = $entry;
        }

        return $list;
    }

    private function sanitizeId(mixed $id): ?string
    {
        if ($id === null) {
            return null;
        }

        if (!is_string($id)) {
            throw new InvalidArgumentException('Embedding input IDs must be strings when provided.');
        }

        $clean = trim($id);

        return $clean === '' ? null : $clean;
    }

    private function isScalar(mixed $value): bool
    {
        return is_string($value) || is_int($value) || is_float($value) || is_bool($value);
    }
}
</document_content>
</document>

<document index="37">
<source>src/Embedding/GeminiEmbeddingConfig.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/GeminiEmbeddingConfig.php

namespace ParaGra\Embedding;

use Gemini\Enums\TaskType;
use InvalidArgumentException;
use ParaGra\Exception\ConfigurationException;
use ParaGra\Util\ConfigValidator;

use function in_array;
use function sprintf;
use function str_replace;
use function strtoupper;

final class GeminiEmbeddingConfig
{
    /**
     * @var array<string, int>
     */
    public const MODEL_DIMENSIONS = [
        'text-embedding-004' => 768,
        'embedding-001' => 3072,
    ];

    /**
     * Models that accept the `outputDimensionality` override.
     *
     * @var list<string>
     */
    private const DIMENSIONALITY_OVERRIDE_MODELS = [
        'text-embedding-004',
    ];

    public function __construct(
        public string $apiKey,
        public string $model,
        public int $maxBatchSize = 250,
        public ?string $baseUrl = null,
        public ?TaskType $taskType = null,
        public ?string $title = null,
        public ?int $defaultDimensions = null,
    ) {
    }

    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::getEnv('GEMINI_EMBED_API_KEY', '');
        if ($apiKey === '') {
            $apiKey = ConfigValidator::getEnv('GOOGLE_API_KEY', '');
        }

        if ($apiKey === '') {
            throw ConfigurationException::invalid(
                'GEMINI_EMBED_API_KEY',
                'Set GEMINI_EMBED_API_KEY or GOOGLE_API_KEY to enable Gemini embeddings.'
            );
        }

        $model = ConfigValidator::getEnv('GEMINI_EMBED_MODEL', 'text-embedding-004');
        if ($model === '') {
            $model = 'text-embedding-004';
        }

        $batchValue = (int) ConfigValidator::getEnv('GEMINI_EMBED_MAX_BATCH', '250');
        $maxBatchSize = $batchValue > 0 ? $batchValue : 250;

        $defaultDimensions = self::parseDimensions(
            ConfigValidator::getEnv('GEMINI_EMBED_DIMENSIONS', ''),
            $model
        );

        return new self(
            apiKey: $apiKey,
            model: $model,
            maxBatchSize: $maxBatchSize,
            baseUrl: ConfigValidator::getEnv('GEMINI_EMBED_BASE_URL', '') ?: null,
            taskType: self::parseTaskType(ConfigValidator::getEnv('GEMINI_EMBED_TASK_TYPE', '')),
            title: ConfigValidator::getEnv('GEMINI_EMBED_TITLE', '') ?: null,
            defaultDimensions: $defaultDimensions,
        );
    }

    /**
     * @throws InvalidArgumentException
     */
    private static function parseDimensions(string $value, string $model): ?int
    {
        if ($value === '') {
            return self::MODEL_DIMENSIONS[$model] ?? null;
        }

        $dimensions = (int) $value;
        if ($dimensions <= 0) {
            throw new InvalidArgumentException('GEMINI_EMBED_DIMENSIONS must be a positive integer.');
        }

        if (!self::supportsDimensionalityOverride($model)) {
            $canonical = self::MODEL_DIMENSIONS[$model] ?? null;
            if ($canonical !== null && $dimensions !== $canonical) {
                throw new InvalidArgumentException(sprintf(
                    'Model "%s" does not support overriding dimensions.',
                    $model
                ));
            }
        }

        return $dimensions;
    }

    private static function supportsDimensionalityOverride(string $model): bool
    {
        return in_array($model, self::DIMENSIONALITY_OVERRIDE_MODELS, true);
    }

    private static function parseTaskType(string $value): ?TaskType
    {
        if ($value === '') {
            return null;
        }

        $normalized = strtoupper(str_replace('-', '_', $value));
        foreach (TaskType::cases() as $case) {
            if ($case->name === $normalized || $case->value === $normalized) {
                if ($case === TaskType::TASK_TYPE_UNSPECIFIED) {
                    return null;
                }

                return $case;
            }
        }

        throw ConfigurationException::invalid('GEMINI_EMBED_TASK_TYPE', 'Unsupported task type: ' . $value);
    }

    public function allowsCustomDimensions(): bool
    {
        return self::supportsDimensionalityOverride($this->model);
    }

    public function canonicalDimensions(): ?int
    {
        return self::MODEL_DIMENSIONS[$this->model] ?? null;
    }
}
</document_content>
</document>

<document index="38">
<source>src/Embedding/GeminiEmbeddingProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/GeminiEmbeddingProvider.php

namespace ParaGra\Embedding;

use Gemini\Contracts\ClientContract as GeminiClient;
use Gemini\Contracts\Resources\EmbeddingModalContract;
use Gemini\Requests\GenerativeModel\EmbedContentRequest;
use InvalidArgumentException;
use RuntimeException;

use function array_filter;
use function array_map;
use function array_unique;
use function array_values;
use function count;
use function sort;
use function sqrt;

final class GeminiEmbeddingProvider implements EmbeddingProviderInterface
{
    private GeminiEmbeddingConfig $config;

    private GeminiClient $client;

    public function __construct(GeminiEmbeddingConfig $config, ?GeminiClient $client = null)
    {
        $this->config = $config;
        $this->client = $client ?? $this->createClient($config);
    }

    public function getProvider(): string
    {
        return 'gemini';
    }

    public function getModel(): string
    {
        return $this->config->model;
    }

    /**
     * @return list<int>
     */
    public function getSupportedDimensions(): array
    {
        $dimensions = array_filter([
            $this->config->defaultDimensions,
            $this->config->canonicalDimensions(),
        ], static fn (?int $value): bool => $value !== null && $value > 0);

        $unique = array_values(array_unique(array_map(
            static fn (int $value): int => $value,
            $dimensions
        )));
        sort($unique);

        return $unique;
    }

    public function getMaxBatchSize(): int
    {
        return $this->config->maxBatchSize;
    }

    public function embed(EmbeddingRequest $request): array
    {
        $batchSize = $request->getBatchSize();
        if ($batchSize > $this->config->maxBatchSize) {
            throw new InvalidArgumentException('Embedding batch exceeds the configured batch limit.');
        }

        $outputDimensions = $this->resolveOutputDimensions($request);
        $inputs = $request->getInputs();
        $payloads = $this->buildRequests($inputs, $outputDimensions);

        try {
            $response = $this->embeddingResource()->batchEmbedContents(...$payloads);
        } catch (\Throwable $exception) {
            throw new RuntimeException(
                'Gemini embeddings request failed: ' . $exception->getMessage(),
                (int) $exception->getCode(),
                $exception
            );
        }

        $vectors = [];
        foreach ($response->embeddings as $index => $embedding) {
            $values = $embedding->values;
            if ($request->shouldNormalize()) {
                $values = $this->normalizeVector($values);
            }

            $input = $inputs[$index] ?? ['id' => null, 'metadata' => null];
            $vectors[] = [
                'id' => $input['id'],
                'values' => $values,
                'metadata' => $input['metadata'] ?? null,
            ];
        }

        $dimensions = $vectors !== []
            ? count($vectors[0]['values'])
            : ($outputDimensions ?? $this->fallbackDimensions());

        return [
            'provider' => $this->getProvider(),
            'model' => $this->config->model,
            'dimensions' => $dimensions,
            'vectors' => $vectors,
            'usage' => null,
        ];
    }

    /**
     * @param list<array{id: string|null, text: string, metadata: array<string, mixed>|null}> $inputs
     * @return list<EmbedContentRequest>
     */
    private function buildRequests(array $inputs, ?int $dimensions): array
    {
        return array_map(
            fn (array $input): EmbedContentRequest => new EmbedContentRequest(
                model: $this->config->model,
                part: $input['text'],
                taskType: $this->config->taskType,
                title: $this->config->title,
                outputDimensionality: $dimensions
            ),
            $inputs
        );
    }

    private function resolveOutputDimensions(EmbeddingRequest $request): ?int
    {
        $requested = $request->getDimensions();
        if ($requested !== null) {
            if (!$this->config->allowsCustomDimensions()) {
                throw new InvalidArgumentException('Gemini model does not support overriding dimensions.');
            }

            return $requested;
        }

        if (!$this->config->allowsCustomDimensions()) {
            return null;
        }

        if ($this->config->defaultDimensions !== null) {
            return $this->config->defaultDimensions;
        }

        return $this->config->canonicalDimensions();
    }

    private function fallbackDimensions(): int
    {
        return $this->config->defaultDimensions
            ?? $this->config->canonicalDimensions()
            ?? 0;
    }

    /**
     * @param list<float> $values
     * @return list<float>
     */
    private function normalizeVector(array $values): array
    {
        $norm = 0.0;
        foreach ($values as $value) {
            $norm += $value * $value;
        }
        $norm = sqrt($norm);

        if ($norm === 0.0) {
            return $values;
        }

        return array_map(
            static fn (float $value): float => $value / $norm,
            $values
        );
    }

    private function embeddingResource(): EmbeddingModalContract
    {
        return $this->client->embeddingModel($this->config->model);
    }

    private function createClient(GeminiEmbeddingConfig $config): GeminiClient
    {
        $factory = \Gemini::factory()->withApiKey($config->apiKey);

        if ($config->baseUrl !== null) {
            $factory = $factory->withBaseUrl($config->baseUrl);
        }

        return $factory->make();
    }
}
</document_content>
</document>

<document index="39">
<source>src/Embedding/OpenAiEmbeddingConfig.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/OpenAiEmbeddingConfig.php

namespace ParaGra\Embedding;

use ParaGra\Util\ConfigValidator;

final class OpenAiEmbeddingConfig
{
    /**
     * @var array<string, int>
     */
    public const MODEL_DIMENSIONS = [
        'text-embedding-3-small' => 1536,
        'text-embedding-3-large' => 3072,
        'text-embedding-ada-002' => 1536,
    ];

    public function __construct(
        public string $apiKey,
        public string $model,
        public ?string $baseUrl = null,
        public int $maxBatchSize = 2048,
        public ?int $defaultDimensions = null,
    ) {
    }

    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::requireEnv('OPENAI_API_KEY');
        $model = ConfigValidator::getEnv('OPENAI_EMBED_MODEL', 'text-embedding-3-small');
        $resolvedModel = $model !== '' ? $model : 'text-embedding-3-small';
        $baseUrl = ConfigValidator::getEnv('OPENAI_EMBED_BASE_URL', '');
        $maxBatch = (int) ConfigValidator::getEnv('OPENAI_EMBED_MAX_BATCH', '2048');
        $maxBatchSize = $maxBatch > 0 ? $maxBatch : 2048;

        $dimensionStr = ConfigValidator::getEnv('OPENAI_EMBED_DIMENSIONS', '');
        $defaultDimensions = self::parseDimensions($dimensionStr, $resolvedModel);

        return new self(
            apiKey: $apiKey,
            model: $resolvedModel,
            baseUrl: $baseUrl !== '' ? $baseUrl : null,
            maxBatchSize: $maxBatchSize,
            defaultDimensions: $defaultDimensions,
        );
    }

    private static function parseDimensions(string $dimensionStr, string $model): ?int
    {
        if ($dimensionStr !== '') {
            $dimensions = (int) $dimensionStr;

            return $dimensions > 0 ? $dimensions : null;
        }

        return self::MODEL_DIMENSIONS[$model] ?? null;
    }
}
</document_content>
</document>

<document index="40">
<source>src/Embedding/OpenAiEmbeddingProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/OpenAiEmbeddingProvider.php

namespace ParaGra\Embedding;

use InvalidArgumentException;
use OpenAI\Contracts\ClientContract as OpenAiClient;
use OpenAI\Contracts\Resources\EmbeddingsContract as OpenAiEmbeddingsResource;
use RuntimeException;

final class OpenAiEmbeddingProvider implements EmbeddingProviderInterface
{
    private OpenAiEmbeddingConfig $config;

    private OpenAiClient $client;

    public function __construct(OpenAiEmbeddingConfig $config, ?OpenAiClient $client = null)
    {
        $this->config = $config;
        $this->client = $client ?? $this->createClient($config);
    }

    public function getProvider(): string
    {
        return 'openai';
    }

    public function getModel(): string
    {
        return $this->config->model;
    }

    /**
     * @return list<int>
     */
    public function getSupportedDimensions(): array
    {
        $dimensions = [];

        foreach (OpenAiEmbeddingConfig::MODEL_DIMENSIONS as $dimension) {
            $dimensions[] = $dimension;
        }

        if ($this->config->defaultDimensions !== null) {
            $dimensions[] = $this->config->defaultDimensions;
        }

        $dimensions = array_values(array_unique(array_filter($dimensions, static fn (int $value): bool => $value > 0)));
        sort($dimensions);

        return $dimensions;
    }

    public function getMaxBatchSize(): int
    {
        return $this->config->maxBatchSize;
    }

    public function embed(EmbeddingRequest $request): array
    {
        if ($request->getBatchSize() > $this->config->maxBatchSize) {
            throw new InvalidArgumentException('Embedding batch exceeds the configured batch limit.');
        }

        $payload = [
            'model' => $this->config->model,
            'input' => array_map(
                static fn (array $input): string => $input['text'],
                $request->getInputs()
            ),
        ];

        $dimensions = $this->resolveDimensions($request);
        if ($dimensions !== null) {
            $payload['dimensions'] = $dimensions;
        }

        try {
            $response = $this->embeddingsResource()->create($payload);
        } catch (\Throwable $exception) {
            throw new RuntimeException(
                'Failed to generate embeddings: ' . $exception->getMessage(),
                (int) $exception->getCode(),
                $exception
            );
        }

        $vectors = [];
        $inputs = $request->getInputs();
        foreach ($response->embeddings as $index => $embedding) {
            $values = $embedding->embedding;

            if ($request->shouldNormalize()) {
                $values = $this->normalizeVector($values);
            }

            $input = $inputs[$index] ?? ['id' => null, 'metadata' => null];
            $vectors[] = [
                'id' => $input['id'],
                'values' => $values,
                'metadata' => $input['metadata'] ?? null,
            ];
        }

        $usage = null;
        if ($response->usage !== null) {
            $usage = [
                'prompt_tokens' => $response->usage->promptTokens,
                'total_tokens' => $response->usage->totalTokens,
            ];
        }

        return [
            'provider' => $this->getProvider(),
            'model' => $this->config->model,
            'dimensions' => $vectors !== [] ? count($vectors[0]['values']) : ($dimensions ?? 0),
            'vectors' => $vectors,
            'usage' => $usage,
        ];
    }

    private function resolveDimensions(EmbeddingRequest $request): ?int
    {
        if ($request->getDimensions() !== null) {
            return $request->getDimensions();
        }

        if ($this->config->defaultDimensions !== null) {
            return $this->config->defaultDimensions;
        }

        return OpenAiEmbeddingConfig::MODEL_DIMENSIONS[$this->config->model] ?? null;
    }

    /**
     * @param list<float> $vector
     * @return list<float>
     */
    private function normalizeVector(array $vector): array
    {
        $norm = 0.0;
        foreach ($vector as $value) {
            $norm += $value * $value;
        }
        $norm = sqrt($norm);

        if ($norm === 0.0) {
            return $vector;
        }

        return array_map(
            static fn (float $value): float => $value / $norm,
            $vector
        );
    }

    private function embeddingsResource(): OpenAiEmbeddingsResource
    {
        return $this->client->embeddings();
    }

    private function createClient(OpenAiEmbeddingConfig $config): OpenAiClient
    {
        $factory = \OpenAI::factory()->withApiKey($config->apiKey);

        if ($config->baseUrl !== null) {
            $factory = $factory->withBaseUri($config->baseUrl);
        }

        return $factory->make();
    }
}
</document_content>
</document>

<document index="41">
<source>src/Embedding/VoyageEmbeddingConfig.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/VoyageEmbeddingConfig.php

namespace ParaGra\Embedding;

use InvalidArgumentException;
use ParaGra\Util\ConfigValidator;

use function array_filter;
use function array_unique;
use function array_values;
use function ctype_digit;
use function in_array;
use function ltrim;
use function sort;
use function strtolower;

final class VoyageEmbeddingConfig
{
    public const DEFAULT_MODEL = 'voyage-3';
    public const DEFAULT_BASE_URI = 'https://api.voyageai.com';
    public const DEFAULT_ENDPOINT = '/v1/embeddings';
    public const DEFAULT_MAX_BATCH = 128;
    public const DEFAULT_TIMEOUT = 30;

    /**
     * @var array<string, int>
     */
    public const MODEL_DIMENSIONS = [
        'voyage-3-large' => 2048,
        'voyage-3' => 1024,
        'voyage-3-lite' => 512,
        'voyage-2' => 1024,
        'voyage-2-lite' => 512,
    ];

    private const ALLOWED_INPUT_TYPES = ['document', 'query'];

    /**
     * @param string|null $inputType One of document/query or null (omit)
     */
    public function __construct(
        public string $apiKey,
        public string $model,
        public string $baseUri = self::DEFAULT_BASE_URI,
        public string $endpoint = self::DEFAULT_ENDPOINT,
        public int $maxBatchSize = self::DEFAULT_MAX_BATCH,
        public int $timeout = self::DEFAULT_TIMEOUT,
        public ?string $inputType = 'document',
        public bool $truncate = true,
        public string $encodingFormat = 'float',
        public ?int $defaultDimensions = null,
    ) {
        if ($this->maxBatchSize <= 0) {
            throw new InvalidArgumentException('Voyage embedding max batch size must be positive.');
        }

        if ($this->timeout <= 0) {
            throw new InvalidArgumentException('Voyage embedding timeout must be positive.');
        }

        if ($this->inputType !== null && !in_array($this->inputType, self::ALLOWED_INPUT_TYPES, true)) {
            throw new InvalidArgumentException('VOYAGE_EMBED_INPUT_TYPE must be document or query.');
        }

        if ($this->encodingFormat !== 'float') {
            throw new InvalidArgumentException('VOYAGE_EMBED_ENCODING currently only supports "float".');
        }
    }

    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::requireEnv('VOYAGE_API_KEY');
        $model = ConfigValidator::getEnv('VOYAGE_EMBED_MODEL', self::DEFAULT_MODEL);
        $model = $model !== '' ? $model : self::DEFAULT_MODEL;

        $baseUri = ConfigValidator::getEnv('VOYAGE_EMBED_BASE_URL', self::DEFAULT_BASE_URI);
        $baseUri = $baseUri !== '' ? $baseUri : self::DEFAULT_BASE_URI;

        $endpoint = ConfigValidator::getEnv('VOYAGE_EMBED_ENDPOINT', self::DEFAULT_ENDPOINT);
        $endpoint = $endpoint !== '' ? $endpoint : self::DEFAULT_ENDPOINT;

        $maxBatchValue = (int) ConfigValidator::getEnv(
            'VOYAGE_EMBED_MAX_BATCH',
            (string) self::DEFAULT_MAX_BATCH
        );
        $maxBatchSize = $maxBatchValue > 0 ? $maxBatchValue : self::DEFAULT_MAX_BATCH;

        $timeoutValue = (int) ConfigValidator::getEnv(
            'VOYAGE_EMBED_TIMEOUT',
            (string) self::DEFAULT_TIMEOUT
        );
        $timeout = $timeoutValue > 0 ? $timeoutValue : self::DEFAULT_TIMEOUT;

        $inputType = self::normalizeInputType(ConfigValidator::getEnv('VOYAGE_EMBED_INPUT_TYPE', 'document'));
        $truncate = self::parseBoolean(ConfigValidator::getEnv('VOYAGE_EMBED_TRUNCATE', 'true'));
        $encodingFormat = self::normalizeEncoding(ConfigValidator::getEnv('VOYAGE_EMBED_ENCODING', 'float'));
        $dimensions = self::parseDimensions(ConfigValidator::getEnv('VOYAGE_EMBED_DIMENSIONS', ''), $model);

        return new self(
            apiKey: $apiKey,
            model: $model,
            baseUri: $baseUri,
            endpoint: $endpoint,
            maxBatchSize: $maxBatchSize,
            timeout: $timeout,
            inputType: $inputType,
            truncate: $truncate,
            encodingFormat: $encodingFormat,
            defaultDimensions: $dimensions,
        );
    }

    private static function normalizeInputType(string $value): ?string
    {
        if ($value === '') {
            return 'document';
        }

        $normalized = strtolower($value);

        if ($normalized === 'none' || $normalized === 'null') {
            return null;
        }

        if (in_array($normalized, self::ALLOWED_INPUT_TYPES, true)) {
            return $normalized;
        }

        throw new InvalidArgumentException('VOYAGE_EMBED_INPUT_TYPE must be "document", "query", or blank.');
    }

    private static function parseBoolean(string $value): bool
    {
        if ($value === '') {
            return true;
        }

        $normalized = strtolower($value);

        return match ($normalized) {
            '1', 'true', 'yes', 'on' => true,
            '0', 'false', 'no', 'off' => false,
            default => throw new InvalidArgumentException('VOYAGE_EMBED_TRUNCATE must be boolean.'),
        };
    }

    private static function normalizeEncoding(string $value): string
    {
        if ($value === '' || strtolower($value) === 'float') {
            return 'float';
        }

        throw new InvalidArgumentException('VOYAGE_EMBED_ENCODING currently supports only "float".');
    }

    private static function parseDimensions(string $value, string $model): ?int
    {
        if ($value === '') {
            return self::MODEL_DIMENSIONS[$model] ?? null;
        }

        if (!ctype_digit(ltrim($value, '-'))) {
            throw new InvalidArgumentException('VOYAGE_EMBED_DIMENSIONS must be a positive integer.');
        }

        $dimensions = (int) $value;
        if ($dimensions <= 0) {
            throw new InvalidArgumentException('VOYAGE_EMBED_DIMENSIONS must be positive.');
        }

        return $dimensions;
    }

    /**
     * @return list<int>
     */
    public function supportedDimensions(): array
    {
        $dimensions = array_values(array_unique(array_filter(
            [
                $this->defaultDimensions,
                ...array_values(self::MODEL_DIMENSIONS),
            ],
            static fn (?int $value): bool => $value !== null && $value > 0
        )));
        sort($dimensions);

        return $dimensions;
    }
}
</document_content>
</document>

<document index="42">
<source>src/Embedding/VoyageEmbeddingProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Embedding/VoyageEmbeddingProvider.php

namespace ParaGra\Embedding;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use InvalidArgumentException;
use RuntimeException;

use function array_map;
use function count;
use function is_array;
use function is_numeric;
use function json_decode;
use function ltrim;
use function rtrim;
use function sqrt;

final class VoyageEmbeddingProvider implements EmbeddingProviderInterface
{
    private VoyageEmbeddingConfig $config;

    private ClientInterface $client;

    public function __construct(VoyageEmbeddingConfig $config, ?ClientInterface $client = null)
    {
        $this->config = $config;
        $this->client = $client ?? new HttpClient([
            'timeout' => $config->timeout,
        ]);
    }

    public function getProvider(): string
    {
        return 'voyage';
    }

    public function getModel(): string
    {
        return $this->config->model;
    }

    /**
     * @return list<int>
     */
    public function getSupportedDimensions(): array
    {
        return $this->config->supportedDimensions();
    }

    public function getMaxBatchSize(): int
    {
        return $this->config->maxBatchSize;
    }

    public function embed(EmbeddingRequest $request): array
    {
        if ($request->getBatchSize() > $this->config->maxBatchSize) {
            throw new InvalidArgumentException('Embedding batch exceeds the configured batch limit.');
        }

        $payload = [
            'model' => $this->config->model,
            'input' => array_map(
                static fn (array $input): string => $input['text'],
                $request->getInputs()
            ),
            'truncate' => $this->config->truncate,
            'encoding_format' => $this->config->encodingFormat,
        ];

        if ($this->config->inputType !== null) {
            $payload['input_type'] = $this->config->inputType;
        }

        $dimensions = $this->resolveDimensions($request);
        if ($dimensions !== null) {
            $payload['output_dimension'] = $dimensions;
        }

        $options = [
            'headers' => [
                'Authorization' => 'Bearer ' . $this->config->apiKey,
                'Content-Type' => 'application/json',
                'Accept' => 'application/json',
            ],
            'json' => $payload,
            'timeout' => $this->config->timeout,
        ];

        try {
            $response = $this->client->request('POST', $this->buildUrl(), $options);
        } catch (GuzzleException $exception) {
            throw new RuntimeException(
                'Voyage embeddings request failed: ' . $exception->getMessage(),
                (int) $exception->getCode(),
                $exception
            );
        }

        try {
            /** @var array<string, mixed> $data */
            $data = json_decode((string) $response->getBody(), true, flags: JSON_THROW_ON_ERROR);
        } catch (\JsonException $exception) {
            throw new RuntimeException(
                'Failed to decode Voyage embeddings response: ' . $exception->getMessage(),
                0,
                $exception
            );
        }

        $vectorsData = $this->extractVectors($data);
        if ($vectorsData === []) {
            throw new RuntimeException('Voyage embeddings response missing vectors payload.');
        }

        $vectors = [];
        $inputs = $request->getInputs();
        foreach ($vectorsData as $index => $values) {
            $normalized = $request->shouldNormalize()
                ? $this->normalizeVector($values)
                : $this->castToFloatList($values);

            $input = $inputs[$index] ?? ['id' => null, 'metadata' => null];
            $vectors[] = [
                'id' => $input['id'],
                'values' => $normalized,
                'metadata' => $input['metadata'] ?? null,
            ];
        }

        $dimensions = $vectors !== []
            ? count($vectors[0]['values'])
            : ($dimensions ?? $this->config->defaultDimensions ?? 0);

        $usage = isset($data['usage']) && is_array($data['usage'])
            ? $data['usage']
            : null;

        return [
            'provider' => $this->getProvider(),
            'model' => $this->config->model,
            'dimensions' => $dimensions,
            'vectors' => $vectors,
            'usage' => $usage,
        ];
    }

    private function resolveDimensions(EmbeddingRequest $request): ?int
    {
        if ($request->getDimensions() !== null) {
            return $request->getDimensions();
        }

        return $this->config->defaultDimensions;
    }

    private function buildUrl(): string
    {
        return rtrim($this->config->baseUri, '/') . '/' . ltrim($this->config->endpoint, '/');
    }

    /**
     * @param array<string, mixed> $payload
     * @return list<list<float|int|string>>
     */
    private function extractVectors(array $payload): array
    {
        $vectors = [];

        if (isset($payload['data']) && is_array($payload['data'])) {
            foreach ($payload['data'] as $entry) {
                if (isset($entry['embedding']) && is_array($entry['embedding'])) {
                    $vectors[] = $entry['embedding'];
                }
            }
        }

        if ($vectors === [] && isset($payload['embeddings']) && is_array($payload['embeddings'])) {
            foreach ($payload['embeddings'] as $embedding) {
                if (is_array($embedding)) {
                    $vectors[] = $embedding;
                }
            }
        }

        return $vectors;
    }

    /**
     * @param list<float|int|string> $values
     * @return list<float>
     */
    private function castToFloatList(array $values): array
    {
        $result = [];

        foreach ($values as $value) {
            if (!is_numeric($value)) {
                throw new RuntimeException('Voyage embeddings returned non-numeric vector values.');
            }

            $result[] = (float) $value;
        }

        return $result;
    }

    /**
     * @param list<float|int|string> $vector
     * @return list<float>
     */
    private function normalizeVector(array $vector): array
    {
        $values = $this->castToFloatList($vector);

        $norm = 0.0;
        foreach ($values as $value) {
            $norm += $value * $value;
        }
        $norm = sqrt($norm);

        if ($norm === 0.0) {
            return $values;
        }

        return array_map(
            static fn (float $value): float => $value / $norm,
            $values
        );
    }
}
</document_content>
</document>

<document index="43">
<source>src/Exception/ConfigurationException.php</source>
<document_content>
<?php

// this_file: paragra-php/src/Exception/ConfigurationException.php

declare(strict_types=1);

namespace ParaGra\Exception;

use RuntimeException;

/**
 * Thrown when required configuration is missing or invalid.
 *
 * This exception is thrown during initialization when environment variables
 * or configuration values are missing or invalid.
 *
 * @example
 * ```php
 * try {
 *     ConfigValidator::refinal quireEnv('RAGIE_API_KEY');
 * } catch (ConfigurationException $e) {
 *     echo "Configuration error: " . $e->getMessage();
 * }
 * ```
 */
class ConfigurationException extends RuntimeException
{
    /**
     * Create exception for missing required environment variable.
     *
     * @param string $varName Name of the missing environment variable
     */
    public static function missingEnv(string $varName): self
    {
        return new self(sprintf(
            'Required environment variable "%s" is not set',
            $varName
        ));
    }

    /**
     * Create exception for empty environment variable.
     *
     * @param string $varName Name of the empty environment variable
     */
    public static function emptyEnv(string $varName): self
    {
        return new self(sprintf(
            'Environment variable "%s" is set but empty',
            $varName
        ));
    }

    /**
     * Create exception for invalid configuration value.
     *
     * @param string $key Configuration key
     * @param string $reason Why the value is invalid
     * @api
     */
    public static function invalid(string $key, string $reason): self
    {
        return new self(sprintf(
            'Invalid configuration for "%s": %s',
            $key,
            $reason
        ));
    }
}
</document_content>
</document>

<document index="44">
<source>src/ExternalSearch/ExternalSearchException.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ExternalSearch/ExternalSearchException.php

namespace ParaGra\ExternalSearch;

use RuntimeException;

/**
 * Raised when an external search adapter (e.g. twat-search) fails to run
 * or returns malformed output.
 */
final class ExternalSearchException extends RuntimeException
{
}
</document_content>
</document>

<document index="45">
<source>src/ExternalSearch/ExternalSearchRetrieverInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ExternalSearch/ExternalSearchRetrieverInterface.php

namespace ParaGra\ExternalSearch;

use ParaGra\Response\UnifiedResponse;

/**
 * Contract for adapters that augment ParaGra with external web searches
 * (e.g., Brave, DuckDuckGo, or SerpAPI) to fill gaps when first-party
 * retrieval providers return no context.
 */
interface ExternalSearchRetrieverInterface
{
    /**
     * Machine-friendly provider slug such as "twat-search".
     */
    public function getProvider(): string;

    /**
     * Identifier of the upstream command or API powering the retriever.
     */
    public function getModel(): string;

    /**
     * Execute a search and return normalized chunks ready for prompt builders.
     *
     * @param array<string, mixed> $options Implementation-specific tuning knobs.
     */
    public function search(string $query, array $options = []): UnifiedResponse;
}
</document_content>
</document>

<document index="46">
<source>src/ExternalSearch/TwatSearchRetriever.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ExternalSearch/TwatSearchRetriever.php

namespace ParaGra\ExternalSearch;

use JsonException;
use ParaGra\Response\UnifiedResponse;
use Symfony\Component\Process\Process;

use function array_filter;
use function array_map;
use function array_shift;
use function array_unique;
use function array_values;
use function count;
use function explode;
use function implode;
use function is_array;
use function is_numeric;
use function is_string;
use function json_decode;
use function microtime;
use function round;
use function sha1;
use function sprintf;
use function str_replace;
use function strtolower;
use function strrpos;
use function strpos;
use function substr;
use function trim;
use function time;
use function usleep;

use const JSON_THROW_ON_ERROR;

/**
 * Executes the `twat-search` CLI (`twat-search web q --json ...`) to fetch rich
 * snippets from engines such as Brave or DuckDuckGo, then converts the results
 * into `UnifiedResponse` chunks that ParaGra can feed into prompt builders.
 */
final class TwatSearchRetriever implements ExternalSearchRetrieverInterface
{
    private const PROVIDER = 'twat-search';
    private const MODEL = 'twat-search-cli';
    private const DEFAULT_BINARY = 'twat-search';
    private const DEFAULT_TIMEOUT = 30.0;
    private const DEFAULT_MAX_ATTEMPTS = 2;
    private const DEFAULT_RETRY_DELAY_MS = 250;
    private const DEFAULT_CACHE_TTL = 120;
    private const DEFAULT_CACHE_LIMIT = 32;
    private const DEFAULT_NUM_RESULTS = 5;
    private const DEFAULT_MAX_RESULTS = 8;

    /**
     * @var array<string, array{
     *     chunks: list<array<string, mixed>>,
     *     metadata: array<string, mixed>,
     *     cached_at: int,
     *     expires_at: int
     * }>
     */
    private array $cache = [];

    /**
     * FIFO list of cache keys for eviction.
     *
     * @var list<string>
     */
    private array $cacheOrder = [];

    /**
     * @var callable|null
     */
    private readonly $processRunner;

    /**
     * @param list<string> $defaultEngines
     * @param array<string, string> $environment
     * @param callable|null $processRunner Custom runner hook for tests.
     */
    public function __construct(
        private readonly string $binary = self::DEFAULT_BINARY,
        private readonly array $defaultEngines = [],
        private readonly int $defaultNumResults = self::DEFAULT_NUM_RESULTS,
        private readonly int $defaultMaxResults = self::DEFAULT_MAX_RESULTS,
        private readonly int $maxAttempts = self::DEFAULT_MAX_ATTEMPTS,
        private readonly int $retryDelayMs = self::DEFAULT_RETRY_DELAY_MS,
        private readonly float $timeoutSeconds = self::DEFAULT_TIMEOUT,
        private readonly int $cacheTtlSeconds = self::DEFAULT_CACHE_TTL,
        private readonly int $cacheLimit = self::DEFAULT_CACHE_LIMIT,
        private readonly array $environment = [],
        ?callable $processRunner = null,
    ) {
        if ($this->maxAttempts < 1) {
            throw new ExternalSearchException('maxAttempts must be at least 1.');
        }

        if ($this->defaultNumResults < 1) {
            throw new ExternalSearchException('defaultNumResults must be positive.');
        }

        if ($this->defaultMaxResults < 1) {
            throw new ExternalSearchException('defaultMaxResults must be positive.');
        }

        if ($this->cacheLimit < 1) {
            throw new ExternalSearchException('cacheLimit must be at least 1 entry.');
        }

        $this->processRunner = $processRunner;
    }

    #[\Override]
    public function getProvider(): string
    {
        return self::PROVIDER;
    }

    #[\Override]
    public function getModel(): string
    {
        return self::MODEL;
    }

    /**
     * @param array<string, mixed> $options
     */
    #[\Override]
    public function search(string $query, array $options = []): UnifiedResponse
    {
        $cleanQuery = $this->sanitizeQuery($query);
        $engines = $this->resolveEngines($options['engines'] ?? null);
        $numResults = $this->resolveNumResults($options['num_results'] ?? $options['count'] ?? null);
        $maxResults = $this->resolveMaxResults($options['max_results'] ?? null);
        $allowCache = (bool) ($options['allow_cache'] ?? true);
        $cacheTtl = $this->resolveCacheTtl($options['cache_ttl'] ?? null);
        $timeout = $this->resolveTimeout($options['timeout'] ?? null);
        $environment = array_merge($this->environment, is_array($options['env'] ?? null) ? $options['env'] : []);
        $cacheKey = $this->buildCacheKey($cleanQuery, $engines, $numResults, $maxResults);

        if ($allowCache) {
            $cached = $this->readCache($cacheKey);
            if ($cached !== null) {
                return UnifiedResponse::fromChunks(
                    provider: $this->getProvider(),
                    model: $this->getModel(),
                    chunks: $cached['chunks'],
                    metadata: array_merge(
                        $cached['metadata'],
                        [
                            'cache_hit' => true,
                            'cached_at' => $cached['cached_at'],
                        ]
                    )
                );
            }
        }

        $attempt = 0;
        $lastError = null;

        while ($attempt < $this->maxAttempts) {
            $attempt++;
            $start = microtime(true);

            try {
                $rawResults = $this->runQuery($cleanQuery, $engines, $numResults, $timeout, $environment);
                $chunks = $this->normalizeChunks($rawResults, $maxResults);

                $metadata = [
                    'binary' => $this->binary,
                    'engines' => $engines,
                    'num_results' => $numResults,
                    'max_results' => $maxResults,
                    'result_count' => count($chunks),
                    'retry_count' => $attempt,
                    'duration_ms' => (int) round((microtime(true) - $start) * 1000),
                    'cache_hit' => false,
                ];

                if ($allowCache) {
                    $this->storeCache($cacheKey, $chunks, $metadata, $cacheTtl);
                }

                return UnifiedResponse::fromChunks(
                    provider: $this->getProvider(),
                    model: $this->getModel(),
                    chunks: $chunks,
                    metadata: $metadata,
                );
            } catch (ExternalSearchException $exception) {
                $lastError = $exception;
                if ($attempt >= $this->maxAttempts) {
                    throw $exception;
                }

                usleep($this->retryDelayMs * 1000 * $attempt);
            }
        }

        throw $lastError ?? new ExternalSearchException('twat-search failed unexpectedly.');
    }

    /**
     * @param list<string> $engines
     * @param array<string, string> $environment
     *
     * @return list<array<string, mixed>>
     */
    private function runQuery(
        string $query,
        array $engines,
        int $numResults,
        float $timeout,
        array $environment
    ): array {
        $command = $this->buildCommand($query, $engines, $numResults);
        $result = $this->executeProcess($command, $environment, $timeout);

        if ($result['exit_code'] !== 0) {
            $stderr = trim($result['stderr']);
            $hint = $stderr !== '' ? $stderr : 'unknown error';

            throw new ExternalSearchException(sprintf(
                'twat-search exited with code %d: %s',
                $result['exit_code'],
                $hint
            ));
        }

        $payload = $this->extractJsonPayload($result['stdout']);

        try {
            $decoded = json_decode($payload, true, 512, JSON_THROW_ON_ERROR);
        } catch (JsonException $exception) {
            throw new ExternalSearchException(
                'Unable to decode twat-search JSON output: ' . $exception->getMessage(),
                0,
                $exception
            );
        }

        if (!is_array($decoded)) {
            throw new ExternalSearchException('twat-search JSON response must be an array.');
        }

        /** @var list<array<string, mixed>> $results */
        $results = array_values(array_filter(
            $decoded,
            static fn(mixed $value): bool => is_array($value)
        ));

        return $results;
    }

    /**
     * @param list<string> $engines
     *
     * @return list<string>
     */
    private function normalizeEngines(array $engines): array
    {
        $normalized = array_map(
            static fn(string $engine): string => strtolower(trim($engine)),
            $engines
        );

        return array_values(array_filter(
            array_unique($normalized),
            static fn(string $engine): bool => $engine !== ''
        ));
    }

    /**
     * @return list<string>
     */
    private function resolveEngines(mixed $engines): array
    {
        if (is_string($engines)) {
            $candidates = explode(',', str_replace(' ', '', $engines));
            return $this->normalizeEngines($candidates);
        }

        if (is_array($engines)) {
            return $this->normalizeEngines(array_map(
                static fn(mixed $value): string => (string) $value,
                $engines
            ));
        }

        return $this->normalizeEngines($this->defaultEngines);
    }

    private function resolveNumResults(mixed $candidate): int
    {
        $value = (int) ($candidate ?? $this->defaultNumResults);

        return $value > 0 ? $value : $this->defaultNumResults;
    }

    private function resolveMaxResults(mixed $candidate): int
    {
        $value = (int) ($candidate ?? $this->defaultMaxResults);

        return $value > 0 ? $value : $this->defaultMaxResults;
    }

    private function resolveCacheTtl(mixed $candidate): int
    {
        $value = (int) ($candidate ?? $this->cacheTtlSeconds);

        return $value > 0 ? $value : $this->cacheTtlSeconds;
    }

    private function resolveTimeout(mixed $candidate): float
    {
        $value = (float) ($candidate ?? $this->timeoutSeconds);

        return $value > 0 ? $value : $this->timeoutSeconds;
    }

    /**
     * @param list<string> $command
     * @param array<string, string> $environment
     *
     * @return array{exit_code: int, stdout: string, stderr: string}
     */
    private function executeProcess(array $command, array $environment, float $timeout): array
    {
        if ($this->processRunner !== null) {
            $result = ($this->processRunner)($command, $environment, $timeout);

            return [
                'exit_code' => (int) ($result['exit_code'] ?? 1),
                'stdout' => (string) ($result['stdout'] ?? ''),
                'stderr' => (string) ($result['stderr'] ?? ''),
            ];
        }

        $process = new Process($command, null, $environment, null, $timeout);
        $process->run();

        return [
            'exit_code' => $process->getExitCode() ?? 1,
            'stdout' => $process->getOutput(),
            'stderr' => $process->getErrorOutput(),
        ];
    }

    /**
     * @param list<string> $engines
     *
     * @return list<string>
     */
    private function buildCommand(string $query, array $engines, int $numResults): array
    {
        $command = [$this->binary, 'web', 'q', $query, '--json'];

        if ($engines !== []) {
            $command[] = '-e';
            $command[] = implode(',', $engines);
        }

        $command[] = '--num_results';
        $command[] = (string) $numResults;

        return $command;
    }

    private function extractJsonPayload(string $stdout): string
    {
        $trimmed = trim($stdout);
        if ($trimmed === '') {
            throw new ExternalSearchException('twat-search returned empty output.');
        }

        if ($trimmed[0] === '[') {
            return $trimmed;
        }

        $start = strpos($trimmed, '[');
        $end = strrpos($trimmed, ']');

        if ($start === false || $end === false || $end <= $start) {
            throw new ExternalSearchException('Failed to locate JSON array in twat-search output.');
        }

        return substr($trimmed, (int) $start, (int) ($end - $start + 1));
    }

    /**
     * @param list<array<string, mixed>> $results
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeChunks(array $results, int $maxResults): array
    {
        $chunks = [];

        foreach ($results as $result) {
            $title = $this->stringOrNull($result['title'] ?? null);
            $snippet = $this->stringOrNull($result['snippet'] ?? null);
            $url = $this->stringOrNull($result['url'] ?? null);

            $textParts = array_filter([$title, $snippet], static fn(?string $value): bool => $value !== null && $value !== '');
            $text = trim(implode("\n\n", $textParts));

            if ($text === '') {
                continue;
            }

            $chunk = [
                'text' => $text,
            ];

            $score = $result['score'] ?? null;
            if (is_numeric($score)) {
                $chunk['score'] = (float) $score;
            }

            if ($url !== null) {
                $chunk['document_id'] = $url;
            }

            if ($title !== null) {
                $chunk['document_name'] = $title;
            }

            $metadata = [
                'engine' => $this->stringOrNull($result['source_engine'] ?? null),
                'url' => $url,
                'title' => $title,
                'snippet' => $snippet,
                'position' => isset($result['position']) && is_numeric($result['position'])
                    ? (int) $result['position']
                    : null,
                'timestamp' => $this->stringOrNull($result['timestamp'] ?? null),
            ];

            if (isset($result['extra_info']) && is_array($result['extra_info']) && $result['extra_info'] !== []) {
                $metadata['extra_info'] = $result['extra_info'];
            }

            if (isset($result['raw']) && is_array($result['raw']) && $result['raw'] !== []) {
                $metadata['raw'] = $result['raw'];
            }

            $metadata = array_filter(
                $metadata,
                static fn(mixed $value): bool => $value !== null && $value !== []
            );

            if ($metadata !== []) {
                $chunk['metadata'] = $metadata;
            }

            $chunks[] = $chunk;

            if (count($chunks) >= $maxResults) {
                break;
            }
        }

        return $chunks;
    }

    private function sanitizeQuery(string $query): string
    {
        $clean = trim($query);
        if ($clean === '') {
            throw new ExternalSearchException('Query cannot be empty.');
        }

        return $clean;
    }

    /**
     * @return array{
     *     chunks: list<array<string, mixed>>,
     *     metadata: array<string, mixed>,
     *     cached_at: int,
     *     expires_at: int
     * }|null
     */
    private function readCache(string $key): ?array
    {
        if (!isset($this->cache[$key])) {
            return null;
        }

        $entry = $this->cache[$key];
        if ($entry['expires_at'] < time()) {
            unset($this->cache[$key]);

            return null;
        }

        return $entry;
    }

    /**
     * @param list<array<string, mixed>> $chunks
     * @param array<string, mixed> $metadata
     */
    private function storeCache(string $key, array $chunks, array $metadata, int $cacheTtl): void
    {
        $now = time();

        $this->cache[$key] = [
            'chunks' => $chunks,
            'metadata' => $metadata,
            'cached_at' => $now,
            'expires_at' => $now + $cacheTtl,
        ];

        $this->cacheOrder[] = $key;

        if (count($this->cacheOrder) > $this->cacheLimit) {
            $evictedKey = array_shift($this->cacheOrder);
            if ($evictedKey !== null && $evictedKey !== $key) {
                unset($this->cache[$evictedKey]);
            }
        }
    }

    /**
     * @param list<string> $engines
     */
    private function buildCacheKey(string $query, array $engines, int $numResults, int $maxResults): string
    {
        $normalized = strtolower(trim($query));

        return sha1($normalized . '|' . implode(',', $engines) . '|' . $numResults . '|' . $maxResults);
    }

    private function stringOrNull(mixed $value): ?string
    {
        if (!is_string($value)) {
            return null;
        }

        $clean = trim($value);

        return $clean === '' ? null : $clean;
    }
}
</document_content>
</document>

<document index="47">
<source>src/Llm/AskYodaClient.php</source>
<document_content>
<?php

// this_file: paragra-php/src/Llm/AskYodaClient.php

declare(strict_types=1);

namespace ParaGra\Llm;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\Exception\GuzzleException;

/**
 * EdenAI AskYoda RAG Client
 *
 * Provides RAG functionality through EdenAI's AskYoda service.
 * Used as a fallback when Ragie API rate limits are exceeded.
 */
class AskYodaClient
{
    private const BASE_URL = 'https://api.edenai.run/v2/aiproducts/askyoda/v2';

    private HttpClient $httpClient;

    public function __construct(
        private readonly string $apiKey,
        private readonly string $projectId,
        private readonly string $llmProvider = 'google',
        private readonly string $llmModel = 'gemini-2.0-flash-exp',
        ?HttpClient $httpClient = null
    ) {
        $this->httpClient = $httpClient ?? new HttpClient([
            'timeout' => 30,
            'http_errors' => true,
        ]);
    }

    /**
     * Ask a question using AskYoda RAG
     *
     * @param string $query The question to ask
     * @param int $k Number of chunks to retrieve (default: 10)
     * @param float $minScore Minimum relevance score (0.0-1.0, default: 0.3)
     * @param float $temperature LLM temperature (0.0-2.0, default: 0.99)
     * @param int $maxTokens Maximum tokens in response (default: 8000)
     * @throws \RuntimeException On API errors
     * @return AskYodaResponse
     */
    public function ask(
        string $query,
        int $k = 10,
        float $minScore = 0.3,
        float $temperature = 0.99,
        int $maxTokens = 8000
    ): AskYodaResponse {
        $url = sprintf('%s/%s/ask_llm/', self::BASE_URL, $this->projectId);

        $payload = [
            'k' => $k,
            'min_score' => $minScore,
            'temperature' => $temperature,
            'max_tokens' => $maxTokens,
            'query' => $query,
            'llm_provider' => $this->llmProvider,
            'llm_model' => $this->llmModel,
        ];

        try {
            $response = $this->httpClient->request('POST', $url, [
                'json' => $payload,
                'headers' => [
                    'accept' => 'application/json',
                    'authorization' => 'Bearer ' . $this->apiKey,
                    'content-type' => 'application/json',
                ],
            ]);

            $body = (string) $response->getBody();
            $data = json_decode($body, true);

            if (json_last_error() !== JSON_ERROR_NONE) {
                throw new \RuntimeException('Failed to decode AskYoda response: ' . json_last_error_msg());
            }

            return new AskYodaResponse($data);
        } catch (GuzzleException $e) {
            throw new \RuntimeException('AskYoda API request failed: ' . $e->getMessage(), 0, $e);
        }
    }

    /**
     * Create AskYoda client from environment variables
     *
     * Required environment variables:
     * - EDENAI_API_KEY
     * - EDENAI_ASKYODA_PROJECT
     *
     * Optional environment variables:
     * - EDENAI_LLM_PROVIDER (default: google)
     * - EDENAI_LLM_MODEL (default: gemini-2.0-flash-exp)
     */
    public static function fromEnv(): self
    {
        $apiKey = getenv('EDENAI_API_KEY');
        if ($apiKey === false || $apiKey === '') {
            throw new \RuntimeException('EDENAI_API_KEY environment variable is required');
        }

        $projectId = getenv('EDENAI_ASKYODA_PROJECT');
        if ($projectId === false || $projectId === '') {
            throw new \RuntimeException('EDENAI_ASKYODA_PROJECT environment variable is required');
        }

        $llmProvider = getenv('EDENAI_LLM_PROVIDER') ?: 'google';
        $llmModel = getenv('EDENAI_LLM_MODEL') ?: 'gemini-2.0-flash-exp';

        return new self($apiKey, $projectId, $llmProvider, $llmModel);
    }
}
</document_content>
</document>

<document index="48">
<source>src/Llm/AskYodaResponse.php</source>
<document_content>
<?php

// this_file: paragra-php/src/Llm/AskYodaResponse.php

declare(strict_types=1);

namespace ParaGra\Llm;

/**
 * Response from EdenAI AskYoda API
 */
class AskYodaResponse
{
    private float $cost;
    private string $result;
    private string $llmProvider;
    private string $llmModel;
    /** @var array<string, mixed> */
    private array $usage;
    /** @var array<int, string> */
    private array $chunkIds;

    /**
     * @param array<string, mixed> $data
     */
    public function __construct(array $data)
    {
        $this->cost = (float) ($data['cost'] ?? 0.0);
        $this->result = (string) ($data['result'] ?? '');
        $this->llmProvider = (string) ($data['llm_provider'] ?? '');
        $this->llmModel = (string) ($data['llm_model'] ?? '');
        $this->usage = $data['usage'] ?? [];
        $this->chunkIds = $data['chunks_ids'] ?? [];
    }

    public function getCost(): float
    {
        return $this->cost;
    }

    public function getResult(): string
    {
        return $this->result;
    }

    public function getLlmProvider(): string
    {
        return $this->llmProvider;
    }

    public function getLlmModel(): string
    {
        return $this->llmModel;
    }

    /**
     * @return array<string, mixed>
     */
    public function getUsage(): array
    {
        return $this->usage;
    }

    public function getInputTokens(): int
    {
        return (int) ($this->usage['input_tokens'] ?? 0);
    }

    public function getOutputTokens(): int
    {
        return (int) ($this->usage['output_tokens'] ?? 0);
    }

    public function getTotalTokens(): int
    {
        return (int) ($this->usage['total_tokens'] ?? 0);
    }

    /**
     * @return array<int, string>
     */
    public function getChunkIds(): array
    {
        return $this->chunkIds;
    }

    public function getChunkCount(): int
    {
        return count($this->chunkIds);
    }

    /**
     * Convert to array format compatible with RAG endpoint response
     *
     * @return array<string, mixed>
     */
    public function toArray(): array
    {
        return [
            'answer' => $this->result,
            'cost' => $this->cost,
            'llm_provider' => $this->llmProvider,
            'llm_model' => $this->llmModel,
            'usage' => $this->usage,
            'chunks_count' => $this->getChunkCount(),
            'chunk_ids' => $this->chunkIds,
        ];
    }
}
</document_content>
</document>

<document index="49">
<source>src/Llm/ChatRequestOptions.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/ChatRequestOptions.php

namespace ParaGra\Llm;

final class ChatRequestOptions
{
    public function __construct(
        public ?string $model = null,
        public ?float $temperature = null,
        public ?float $topP = null,
        public ?int $maxTokens = null
    ) {
    }
}
</document_content>
</document>

<document index="50">
<source>src/Llm/ChatResponse.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/ChatResponse.php

namespace ParaGra\Llm;

final class ChatResponse
{
    public function __construct(
        private string $text,
        private ChatUsage $usage,
        private mixed $rawResponse
    ) {
    }

    public function getText(): string
    {
        return $this->text;
    }

    public function getUsage(): ChatUsage
    {
        return $this->usage;
    }

    /**
     * @api
     */
    public function getRawResponse(): mixed
    {
        return $this->rawResponse;
    }
}
</document_content>
</document>

<document index="51">
<source>src/Llm/ChatUsage.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/ChatUsage.php

namespace ParaGra\Llm;

final class ChatUsage
{
    public function __construct(
        public int $promptTokens,
        public int $completionTokens,
        public int $totalTokens
    ) {
    }
}
</document_content>
</document>

<document index="52">
<source>src/Llm/NeuronAiAdapter.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/NeuronAiAdapter.php

namespace ParaGra\Llm;

use InvalidArgumentException;
use NeuronAI\Chat\Messages\Message;
use NeuronAI\Chat\Messages\UserMessage;
use NeuronAI\Providers\AIProviderInterface;
use NeuronAI\Providers\Anthropic\Anthropic;
use NeuronAI\Providers\Deepseek\Deepseek;
use NeuronAI\Providers\Gemini\Gemini;
use NeuronAI\Providers\Mistral\Mistral;
use NeuronAI\Providers\OpenAI\OpenAI;
use NeuronAI\Providers\OpenAILike;
use NeuronAI\Providers\XAI\Grok;

use function array_replace;
use function is_array;
use function is_callable;
use function sprintf;
use function strtolower;

/**
 * Thin wrapper around neuron-ai providers that exposes a simplified generate() API.
 */
final class NeuronAiAdapter
{
    public function __construct(
        private readonly string $provider,
        private readonly string $model,
        private readonly string $apiKey,
        private readonly array $parameters = [],
        private readonly ?string $systemPrompt = null,
        private readonly mixed $providerFactory = null,
    ) {
    }

    /**
     * @param array<string, mixed> $options
     */
    public function generate(string $prompt, array $options = []): string
    {
        $provider = $this->resolveProvider($options);
        $systemPrompt = $options['system_prompt'] ?? $this->systemPrompt;
        $provider->systemPrompt($systemPrompt);

        /** @var Message $response */
        $response = $provider->chat([new UserMessage($prompt)]);
        $content = $response->getContent();

        if (is_array($content)) {
            $content = $content[0] ?? '';
        }

        return (string) $content;
    }

    /**
     * @param array<string, mixed> $options
     */
    private function resolveProvider(array $options): AIProviderInterface
    {
        if (is_callable($this->providerFactory)) {
            return ($this->providerFactory)(
                $this->provider,
                $this->model,
                $this->apiKey,
                $this->parameters,
                $options
            );
        }

        $parameters = array_replace(
            $this->parameters,
            $options['parameters'] ?? [],
            $this->extractScalarOverrides($options)
        );

        return match (strtolower($this->provider)) {
            'openai' => new OpenAI($this->apiKey, $this->model, $parameters),
            'anthropic' => $this->createAnthropicProvider($parameters),
            'gemini' => new Gemini($this->apiKey, $this->model, $parameters),
            'mistral' => new Mistral($this->apiKey, $this->model, $parameters),
            'xai' => new Grok($this->apiKey, $this->model, $parameters),
            'deepseek' => new Deepseek($this->apiKey, $this->model, $parameters),
            'cerebras' => $this->createOpenAiLike('https://api.cerebras.ai/v1/', $parameters),
            'groq' => $this->createOpenAiLike('https://api.groq.com/openai/v1/', $parameters),
            default => throw new InvalidArgumentException(sprintf('Unsupported LLM provider "%s".', $this->provider)),
        };
    }

    /**
     * @param array<string, mixed> $options
     *
     * @return array<string, mixed>
     */
    private function extractScalarOverrides(array $options): array
    {
        $overrides = [];

        if (isset($options['temperature'])) {
            $overrides['temperature'] = (float) $options['temperature'];
        }

        if (isset($options['max_tokens'])) {
            $overrides['max_tokens'] = (int) $options['max_tokens'];
        }

        return $overrides;
    }

    /**
     * @param array<string, mixed> $parameters
     */
    private function createOpenAiLike(string $baseUri, array $parameters): OpenAILike
    {
        return new OpenAILike(
            $baseUri,
            $this->apiKey,
            $this->model,
            $parameters
        );
    }

    /**
     * @param array<string, mixed> $parameters
     */
    private function createAnthropicProvider(array $parameters): Anthropic
    {
        $anthropicParameters = $parameters;
        $version = (string) ($anthropicParameters['anthropic_version'] ?? '2023-06-01');
        unset($anthropicParameters['anthropic_version']);

        $maxTokens = (int) ($anthropicParameters['max_tokens'] ?? 8192);

        return new Anthropic(
            $this->apiKey,
            $this->model,
            $version,
            $maxTokens,
            $anthropicParameters
        );
    }
}
</document_content>
</document>

<document index="53">
<source>src/Llm/OpenAiChatClient.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/OpenAiChatClient.php

namespace ParaGra\Llm;

use OpenAI\Contracts\ClientContract as OpenAiClient;
use OpenAI\Contracts\Resources\ChatContract as OpenAiChatResource;
use RuntimeException;

final class OpenAiChatClient
{
    private OpenAiChatConfig $config;

    private OpenAiClient $client;

    public function __construct(OpenAiChatConfig $config, ?OpenAiClient $client = null)
    {
        $this->config = $config;
        $this->client = $client ?? $this->createClient($config);
    }

    public function generateText(string $prompt, ?ChatRequestOptions $options = null): ChatResponse
    {
        $messages = [
            ['role' => 'user', 'content' => $prompt],
        ];

        return $this->generateMessages($messages, $options);
    }

    /**
     * @param array<int, array{role: string, content: string}> $messages
     */
    public function generateMessages(array $messages, ?ChatRequestOptions $options = null): ChatResponse
    {
        $payload = $this->buildPayload($messages, $options);

        try {
            $response = $this->chatResource()->create($payload);
        } catch (\Throwable $e) {
            throw new RuntimeException('Failed to request chat completion: ' . $e->getMessage(), (int) $e->getCode(), $e);
        }

        $text = $response->choices[0]->message->content ?? '';
        $usage = $response->usage;

        $chatUsage = new ChatUsage(
            promptTokens: $usage?->promptTokens ?? 0,
            completionTokens: $usage?->completionTokens ?? 0,
            totalTokens: $usage?->totalTokens ?? 0
        );

        return new ChatResponse($text, $chatUsage, $response);
    }

    /**
     * @param array<int, array{role: string, content: string}> $messages
     * @return array<string, mixed>
     */
    private function buildPayload(array $messages, ?ChatRequestOptions $options): array
    {
        $temperature = $options?->temperature ?? $this->config->defaultTemperature;
        $topP = $options?->topP ?? $this->config->defaultTopP;
        $maxTokens = $options?->maxTokens ?? $this->config->defaultMaxTokens;

        $payload = [
            'model' => $options?->model ?? $this->config->model,
            'messages' => $messages,
            'temperature' => $temperature,
            'top_p' => $topP,
        ];

        if ($maxTokens !== null) {
            $payload['max_tokens'] = $maxTokens;
        }

        return $payload;
    }

    private function createClient(OpenAiChatConfig $config): OpenAiClient
    {
        $factory = \OpenAI::factory()->withApiKey($config->apiKey);

        if ($config->baseUrl) {
            $factory = $factory->withBaseUri($config->baseUrl);
        }

        return $factory->make();
    }

    private function chatResource(): OpenAiChatResource
    {
        return $this->client->chat();
    }
}
</document_content>
</document>

<document index="54">
<source>src/Llm/OpenAiChatConfig.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/OpenAiChatConfig.php

namespace ParaGra\Llm;

use ParaGra\Util\ConfigValidator;

final class OpenAiChatConfig
{
    public function __construct(
        public string $apiKey,
        public string $model,
        public ?string $baseUrl = null,
        public float $defaultTemperature = 0.7,
        public float $defaultTopP = 1.0,
        public ?int $defaultMaxTokens = null
    ) {
    }

    /**
     * Create configuration from environment variables
     *
     * Required environment variables:
     * - OPENAI_API_KEY
     *
     * Optional environment variables:
     * - OPENAI_BASE_URL (default: null, uses OpenAI's default)
     * - OPENAI_API_MODEL (default: gpt-4o-mini)
     * - OPENAI_API_TEMPERATURE (default: 0.7)
     * - OPENAI_API_TOP_P (default: 1.0)
     * - OPENAI_API_MAX_OUT (default: null, no limit)
     *
     * @throws \ParaGra\Exception\ConfigurationException if required env vars missing
     */
    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::requireEnv('OPENAI_API_KEY');
        $model = ConfigValidator::getEnv('OPENAI_API_MODEL', 'gpt-4o-mini');
        $baseUrlStr = ConfigValidator::getEnv('OPENAI_BASE_URL', '');
        $baseUrl = $baseUrlStr !== '' ? $baseUrlStr : null;

        // Parse numeric config with fallbacks
        $temperature = (float) ConfigValidator::getEnv('OPENAI_API_TEMPERATURE', '0.7');
        $topP = (float) ConfigValidator::getEnv('OPENAI_API_TOP_P', '1.0');
        $maxTokensStr = ConfigValidator::getEnv('OPENAI_API_MAX_OUT', '0');
        $maxTokens = ($max = (int) $maxTokensStr) > 0 ? $max : null;

        return new self(
            apiKey: $apiKey,
            model: $model,
            baseUrl: $baseUrl,
            defaultTemperature: $temperature,
            defaultTopP: $topP,
            defaultMaxTokens: $maxTokens,
        );
    }
}
</document_content>
</document>

<document index="55">
<source>src/Llm/PromptBuilder.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Llm/PromptBuilder.php

namespace ParaGra\Llm;

final class PromptBuilder
{
    public const DEFAULT_TEMPLATE = <<<'PROMPT'
You are a helpful AI assistant. Answer the user's question based on the context provided below.

CONTEXT:
{{context}}

QUESTION:
{{question}}

Provide a clear, concise answer based on the context. If the context doesn't contain relevant information, say so.
PROMPT;

    private string $template;

    public function __construct(?string $template = null)
    {
        $this->template = $template ?? self::DEFAULT_TEMPLATE;
    }

    /**
     * @param string[] $contextChunks
     */
    public function build(string $question, array $contextChunks): string
    {
        $context = trim(implode("\n\n", array_filter($contextChunks, static fn (string $chunk): bool => $chunk !== '')));

        return str_replace(
            ['{{question}}', '{{context}}'],
            [$question, $context],
            $this->template
        );
    }
}
</document_content>
</document>

<document index="56">
<source>src/Media/ChutesImageProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/ChutesImageProvider.php

namespace ParaGra\Media;

use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use JsonException;
use Psr\Http\Message\ResponseInterface;

use function array_flip;
use function array_intersect_key;
use function array_key_exists;
use function array_merge;
use function array_replace;
use function base64_encode;
use function json_decode;
use function max;
use function min;
use function microtime;
use function rtrim;
use function round;
use function str_contains;
use function is_array;
use function is_string;
use function trim;
use function usleep;

use const JSON_THROW_ON_ERROR;

/**
 * Executes Chutes image jobs by POSTing JSON payloads to a chute endpoint.
 *
 * The official docs (`chutes.ai/docs/examples/image-generation`) describe a
 * `/generate` endpoint that returns either JSON metadata or the binary image.
 * This adapter normalizes both shapes into a MediaResult so ParaGra callers
 * can immediately embed URLs/base64 responses inside their experiences.
 */
final class ChutesImageProvider implements ImageOperationInterface
{
    /**
     * @param array{
     *     endpoint?: string,
     *     default_width?: int,
     *     default_height?: int,
     *     num_inference_steps?: int,
     *     guidance_scale?: float,
     *     max_images?: int,
     *     max_retries?: int,
     *     retry_delay_ms?: int,
     *     provider_label?: string
     * } $defaults
     */
    public function __construct(
        private readonly ClientInterface $http,
        private readonly string $baseUrl,
        private readonly string $apiKey,
        private readonly array $defaults = [],
    ) {
    }

    #[\Override]
    public function generate(MediaRequest $request, array $options = []): MediaResult
    {
        $settings = $this->resolveSettings($options);
        $dimensions = $request->resolveDimensions($settings['default_width'], $settings['default_height']);
        $payloadOverrides = $options['payload'] ?? [];
        if ($payloadOverrides !== [] && !is_array($payloadOverrides)) {
            throw new MediaException('Chutes payload overrides must be an array.');
        }

        $payload = $this->buildPayload($request, $settings, $dimensions, $payloadOverrides);
        $url = $this->buildUrl($settings['endpoint']);
        $attempt = 0;
        $start = microtime(true);

        do {
            try {
                $response = $this->http->request('POST', $url, [
                    'headers' => [
                        'Authorization' => 'Bearer ' . $this->apiKey,
                        'Content-Type' => 'application/json',
                        'Accept' => 'application/json',
                    ],
                    'json' => $payload,
                    'timeout' => $options['timeout'] ?? 60,
                ]);

                if ($response->getStatusCode() >= 500 && $attempt < $settings['max_retries']) {
                    $this->delay($settings['retry_delay_ms']);
                    ++$attempt;
                    continue;
                }

                return $this->normalizeResponse(
                    $response,
                    $request,
                    $dimensions,
                    $settings,
                    $attempt,
                    $start,
                );
            } catch (GuzzleException $exception) {
                if ($attempt >= $settings['max_retries']) {
                    throw new MediaException('Chutes image request failed: ' . $exception->getMessage(), 0, $exception);
                }

                $this->delay($settings['retry_delay_ms']);
            }

            ++$attempt;
        } while ($attempt <= $settings['max_retries']);

        throw new MediaException('Chutes image request exhausted retries.');
    }

    /**
     * @param array{width:int,height:int} $dimensions
     * @param array{endpoint:string,default_width:int,default_height:int,num_inference_steps:int,guidance_scale:float,max_images:int,max_retries:int,retry_delay_ms:int,provider_label:string} $settings
     */
    private function normalizeResponse(
        ResponseInterface $response,
        MediaRequest $request,
        array $dimensions,
        array $settings,
        int $attempt,
        float $startTime,
    ): MediaResult {
        $durationMs = (int) max(1, round((microtime(true) - $startTime) * 1000));
        $contentType = trim($response->getHeaderLine('Content-Type'));
        $metadata = [
            'endpoint' => $settings['endpoint'],
            'duration_ms' => $durationMs,
            'attempts' => $attempt + 1,
        ];

        if ($contentType !== '' && str_contains($contentType, 'json')) {
            $body = (string) $response->getBody();
            try {
                /** @var array<string, mixed> $payload */
                $payload = json_decode($body, true, 512, JSON_THROW_ON_ERROR);
            } catch (JsonException $exception) {
                throw new MediaException('Chutes JSON response could not be decoded.', 0, $exception);
            }

            $artifacts = $this->extractJsonArtifacts($payload);
            $metadata = array_merge(
                $payload['metadata'] ?? [],
                $metadata,
                [
                    'job_id' => $payload['job_id'] ?? null,
                    'duration_ms' => $payload['duration_ms'] ?? $durationMs,
                ]
            );

            return new MediaResult(
                provider: $settings['provider_label'],
                model: $settings['model'] ?? 'image',
                artifacts: $artifacts,
                metadata: $metadata,
            );
        }

        $artifact = [
            'base64' => base64_encode((string) $response->getBody()),
            'mime_type' => $contentType !== '' ? $contentType : 'image/png',
            'width' => $dimensions['width'],
            'height' => $dimensions['height'],
            'metadata' => ['binary_response' => true],
        ];

        if ($request->getMetadata() !== []) {
            $artifact['metadata'] = array_merge($request->getMetadata(), $artifact['metadata']);
        }

        return new MediaResult(
            provider: $settings['provider_label'],
            model: $settings['model'] ?? 'image',
            artifacts: [$artifact],
            metadata: $metadata,
        );
    }

    /**
     * @return list<array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }>
     */
    private function extractJsonArtifacts(array $payload): array
    {
        $images = $payload['images'] ?? $payload['result']['images'] ?? null;
        if (!is_array($images) || $images === []) {
            throw new MediaException('Chutes response missing image entries.');
        }

        $artifacts = [];
        foreach ($images as $entry) {
            if (!is_array($entry)) {
                continue;
            }

            $artifact = [];
            if (array_key_exists('url', $entry) && is_string($entry['url'])) {
                $artifact['url'] = $entry['url'];
            }

            if (array_key_exists('b64_json', $entry) && is_string($entry['b64_json'])) {
                $artifact['base64'] = $entry['b64_json'];
            }

            if (array_key_exists('mime_type', $entry) && is_string($entry['mime_type'])) {
                $artifact['mime_type'] = $entry['mime_type'];
            }

            if (array_key_exists('width', $entry)) {
                $artifact['width'] = (int) $entry['width'];
            }

            if (array_key_exists('height', $entry)) {
                $artifact['height'] = (int) $entry['height'];
            }

            if (array_key_exists('bytes', $entry)) {
                $artifact['bytes'] = (int) $entry['bytes'];
            }

            if (array_key_exists('metadata', $entry) && is_array($entry['metadata'])) {
                $artifact['metadata'] = $entry['metadata'];
            }

            if ($artifact === []) {
                continue;
            }

            $artifacts[] = $artifact;
        }

        if ($artifacts === []) {
            throw new MediaException('Chutes response returned no valid image payloads.');
        }

        return $artifacts;
    }

    /**
     * @param array{width:int,height:int} $dimensions
     * @param array<string, mixed> $payloadOverrides
     *
     * @return array<string, mixed>
     */
    private function buildPayload(
        MediaRequest $request,
        array $settings,
        array $dimensions,
        array $payloadOverrides
    ): array {
        $payload = [
            'prompt' => $request->getPrompt(),
            'width' => $dimensions['width'],
            'height' => $dimensions['height'],
            'num_inference_steps' => $settings['num_inference_steps'],
            'guidance_scale' => $settings['guidance_scale'],
            'images' => max(1, min($settings['max_images'], $request->getImageCount())),
        ];

        if ($request->getNegativePrompt() !== null && $request->getNegativePrompt() !== '') {
            $payload['negative_prompt'] = $request->getNegativePrompt();
        }

        if ($request->getSeed() !== null) {
            $payload['seed'] = $request->getSeed();
        }

        if ($request->getMetadata() !== []) {
            $payload['metadata'] = $request->getMetadata();
        }

        if (isset($settings['model'])) {
            $payload['model'] = $settings['model'];
        }

        if ($payloadOverrides !== []) {
            $payload = array_replace($payload, $payloadOverrides);
        }

        return $payload;
    }

    /**
     * @param array<string, mixed> $options
     *
     * @return array{endpoint:string,default_width:int,default_height:int,num_inference_steps:int,guidance_scale:float,max_images:int,max_retries:int,retry_delay_ms:int,provider_label:string,model?:string}
     */
    private function resolveSettings(array $options): array
    {
        $defaults = array_merge([
            'endpoint' => '/generate',
            'default_width' => 1024,
            'default_height' => 1024,
            'num_inference_steps' => 28,
            'guidance_scale' => 7.5,
            'max_images' => 4,
            'max_retries' => 2,
            'retry_delay_ms' => 200,
            'provider_label' => 'chutes',
        ], $this->defaults);

        $overrides = array_intersect_key(
            $options,
            array_flip([
                'endpoint',
                'default_width',
                'default_height',
                'num_inference_steps',
                'guidance_scale',
                'max_images',
                'max_retries',
                'retry_delay_ms',
                'provider_label',
                'model',
            ])
        );

        /** @var array{endpoint:string,default_width:int,default_height:int,num_inference_steps:int,guidance_scale:float,max_images:int,max_retries:int,retry_delay_ms:int,provider_label:string,model?:string} $settings */
        $settings = array_merge($defaults, $overrides);

        return $settings;
    }

    private function buildUrl(string $endpoint): string
    {
        $base = rtrim($this->baseUrl, '/');
        $path = '/' . ltrim($endpoint, '/');

        return $base . $path;
    }

    private function delay(int $milliseconds): void
    {
        if ($milliseconds <= 0) {
            return;
        }

        usleep($milliseconds * 1000);
    }
}
</document_content>
</document>

<document index="57">
<source>src/Media/FalImageProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/FalImageProvider.php

namespace ParaGra\Media;

use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use JsonException;
use Psr\Http\Message\ResponseInterface;

use function array_flip;
use function array_intersect_key;
use function array_key_exists;
use function array_merge;
use function base64_encode;
use function is_array;
use function is_string;
use function json_decode;
use function ltrim;
use function max;
use function microtime;
use function min;
use function round;
use function rtrim;
use function sprintf;
use function str_contains;
use function trim;
use function usleep;

use const JSON_THROW_ON_ERROR;

/**
 * Fal.ai async image generator.
 *
 * Submits a job (POST https://api.fal.ai/v1/{modelId}) then polls
 * https://api.fal.ai/v1/jobs/{requestId} until completion. Based on
 * `docs.fal.ai/model-apis/guides/generate-images-from-text`.
 */
final class FalImageProvider implements ImageOperationInterface
{
    /**
     * @param array{
     *     base_url?: string,
     *     guidance_scale?: float,
     *     poll_interval_ms?: int,
     *     max_poll_attempts?: int,
     *     num_images?: int,
     *     provider_label?: string
     * } $defaults
     */
    public function __construct(
        private readonly ClientInterface $http,
        private readonly string $apiKey,
        private readonly string $modelId,
        private readonly array $defaults = [],
    ) {
    }

    #[\Override]
    public function generate(MediaRequest $request, array $options = []): MediaResult
    {
        $settings = $this->resolveSettings($options);
        $dimensions = $request->resolveDimensions();
        $payloadOverrides = $options['payload'] ?? [];
        if ($payloadOverrides !== [] && !is_array($payloadOverrides)) {
            throw new MediaException('Fal payload overrides must be an array.');
        }

        $payload = $this->buildPayload($request, $settings, $dimensions, $payloadOverrides);

        $jobId = $this->submitJob($payload, $settings);
        $resultPayload = $this->pollResult($jobId, $settings);

        $artifacts = $this->flattenFalArtifacts($resultPayload);
        $metadata = array_merge(
            [
                'request_id' => $jobId,
                'provider' => 'fal.ai',
                'latency_ms' => $resultPayload['metrics']['queue_time'] ?? null,
            ],
            $resultPayload['metadata'] ?? []
        );

        return new MediaResult(
            provider: $settings['provider_label'],
            model: $this->modelId,
            artifacts: $artifacts,
            metadata: $metadata,
        );
    }

    /**
     * @param array<string, mixed> $payload
     * @param array{base_url:string,poll_interval_ms:int,max_poll_attempts:int,provider_label:string} $settings
     */
    private function submitJob(array $payload, array $settings): string
    {
        try {
            $response = $this->http->request('POST', $this->endpoint($settings['base_url']), [
                'headers' => [
                    'Authorization' => 'Key ' . $this->apiKey,
                    'Content-Type' => 'application/json',
                ],
                'json' => $payload,
            ]);
        } catch (GuzzleException $exception) {
            throw new MediaException('Fal image submission failed: ' . $exception->getMessage(), 0, $exception);
        }

        $data = $this->decodeJson($response);
        $requestId = $data['request_id'] ?? $data['id'] ?? null;
        if (!is_string($requestId) || trim($requestId) === '') {
            throw new MediaException('Fal response missing request_id.');
        }

        return $requestId;
    }

    /**
     * @param array{base_url:string,poll_interval_ms:int,max_poll_attempts:int,provider_label:string} $settings
     *
     * @return array<string, mixed>
     */
    private function pollResult(string $requestId, array $settings): array
    {
        $attempts = 0;
        $start = microtime(true);
        do {
            $response = $this->getJobStatus($requestId, $settings['base_url']);
            $payload = $this->decodeJson($response);

            $status = (string) ($payload['status'] ?? 'unknown');
            $done = ($payload['done'] ?? false) === true || str_contains(strtolower($status), 'complete');

            if ($done) {
                $payload['metadata'] = array_merge(
                    $payload['metadata'] ?? [],
                    ['duration_ms' => (int) max(1, round((microtime(true) - $start) * 1000))]
                );

                return $payload;
            }

            if (str_contains(strtolower($status), 'fail')) {
                $message = is_string($payload['error'] ?? null) ? $payload['error'] : 'Fal job failed';
                throw new MediaException($message);
            }

            $this->delay($settings['poll_interval_ms']);
            ++$attempts;
        } while ($attempts < $settings['max_poll_attempts']);

        throw new MediaException('Fal image job did not complete before timeout.');
    }

    private function getJobStatus(string $requestId, string $baseUrl): ResponseInterface
    {
        $url = rtrim($baseUrl, '/') . '/jobs/' . $requestId;
        try {
            return $this->http->request('GET', $url, [
                'headers' => [
                    'Authorization' => 'Key ' . $this->apiKey,
                    'Accept' => 'application/json',
                ],
            ]);
        } catch (GuzzleException $exception) {
            throw new MediaException('Fal job polling failed: ' . $exception->getMessage(), 0, $exception);
        }
    }

    /**
     * @return list<array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }>
     */
    private function flattenFalArtifacts(array $payload): array
    {
        $images = $payload['images'] ?? $payload['output']['images'] ?? null;
        if (!is_array($images) || $images === []) {
            throw new MediaException('Fal job response missing images.');
        }

        $artifacts = [];
        foreach ($images as $entry) {
            if (!is_array($entry)) {
                continue;
            }

            $artifact = [];
            if (array_key_exists('url', $entry) && is_string($entry['url'])) {
                $artifact['url'] = $entry['url'];
            }

            if (array_key_exists('content_type', $entry) && is_string($entry['content_type'])) {
                $artifact['mime_type'] = $entry['content_type'];
            }

            if (array_key_exists('width', $entry)) {
                $artifact['width'] = (int) $entry['width'];
            }

            if (array_key_exists('height', $entry)) {
                $artifact['height'] = (int) $entry['height'];
            }

            if (array_key_exists('file_size', $entry)) {
                $artifact['bytes'] = (int) $entry['file_size'];
            }

            if (array_key_exists('b64_json', $entry) && is_string($entry['b64_json'])) {
                $artifact['base64'] = $entry['b64_json'];
            }

            if ($artifact === [] && array_key_exists('data', $entry) && is_string($entry['data'])) {
                $artifact['base64'] = base64_encode($entry['data']);
            }

            if ($artifact !== []) {
                $artifacts[] = $artifact;
            }
        }

        if ($artifacts === []) {
            throw new MediaException('Fal job returned no usable artifacts.');
        }

        return $artifacts;
    }

    /**
     * @param array<string, mixed> $payloadOverrides
     *
     * @return array<string, mixed>
     */
    private function buildPayload(
        MediaRequest $request,
        array $settings,
        array $dimensions,
        array $payloadOverrides
    ): array {
        $size = sprintf('%dx%d', $dimensions['width'], $dimensions['height']);
        $payload = [
            'prompt' => $request->getPrompt(),
            'negative_prompt' => $request->getNegativePrompt(),
            'num_images' => max(1, min($settings['num_images'], $request->getImageCount())),
            'image_size' => $size,
            'guidance_scale' => $settings['guidance_scale'],
        ];

        if ($request->getSeed() !== null) {
            $payload['seed'] = $request->getSeed();
        }

        if ($payloadOverrides !== []) {
            $payload = array_merge($payload, $payloadOverrides);
        }

        return $payload;
    }

    /**
     * @param ResponseInterface $response
     *
     * @return array<string, mixed>
     */
    private function decodeJson(ResponseInterface $response): array
    {
        $body = (string) $response->getBody();
        try {
            /** @var array<string, mixed> $payload */
            $payload = json_decode($body, true, 512, JSON_THROW_ON_ERROR);

            return $payload;
        } catch (JsonException $exception) {
            throw new MediaException('Fal response could not be decoded.', 0, $exception);
        }
    }

    private function endpoint(string $baseUrl): string
    {
        return rtrim($baseUrl, '/') . '/' . ltrim($this->modelId, '/');
    }

    private function delay(int $milliseconds): void
    {
        if ($milliseconds <= 0) {
            return;
        }

        usleep($milliseconds * 1000);
    }

    /**
     * @param array<string, mixed> $options
     *
     * @return array{
     *     base_url: string,
     *     guidance_scale: float,
     *     poll_interval_ms: int,
     *     max_poll_attempts: int,
     *     num_images: int,
     *     provider_label: string
     * }
     */
    private function resolveSettings(array $options): array
    {
        $defaults = array_merge([
            'base_url' => 'https://api.fal.ai/v1',
            'guidance_scale' => 7.5,
            'poll_interval_ms' => 750,
            'max_poll_attempts' => 40,
            'num_images' => 1,
            'provider_label' => 'fal.ai',
        ], $this->defaults);

        $overrides = array_intersect_key(
            $options,
            array_flip(['base_url', 'guidance_scale', 'poll_interval_ms', 'max_poll_attempts', 'num_images', 'provider_label'])
        );

        /** @var array{
         *     base_url: string,
         *     guidance_scale: float,
         *     poll_interval_ms: int,
         *     max_poll_attempts: int,
         *     num_images: int,
         *     provider_label: string
         * } $settings
         */
        $settings = array_merge($defaults, $overrides);

        return $settings;
    }
}
</document_content>
</document>

<document index="58">
<source>src/Media/ImageOperationInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/ImageOperationInterface.php

namespace ParaGra\Media;

interface ImageOperationInterface
{
    /**
     * @param array<string, mixed> $options
     */
    public function generate(MediaRequest $request, array $options = []): MediaResult;
}
</document_content>
</document>

<document index="59">
<source>src/Media/MediaException.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/MediaException.php

namespace ParaGra\Media;

use RuntimeException;

final class MediaException extends RuntimeException
{
}
</document_content>
</document>

<document index="60">
<source>src/Media/MediaRequest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/MediaRequest.php

namespace ParaGra\Media;

use InvalidArgumentException;

use function array_key_exists;
use function array_map;
use function ceil;
use function is_array;
use function is_int;
use function is_scalar;
use function is_string;
use function max;
use function preg_match;
use function round;
use function sprintf;
use function trim;

/**
 * Immutable request payload describing a text-to-image operation.
 *
 * Inspired by the ParaGra provider catalog research we capture prompt text,
 * optional negative prompts, image counts, seeds, aspect ratios, and user
 * metadata so all downstream image providers can share a single contract.
 */
final class MediaRequest
{
    private string $prompt;

    private ?string $negativePrompt;

    private ?int $width;

    private ?int $height;

    /**
     * @var array{w:int,h:int}|null
     */
    private ?array $aspectRatio;

    private int $images;

    private ?int $seed;

    /**
     * @var array<string, string|int|float|bool|list<string|int|float|bool|null>|null>
     */
    private array $metadata;

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool|null>|null> $metadata
     */
    public function __construct(
        string $prompt,
        ?string $negativePrompt = null,
        ?int $width = null,
        ?int $height = null,
        ?string $aspectRatio = null,
        int $images = 1,
        ?int $seed = null,
        array $metadata = [],
    ) {
        $this->prompt = $this->sanitizePrompt($prompt, 'prompt');
        $this->negativePrompt = $negativePrompt !== null
            ? $this->sanitizePrompt($negativePrompt, 'negative prompt', allowEmpty: true)
            : null;
        $this->width = $this->sanitizeDimension($width, 'width');
        $this->height = $this->sanitizeDimension($height, 'height');
        $this->aspectRatio = $aspectRatio !== null ? $this->parseAspectRatio($aspectRatio) : null;

        if ($this->width === null && $this->height === null && $this->aspectRatio === null) {
            // Default to square instructions to avoid provider ambiguity.
            $this->aspectRatio = ['w' => 1, 'h' => 1];
        }

        if ($images <= 0) {
            throw new InvalidArgumentException('MediaRequest images must be a positive integer.');
        }

        $this->images = $images;
        $this->seed = $seed;
        $this->metadata = $this->validateMetadata($metadata);
    }

    public function getPrompt(): string
    {
        return $this->prompt;
    }

    public function getNegativePrompt(): ?string
    {
        return $this->negativePrompt;
    }

    public function getWidth(): ?int
    {
        return $this->width;
    }

    public function getHeight(): ?int
    {
        return $this->height;
    }

    public function getAspectRatio(): ?string
    {
        if ($this->aspectRatio === null) {
            return null;
        }

        return sprintf('%d:%d', $this->aspectRatio['w'], $this->aspectRatio['h']);
    }

    public function getImageCount(): int
    {
        return $this->images;
    }

    public function getSeed(): ?int
    {
        return $this->seed;
    }

    /**
     * @return array<string, scalar|array<scalar>|null>
     */
    public function getMetadata(): array
    {
        return $this->metadata;
    }

    /**
     * Resolve concrete dimensions that respect the request + defaults.
     *
     * @return array{width:int,height:int}
     */
    public function resolveDimensions(int $defaultWidth = 1024, int $defaultHeight = 1024): array
    {
        $width = $this->width ?? $defaultWidth;
        $height = $this->height ?? $defaultHeight;

        if ($this->aspectRatio !== null) {
            if ($this->width !== null && $this->height === null) {
                $height = (int) round($this->width * $this->aspectRatio['h'] / $this->aspectRatio['w']);
            } elseif ($this->height !== null && $this->width === null) {
                $width = (int) round($this->height * $this->aspectRatio['w'] / $this->aspectRatio['h']);
            } elseif ($this->width === null && $this->height === null) {
                $width = $defaultWidth;
                $height = (int) round($defaultWidth * $this->aspectRatio['h'] / $this->aspectRatio['w']);
            }
        }

        return [
            'width' => $this->normalizeDimension($width),
            'height' => $this->normalizeDimension($height),
        ];
    }

    /**
     * @return array{
     *     prompt: string,
     *     negative_prompt: string|null,
     *     width: int|null,
     *     height: int|null,
     *     aspect_ratio: string|null,
     *     images: int,
     *     seed: int|null,
     *     metadata: array<string, string|int|float|bool|list<string|int|float|bool|null>|null>
     * }
     */
    public function toArray(): array
    {
        return [
            'prompt' => $this->prompt,
            'negative_prompt' => $this->negativePrompt,
            'width' => $this->width,
            'height' => $this->height,
            'aspect_ratio' => $this->getAspectRatio(),
            'images' => $this->images,
            'seed' => $this->seed,
            'metadata' => $this->metadata,
        ];
    }

    private function sanitizePrompt(string $prompt, string $context, bool $allowEmpty = false): string
    {
        $clean = trim($prompt);
        if (!$allowEmpty && $clean === '') {
            throw new InvalidArgumentException(sprintf('MediaRequest %s cannot be empty.', $context));
        }

        return $clean;
    }

    private function sanitizeDimension(?int $value, string $context): ?int
    {
        if ($value === null) {
            return null;
        }

        if ($value <= 0) {
            throw new InvalidArgumentException(sprintf('MediaRequest %s must be positive.', $context));
        }

        return $value;
    }

    /**
     * @return array{w:int,h:int}
     */
    private function parseAspectRatio(string $ratio): array
    {
        $clean = trim($ratio);
        if ($clean === '') {
            throw new InvalidArgumentException('MediaRequest aspect ratio cannot be empty.');
        }

        if (preg_match('/^(?P<w>\d+)\s*[:x]\s*(?P<h>\d+)$/i', $clean, $matches) !== 1) {
            throw new InvalidArgumentException('Aspect ratio must use the W:H format (e.g. 16:9).');
        }

        $width = (int) $matches['w'];
        $height = (int) $matches['h'];
        if ($width === 0 || $height === 0) {
            throw new InvalidArgumentException('Aspect ratio components must be positive.');
        }

        return ['w' => $width, 'h' => $height];
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool|null>|null> $metadata
     *
     * @return array<string, string|int|float|bool|list<string|int|float|bool|null>|null>
     */
    private function validateMetadata(array $metadata): array
    {
        foreach ($metadata as $key => $value) {
            if (!is_string($key)) {
                throw new InvalidArgumentException('MediaRequest metadata keys must be strings.');
            }

            if ($value === null || is_scalar($value)) {
                continue;
            }

            if (!is_array($value)) {
                throw new InvalidArgumentException(
                    sprintf('MediaRequest metadata for "%s" must be scalar, null, or list.', $key)
                );
            }

            array_map(static function ($entry) use ($key): void {
                if ($entry !== null && !is_scalar($entry)) {
                    throw new InvalidArgumentException(
                        sprintf('MediaRequest metadata list "%s" must contain scalar or null entries.', $key)
                    );
                }
            }, $value);
        }

        return $metadata;
    }

    private function normalizeDimension(int $value): int
    {
        $aligned = (int) ceil($value / 8) * 8;

        return max($aligned, 64);
    }
}
</document_content>
</document>

<document index="61">
<source>src/Media/MediaResult.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Media/MediaResult.php

namespace ParaGra\Media;

use InvalidArgumentException;

use function array_key_exists;
use function array_map;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_string;
use function trim;

/**
 * Immutable DTO returned by image/video providers.
 *
 * Captures the originating provider/model plus the generated artifacts so
 * callers can stream URLs, inline base64, or metadata to downstream clients.
 */
final class MediaResult
{
    /**
     * @var list<array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }>
     */
    private array $artifacts;

    /**
     * @param list<array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }> $artifacts
     * @param array<string, string|int|float|bool|null> $metadata
     */
    public function __construct(
        private readonly string $provider,
        private readonly string $model,
        array $artifacts,
        private readonly array $metadata = [],
    ) {
        $this->provider = $this->sanitizeString($provider, 'provider');
        $this->model = $this->sanitizeString($model, 'model');
        if ($artifacts === []) {
            throw new InvalidArgumentException('MediaResult requires at least one artifact.');
        }

        $this->artifacts = array_map($this->validateArtifact(...), $artifacts);
        $this->assertMetadata($metadata);
    }

    public function getProvider(): string
    {
        return $this->provider;
    }

    public function getModel(): string
    {
        return $this->model;
    }

    /**
     * @return list<array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }>
     */
    public function getArtifacts(): array
    {
        return $this->artifacts;
    }

    /**
     * @return array<string, string|int|float|bool|null>
     */
    public function getMetadata(): array
    {
        return $this->metadata;
    }

    public function getFirstUrl(): ?string
    {
        foreach ($this->artifacts as $artifact) {
            if (array_key_exists('url', $artifact)) {
                return $artifact['url'];
            }
        }

        return null;
    }

    /**
     * @return array{
     *     provider: string,
     *     model: string,
     *     artifacts: list<array{
     *         url?: string,
     *         base64?: string,
     *         mime_type?: string,
     *         width?: int,
     *         height?: int,
     *         bytes?: int|null,
     *         metadata?: array<string, string|int|float|bool|null>
     *     }>,
     *     metadata: array<string, string|int|float|bool|null>
     * }
     */
    public function toArray(): array
    {
        return [
            'provider' => $this->provider,
            'model' => $this->model,
            'artifacts' => $this->artifacts,
            'metadata' => $this->metadata,
        ];
    }

    private function sanitizeString(string $value, string $context): string
    {
        $clean = trim($value);
        if ($clean === '') {
            throw new InvalidArgumentException(sprintf('MediaResult %s cannot be empty.', $context));
        }

        return $clean;
    }

    /**
     * @return array{
     *     url?: string,
     *     base64?: string,
     *     mime_type?: string,
     *     width?: int,
     *     height?: int,
     *     bytes?: int|null,
     *     metadata?: array<string, string|int|float|bool|null>
     * }
     */
    private function validateArtifact(array $artifact): array
    {
        if (!array_key_exists('url', $artifact) && !array_key_exists('base64', $artifact)) {
            throw new InvalidArgumentException('MediaResult artifact requires either a URL or inline data.');
        }

        if (array_key_exists('url', $artifact) && !is_string($artifact['url'])) {
            throw new InvalidArgumentException('MediaResult artifact URL must be a string.');
        }

        if (array_key_exists('base64', $artifact) && !is_string($artifact['base64'])) {
            throw new InvalidArgumentException('MediaResult artifact base64 payload must be a string.');
        }

        if (array_key_exists('width', $artifact) && (!is_int($artifact['width']) || $artifact['width'] <= 0)) {
            throw new InvalidArgumentException('MediaResult artifact width must be positive integer.');
        }

        if (array_key_exists('height', $artifact) && (!is_int($artifact['height']) || $artifact['height'] <= 0)) {
            throw new InvalidArgumentException('MediaResult artifact height must be positive integer.');
        }

        if (array_key_exists('bytes', $artifact) && $artifact['bytes'] !== null && (!is_int($artifact['bytes']) || $artifact['bytes'] < 0)) {
            throw new InvalidArgumentException('MediaResult artifact bytes must be null or non-negative integer.');
        }

        if (array_key_exists('mime_type', $artifact) && !is_string($artifact['mime_type'])) {
            throw new InvalidArgumentException('MediaResult artifact mime_type must be a string.');
        }

        if (array_key_exists('metadata', $artifact)) {
            if (!is_array($artifact['metadata'])) {
                throw new InvalidArgumentException('MediaResult artifact metadata must be an array.');
            }

            array_map(static function ($value, string $key): void {
                if ($value !== null && !is_string($value) && !is_int($value) && !is_float($value) && !is_bool($value)) {
                    throw new InvalidArgumentException(
                        sprintf('MediaResult artifact metadata "%s" must be scalar or null.', $key)
                    );
                }
            }, $artifact['metadata'], array_keys($artifact['metadata']));
        }

        return $artifact;
    }

    /**
     * @param array<string, string|int|float|bool|null> $metadata
     */
    private function assertMetadata(array $metadata): void
    {
        foreach ($metadata as $key => $value) {
            if (!is_string($key)) {
                throw new InvalidArgumentException('MediaResult metadata keys must be strings.');
            }

            if ($value !== null && !is_string($value) && !is_int($value) && !is_float($value) && !is_bool($value)) {
                throw new InvalidArgumentException(
                    sprintf('MediaResult metadata "%s" must be scalar or null.', $key)
                );
            }
        }
    }
}
</document_content>
</document>

<document index="62">
<source>src/Moderation/ModerationException.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Moderation/ModerationException.php

namespace ParaGra\Moderation;

/**
 * Exception thrown when content is flagged by moderation
 */
class ModerationException extends \RuntimeException
{
    /**
     * @param array<string, bool> $flaggedCategories
     * @param array<string, float> $categoryScores
     */
    public function __construct(
        string $message,
        private readonly array $flaggedCategories = [],
        private readonly array $categoryScores = [],
        int $code = 0,
        ?\Throwable $previous = null
    ) {
        parent::__construct($message, $code, $previous);
    }

    /**
     * Get flagged categories
     *
     * @return array<string, bool>
     */
    public function getFlaggedCategories(): array
    {
        return $this->flaggedCategories;
    }

    /**
     * Get category scores
     *
     * @return array<string, float>
     */
    public function getCategoryScores(): array
    {
        return $this->categoryScores;
    }

    /**
     * Get comma-separated list of flagged category names
     */
    public function getFlaggedCategoryNames(): string
    {
        $names = array_keys(array_filter($this->flaggedCategories, fn ($v) => $v === true));
        return implode(', ', $names);
    }
}
</document_content>
</document>

<document index="63">
<source>src/Moderation/ModerationResult.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Moderation/ModerationResult.php

namespace ParaGra\Moderation;

/**
 * Result from content moderation when content is not flagged
 */
class ModerationResult
{
    /**
     * @param array<string, bool> $categories
     * @param array<string, float> $categoryScores
     */
    public function __construct(
        private readonly bool $flagged,
        private readonly array $categories = [],
        private readonly array $categoryScores = []
    ) {
    }

    /**
     * Check if content was flagged as harmful
     */
    public function isFlagged(): bool
    {
        return $this->flagged;
    }

    /**
     * Get all categories
     *
     * @return array<string, bool>
     */
    public function getCategories(): array
    {
        return $this->categories;
    }

    /**
     * Get category scores
     *
     * @return array<string, float>
     */
    public function getCategoryScores(): array
    {
        return $this->categoryScores;
    }

    /**
     * Get score for specific category
     */
    public function getCategoryScore(string $category): ?float
    {
        return $this->categoryScores[$category] ?? null;
    }

    /**
     * Check if specific category was flagged
     */
    public function isCategoryFlagged(string $category): bool
    {
        return $this->categories[$category] ?? false;
    }
}
</document_content>
</document>

<document index="64">
<source>src/Moderation/ModeratorInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Moderation/ModeratorInterface.php

namespace ParaGra\Moderation;

/**
 * Generic moderation adapter contract.
 *
 * Implementations should throw ModerationException when content violates policy.
 */
interface ModeratorInterface
{
    /**
     * @throws ModerationException when the supplied text is flagged.
     */
    public function moderate(string $text): ModerationResult;

    /**
     * Lightweight safety probe that does not bubble exceptions.
     */
    public function isSafe(string $text): bool;
}
</document_content>
</document>

<document index="65">
<source>src/Moderation/NullModerator.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Moderation/NullModerator.php

namespace ParaGra\Moderation;

/**
 * No-op moderator used to explicitly disable moderation.
 */
final class NullModerator implements ModeratorInterface
{
    public function moderate(string $text): ModerationResult
    {
        return new ModerationResult(
            flagged: false,
            categories: [],
            categoryScores: []
        );
    }

    public function isSafe(string $text): bool
    {
        return true;
    }
}
</document_content>
</document>

<document index="66">
<source>src/Moderation/OpenAiModerator.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Moderation/OpenAiModerator.php

namespace ParaGra\Moderation;

use OpenAI\Contracts\Resources\ModerationsContract;
use ParaGra\Util\ConfigValidator;

/**
 * OpenAI Content Moderation
 *
 * Uses OpenAI's moderation API to check if content is potentially harmful.
 */
class OpenAiModerator implements ModeratorInterface
{
    private const DEFAULT_MODEL = 'omni-moderation-latest';

    public function __construct(
        private readonly ModerationsContract $moderations,
        private readonly string $model = self::DEFAULT_MODEL
    ) {
    }

    /**
     * Create moderator from environment variables
     *
     * Required environment variables:
     * - OPENAI_API_KEY
     *
     * Optional environment variables:
     * - OPENAI_MODERATION_MODEL (default: omni-moderation-latest)
     *
     * @throws \ParaGra\Exception\ConfigurationException if OPENAI_API_KEY missing
     */
    public static function fromEnv(): self
    {
        $apiKey = ConfigValidator::requireEnv('OPENAI_API_KEY');
        $model = ConfigValidator::getEnv('OPENAI_MODERATION_MODEL', self::DEFAULT_MODEL);

        $client = \OpenAI::client($apiKey);
        $moderations = $client->moderations();

        return new self($moderations, $model);
    }

    /**
     * Moderate text content
     *
     * @throws ModerationException if content is flagged as harmful
     */
    public function moderate(string $text): ModerationResult
    {
        try {
            $response = $this->moderations->create([
                'model' => $this->model,
                'input' => $text,
            ]);

            // Get first result (single text input)
            $result = $response->results[0] ?? null;

            if ($result === null) {
                throw new \RuntimeException('No moderation results returned');
            }

            // Extract data from OpenAI response objects
            $flagged = $result->flagged;

            // Convert CreateResponseCategory objects to arrays
            $categories = [];
            $categoryScores = [];

            foreach ($result->categories as $categoryName => $categoryObj) {
                $categories[$categoryName] = $categoryObj->violated;
                $categoryScores[$categoryName] = $categoryObj->score;
            }

            // If flagged, throw exception
            if ($flagged) {
                $flaggedCategories = array_filter($categories, fn ($v) => $v === true);
                $categoryNames = implode(', ', array_keys($flaggedCategories));

                throw new ModerationException(
                    "Content flagged by moderation: {$categoryNames}",
                    $categories,
                    $categoryScores
                );
            }

            return new ModerationResult(
                flagged: false,
                categories: $categories,
                categoryScores: $categoryScores
            );
        } catch (ModerationException $e) {
            // Re-throw moderation exceptions
            throw $e;
        } catch (\Throwable $e) {
            // Wrap other errors
            throw new \RuntimeException(
                'Moderation API request failed: ' . $e->getMessage(),
                0,
                $e
            );
        }
    }

    /**
     * Check if text is safe (doesn't throw on flagged content)
     */
    public function isSafe(string $text): bool
    {
        try {
            $this->moderate($text);
            return true;
        } catch (ModerationException $e) {
            return false;
        }
    }
}
</document_content>
</document>

<document index="67">
<source>src/ParaGra.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ParaGra.php

namespace ParaGra;

use InvalidArgumentException;
use ParaGra\Config\PriorityPool;
use ParaGra\Config\ProviderSpec;
use ParaGra\Llm\NeuronAiAdapter;
use ParaGra\Llm\PromptBuilder;
use ParaGra\Moderation\ModeratorInterface;
use ParaGra\ProviderCatalog\ProviderDiscovery;
use ParaGra\Providers\ProviderFactory;
use ParaGra\Providers\ProviderInterface;
use ParaGra\Response\UnifiedResponse;
use ParaGra\Router\FallbackStrategy;
use ParaGra\Router\KeyRotator;

use function array_merge;
use function dirname;
use function is_array;
use function is_string;
use function sprintf;
use function trim;

/**
 * High-level entry point that routes retrieval + answer flows across configured providers.
 */
final class ParaGra
{
    private FallbackStrategy $fallback;

    private PromptBuilder $promptBuilder;

    private ?ModeratorInterface $moderator = null;

    /**
     * @var callable(ProviderSpec): ProviderInterface
     */
    private $providerResolver;

    /**
     * @var callable(ProviderSpec): NeuronAiAdapter
     */
    private $llmResolver;

    public function __construct(
        private readonly PriorityPool $pools,
        private readonly ProviderFactory $providerFactory,
        ?FallbackStrategy $fallback = null,
        ?PromptBuilder $promptBuilder = null,
        ?callable $providerResolver = null,
        ?callable $llmResolver = null,
    ) {
        $this->fallback = $fallback ?? new FallbackStrategy($pools, new KeyRotator());
        $this->promptBuilder = $promptBuilder ?? new PromptBuilder();
        $this->providerResolver = $providerResolver ?? [$this->providerFactory, 'createProvider'];
        $this->llmResolver = $llmResolver ?? [$this->providerFactory, 'createLlmClient'];
    }

    /**
     * @param array<string, mixed> $config
     */
    public static function fromConfig(array $config): self
    {
        if (!isset($config['priority_pools']) || !is_array($config['priority_pools'])) {
            throw new InvalidArgumentException('ParaGra configuration requires a "priority_pools" array.');
        }

        $catalog = null;
        if (self::hasCatalogEntries($config['priority_pools'])) {
            $catalogPath = isset($config['provider_catalog']) && is_string($config['provider_catalog'])
                ? $config['provider_catalog']
                : self::defaultCatalogPath();
            $catalog = ProviderDiscovery::fromFile($catalogPath);
        }

        $pools = PriorityPool::fromArray($config['priority_pools'], $catalog);

        return new self($pools, new ProviderFactory());
    }

    public function withModeration(ModeratorInterface $moderator): self
    {
        $this->moderator = $moderator;

        return $this;
    }

    /**
     * Execute a retrieval request with automatic rotation + fallback.
     *
     * @param array<string, mixed> $options Provider-specific retrieval overrides
     */
    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        $cleanQuery = $this->guardQuestion($query);

        return $this->fallback->execute(function (ProviderSpec $spec) use ($cleanQuery, $options): UnifiedResponse {
            $provider = $this->resolveProvider($spec);
            return $provider->retrieve($cleanQuery, $options);
        });
    }

    /**
     * Answer a user question by retrieving context + invoking the configured LLM provider.
     *
     * @param array{
     *     retrieval?: array<string, mixed>,
     *     generation?: array<string, mixed>
     * } $options
     *
     * @return array{
     *     answer: string,
     *     prompt: string,
     *     context: UnifiedResponse,
     *     metadata: array<string, mixed>
     * }
     */
    public function answer(string $question, array $options = []): array
    {
        $cleanQuestion = $this->guardQuestion($question);
        $retrievalOptions = $this->extractNestedOptions($options, 'retrieval');
        $generationOptions = $this->extractNestedOptions($options, 'generation');

        return $this->fallback->execute(function (ProviderSpec $spec) use ($cleanQuestion, $retrievalOptions, $generationOptions): array {
            $provider = $this->resolveProvider($spec);
            $context = $provider->retrieve($cleanQuestion, $retrievalOptions);
            $prompt = $this->promptBuilder->build($cleanQuestion, $context->getChunkTexts());

            $llm = $this->resolveLlm($spec);
            $answer = $llm->generate($prompt, $generationOptions);

            return [
                'answer' => $answer,
                'prompt' => $prompt,
                'context' => $context,
                'metadata' => array_merge(
                    [
                        'provider' => $spec->provider,
                        'model' => $spec->model,
                    ],
                    $context->getProviderMetadata(),
                ),
            ];
        });
    }

    private function guardQuestion(string $question): string
    {
        $clean = trim($question);
        if ($clean === '') {
            throw new InvalidArgumentException('Query cannot be empty.');
        }

        if ($this->moderator !== null) {
            $this->moderator->moderate($clean);
        }

        return $clean;
    }

    /**
     * @return array<string, mixed>
     */
    private function extractNestedOptions(array $options, string $key): array
    {
        if (!isset($options[$key])) {
            return [];
        }

        if (!is_array($options[$key])) {
            throw new InvalidArgumentException(sprintf('The "%s" option must be an array.', $key));
        }

        return $options[$key];
    }

    private function resolveProvider(ProviderSpec $spec): ProviderInterface
    {
        $provider = ($this->providerResolver)($spec);
        if (!$provider instanceof ProviderInterface) {
            throw new InvalidArgumentException('Provider resolver must return a ProviderInterface implementation.');
        }

        return $provider;
    }

    private function resolveLlm(ProviderSpec $spec): NeuronAiAdapter
    {
        $adapter = ($this->llmResolver)($spec);
        if (!$adapter instanceof NeuronAiAdapter) {
            throw new InvalidArgumentException('LLM resolver must return a NeuronAiAdapter instance.');
        }

        return $adapter;
    }

    /**
     * @param array<int, mixed> $priorityPools
     */
    private static function hasCatalogEntries(array $priorityPools): bool
    {
        foreach ($priorityPools as $pool) {
            if (!is_array($pool)) {
                continue;
            }

            foreach ($pool as $spec) {
                if (is_array($spec) && (isset($spec['catalog']) || isset($spec['catalog_slug']))) {
                    return true;
                }
            }
        }

        return false;
    }

    private static function defaultCatalogPath(): string
    {
        return dirname(__DIR__) . '/config/providers/catalog.php';
    }
}
</document_content>
</document>

<document index="68">
<source>src/Pipeline/HybridRetrievalPipeline.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Pipeline/HybridRetrievalPipeline.php

namespace ParaGra\Pipeline;

use ParaGra\Embedding\EmbeddingProviderInterface;
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Response\UnifiedResponse;
use ParaGra\VectorStore\VectorNamespace;
use ParaGra\VectorStore\VectorStoreInterface;
use RuntimeException;

use function array_filter;
use function array_key_exists;
use function array_slice;
use function array_values;
use function is_array;
use function is_numeric;
use function is_string;
use function max;
use function preg_replace;
use function sha1;
use function sprintf;
use function strtolower;
use function trim;
use function usort;

/**
 * Coordinates hybrid retrieval by:
 * - calling a Ragie-backed retriever for keyword/RAG contexts
 * - embedding text and storing it in an external vector store
 * - querying the vector store with semantic embeddings
 * - reranking + deduplicating both sources into a single UnifiedResponse
 */
final class HybridRetrievalPipeline
{
    /**
     * @var callable(string, array<string, mixed>): UnifiedResponse
     */
    private $ragieRetriever;

    public function __construct(
        callable $ragieRetriever,
        private readonly EmbeddingProviderInterface $embeddingProvider,
        private readonly VectorStoreInterface $vectorStore,
        private readonly VectorNamespace $namespace,
        private readonly int $maxCombinedChunks = 8,
        private readonly float $ragieWeight = 1.0,
        private readonly float $vectorStoreWeight = 0.85,
    ) {
        if ($maxCombinedChunks <= 0) {
            throw new RuntimeException('maxCombinedChunks must be positive.');
        }

        if ($ragieWeight <= 0 || $vectorStoreWeight <= 0) {
            throw new RuntimeException('Hybrid weights must be positive.');
        }

        $this->ragieRetriever = $ragieRetriever;
    }

    /**
     * Pulls Ragie context, embeds chunk text, and seeds the configured vector store.
     *
     * @param array{
     *     retrieval?: array<string, mixed>,
     *     vector_store?: array<string, mixed>
     * } $options
     *
     * @return array{
     *     context: UnifiedResponse,
     *     ingested_chunks: int,
     *     upsert: array<string, mixed>
     * }
     */
    public function ingestFromRagie(string $question, array $options = []): array
    {
        $context = $this->callRetriever($question, $options['retrieval'] ?? []);

        if ($context->isEmpty()) {
            return [
                'context' => $context,
                'ingested_chunks' => 0,
                'upsert' => ['upserted' => 0, 'updated' => 0],
            ];
        }

        $inputs = $this->buildEmbeddingInputs($context);
        $embeddingRequest = new EmbeddingRequest($inputs);
        $vectors = $this->embeddingProvider->embed($embeddingRequest);
        $records = $this->buildVectorRecords($vectors['vectors'], $inputs);

        $upsert = $this->vectorStore->upsert(
            $this->namespace,
            $records,
            $options['vector_store'] ?? [],
        );

        return [
            'context' => $context,
            'ingested_chunks' => count($records),
            'upsert' => $upsert,
        ];
    }

    /**
     * Executes hybrid retrieval (Ragie + vector store) and returns raw + reranked contexts.
     *
     * @param array{
     *     retrieval?: array<string, mixed>,
     *     vector_store?: array<string, mixed>,
     *     hybrid_limit?: int
     * } $options
     *
     * @return array{
     *     ragie: UnifiedResponse,
     *     vector_store: UnifiedResponse,
     *     combined: UnifiedResponse
     * }
     */
    public function hybridRetrieve(string $question, array $options = []): array
    {
        $ragieContext = $this->callRetriever($question, $options['retrieval'] ?? []);
        $vectorResponse = $this->queryVectorStore($question, $options['vector_store'] ?? []);

        $limit = (int) ($options['hybrid_limit'] ?? $this->maxCombinedChunks);
        if ($limit <= 0) {
            $limit = $this->maxCombinedChunks;
        }

        $combined = $this->combineContexts($ragieContext, $vectorResponse, $limit);

        return [
            'ragie' => $ragieContext,
            'vector_store' => $vectorResponse,
            'combined' => $combined,
        ];
    }

    /**
     * @param array<string, mixed> $options
     */
    private function callRetriever(string $question, array $options): UnifiedResponse
    {
        $response = ($this->ragieRetriever)($question, $options);
        if (! $response instanceof UnifiedResponse) {
            throw new RuntimeException('Retriever must return a UnifiedResponse instance.');
        }

        return $response;
    }

    /**
     * @return list<array{id: string|null, text: string, metadata: array<string, mixed>|null}>
     */
    private function buildEmbeddingInputs(UnifiedResponse $context): array
    {
        $inputs = [];
        foreach ($context->getChunks() as $index => $chunk) {
            $metadata = [
                'origin' => 'ragie',
                'ragie_score' => $this->extractScore($chunk),
                'ragie_document_id' => $chunk['document_id'] ?? sprintf('ragie-%d', $index + 1),
                'ragie_model' => $this->slug($context->getModel()),
                'ragie_provider' => $this->slug($context->getProvider()),
                'snippet_index' => $index,
            ];

            $metadata = array_filter(
                $metadata,
                static fn (mixed $value): bool => $value !== null
            );

            $inputs[] = [
                'id' => $chunk['document_id'] ?? sprintf('ragie-%d', $index + 1),
                'text' => $chunk['text'],
                'metadata' => $metadata,
            ];
        }

        return $inputs;
    }

    /**
     * @param list<array{id: string|null, values: list<float>, metadata?: array<string, mixed>|null}> $vectors
     * @param list<array{id: string|null, text: string, metadata: array<string, mixed>|null}> $inputs
     *
     * @return list<array{id: string, values: list<float>, metadata: array<string, mixed>}>
     */
    private function buildVectorRecords(array $vectors, array $inputs): array
    {
        $records = [];
        foreach ($vectors as $index => $vector) {
            $input = $inputs[$index] ?? null;
            if ($input === null) {
                continue;
            }

            $id = $vector['id'] ?? $input['id'] ?? sprintf('ragie-chunk-%d', $index + 1);
            $metadata = is_array($vector['metadata'] ?? null) ? $vector['metadata'] : [];

            if ($input['metadata'] !== null) {
                $metadata += $input['metadata'];
            }

            $metadata['text'] ??= $input['text'];
            $metadata['origin'] ??= 'ragie';

            $records[] = [
                'id' => $id,
                'values' => $vector['values'],
                'metadata' => $metadata,
            ];
        }

        return $records;
    }

    /**
     * @param array<string, mixed> $options
     */
    private function queryVectorStore(string $question, array $options): UnifiedResponse
    {
        $request = new EmbeddingRequest([
            [
                'id' => 'query',
                'text' => $question,
                'metadata' => ['origin' => 'query'],
            ],
        ]);

        $embedding = $this->embeddingProvider->embed($request);
        if (! array_key_exists(0, $embedding['vectors'])) {
            throw new RuntimeException('Embedding provider did not return a query vector.');
        }

        $vector = $embedding['vectors'][0]['values'];
        $vectorOptions = $options;
        if (! array_key_exists('query', $vectorOptions)) {
            $vectorOptions['query'] = $question;
        }

        return $this->vectorStore->query($this->namespace, $vector, $vectorOptions);
    }

    private function combineContexts(UnifiedResponse $ragie, UnifiedResponse $vectorStore, int $limit): UnifiedResponse
    {
        $combined = [];
        $ragieKeys = $this->collectChunkKeys($ragie);

        foreach ($ragie->getChunks() as $index => $chunk) {
            $combined[] = $this->decorateChunk(
                $chunk,
                'ragie',
                $ragie->getProvider(),
                $ragie->getModel(),
                $this->ragieWeight,
                $index,
                false,
            );
        }

        foreach ($vectorStore->getChunks() as $index => $chunk) {
            $combined[] = $this->decorateChunk(
                $chunk,
                'vector_store',
                $vectorStore->getProvider(),
                $vectorStore->getModel(),
                $this->vectorStoreWeight,
                $index,
                isset($ragieKeys[$this->chunkKey($chunk)]),
            );
        }

        $deduped = $this->deduplicateChunks($combined);

        usort(
            $deduped,
            static fn (array $a, array $b): int => ($b['score'] ?? 0.0) <=> ($a['score'] ?? 0.0)
        );

        $chunks = array_slice($deduped, 0, $limit);

        return UnifiedResponse::fromChunks(
            provider: 'hybrid',
            model: sprintf('%s+%s', $ragie->getProvider(), $this->vectorStore->getProvider()),
            chunks: $chunks,
            metadata: [
                'ragie_provider' => $ragie->getProvider(),
                'ragie_model' => $ragie->getModel(),
                'vector_store_provider' => $this->vectorStore->getProvider(),
                'vector_store_model' => $vectorStore->getModel(),
            ],
        );
    }

    /**
     * @param array<string, mixed> $chunk
     */
    private function decorateChunk(
        array $chunk,
        string $origin,
        string $provider,
        string $model,
        float $weight,
        int $index,
        bool $duplicatePenalty = false,
    ): array {
        $metadata = is_array($chunk['metadata'] ?? null) ? $chunk['metadata'] : [];
        $metadata['origin'] = $origin;
        $metadata['source_provider'] = $provider;
        $metadata['source_model'] = $model;

        $chunk['score'] = $this->weightedScore($chunk, $weight, $index);
        if ($duplicatePenalty) {
            $chunk['score'] *= 0.9;
        }
        $chunk['metadata'] = $metadata;

        return $chunk;
    }

    /**
     * @param list<array<string, mixed>> $chunks
     *
     * @return list<array<string, mixed>>
     */
    private function deduplicateChunks(array $chunks): array
    {
        $unique = [];

        foreach ($chunks as $chunk) {
            $key = $this->chunkKey($chunk);

            if (! array_key_exists($key, $unique) || ($chunk['score'] ?? 0.0) > ($unique[$key]['score'] ?? 0.0)) {
                $unique[$key] = $chunk;
            }
        }

        return array_values($unique);
    }

    /**
     * Extracts the upstream similarity score.
     *
     * @param array<string, mixed> $chunk
     */
    private function extractScore(array $chunk): ?float
    {
        if (! array_key_exists('score', $chunk)) {
            return null;
        }

        $score = $chunk['score'];
        if (! is_numeric($score)) {
            return null;
        }

        return (float) $score;
    }

    /**
     * @param array<string, mixed> $chunk
     */
    private function weightedScore(array $chunk, float $weight, int $index): float
    {
        $base = $this->extractScore($chunk);
        if ($base === null) {
            $base = max(0.01, 1 - ($index * 0.05));
        }

        return $base * $weight;
    }

    private function slug(string $value): string
    {
        $slug = (string) preg_replace('/[^a-zA-Z0-9]+/', '_', strtolower($value));
        $slug = trim($slug, '_');

        return $slug !== '' ? $slug : 'ragie';
    }

    /**
     * @return array<string, bool>
     */
    private function collectChunkKeys(UnifiedResponse $response): array
    {
        $keys = [];
        foreach ($response->getChunks() as $chunk) {
            $keys[$this->chunkKey($chunk)] = true;
        }

        return $keys;
    }

    /**
     * @param array<string, mixed> $chunk
     */
    private function chunkKey(array $chunk): string
    {
        if (isset($chunk['document_id']) && is_string($chunk['document_id'])) {
            $docId = trim($chunk['document_id']);
            if ($docId !== '') {
                return $docId;
            }
        }

        return sha1($chunk['text']);
    }
}
</document_content>
</document>

<document index="69">
<source>src/Planner/PoolBuilder.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Planner/PoolBuilder.php

namespace ParaGra\Planner;

use ParaGra\ProviderCatalog\ProviderDiscovery;
use ParaGra\ProviderCatalog\ProviderSummary;
use RuntimeException;

use function array_filter;
use function array_key_exists;
use function array_map;
use function array_replace_recursive;
use function array_values;
use function explode;
use function getenv;
use function is_array;
use function is_string;
use function sprintf;
use function trim;

/**
 * Scenario-aware builder that assembles ParaGra priority pools from catalog data.
 */
final class PoolBuilder
{
    public const PRESET_FREE = 'free-tier';
    public const PRESET_HYBRID = 'hybrid';
    public const PRESET_HOSTED = 'hosted';

    /**
     * @param array<string, string> $environment
     */
    public function __construct(
        private readonly ProviderDiscovery $catalog,
        private readonly array $environment = [],
    ) {
    }

    public static function fromGlobals(ProviderDiscovery $catalog): self
    {
        return new self($catalog);
    }

    /**
     * @param array<string, mixed> $options
     * @return array<int, array<int, array<string, mixed>>>
     */
    public function build(string $preset, array $options = []): array
    {
        return match ($preset) {
            self::PRESET_FREE => $this->buildFreeTier($options),
            self::PRESET_HYBRID => $this->buildHybrid($options),
            self::PRESET_HOSTED => $this->buildHosted($options),
            default => throw new RuntimeException(sprintf('Unknown pool preset "%s".', $preset)),
        };
    }

    /**
     * @param array<string, mixed> $options
     * @return array<int, array<int, array<string, mixed>>>
     */
    private function buildFreeTier(array $options): array
    {
        $ragieKey = $this->requireEnv('RAGIE_API_KEY');
        $defaults = $this->extractArrayOption($options, 'ragie_defaults');
        $partition = $this->resolvePartition($options);

        $pools = [];

        if ($cerebras = $this->buildCerebrasRotation($ragieKey, $defaults, $partition, $options)) {
            $pools[] = $cerebras;
        }

        $pools[] = $this->buildFreeRotation($ragieKey, $defaults, $partition, $options);

        return $pools;
    }

    /**
     * @param array<string, mixed> $options
     * @return array<int, array<int, array<string, mixed>>>
     */
    private function buildHybrid(array $options): array
    {
        $ragieKey = $this->requireEnv('RAGIE_API_KEY');
        $defaults = $this->extractArrayOption($options, 'ragie_defaults');
        $partition = $this->resolvePartition($options);

        $pools = [];

        if ($cerebras = $this->buildCerebrasRotation($ragieKey, $defaults, $partition, $options)) {
            $pools[] = $cerebras;
        }

        $pools[] = $this->buildFreeRotation($ragieKey, $defaults, $partition, $options);

        $pools[] = [
            $this->ragieCatalogEntry(
                slug: 'openai',
                apiKey: $this->requireEnv('OPENAI_API_KEY'),
                model: $this->resolveModel($options, 'openai_model', 'PARAGRA_OPENAI_MODEL', 'gpt-4o-mini', 'OPENAI_MODEL'),
                ragieKey: $ragieKey,
                partition: $partition,
                defaults: $defaults,
                metadata: [
                    'plan' => self::PRESET_HYBRID,
                    'tier' => 'paid',
                    'vector_store' => 'pinecone-starter',
                    'embedding_provider' => 'voyage-embeddings',
                ]
            ),
        ];

        return $pools;
    }

    /**
     * @param array<string, mixed> $options
     * @return array<int, array<int, array<string, mixed>>>
     */
    private function buildHosted(array $options): array
    {
        $askyodaKey = $this->requireEnv('EDENAI_API_KEY');
        $projectId = $this->requireEnv('EDENAI_ASKYODA_PROJECT');
        $defaults = $this->extractArrayOption($options, 'askyoda_options');
        $llm = $this->extractArrayOption($options, 'askyoda_llm');
        $askyodaInsight = $this->summarizeInsight('askyoda', 'eden-askyoda');

        $metadata = [
            'plan' => self::PRESET_HOSTED,
            'tier' => 'hosted',
            'latency_tier' => 'hosted',
            'insight' => $askyodaInsight,
            'hosted_recommendations' => [
                $this->summarizeInsight('vectara'),
                $this->summarizeInsight('bedrock-kb'),
            ],
        ];

        return [[
            [
                'catalog' => [
                    'slug' => 'askyoda',
                    'model_type' => 'generation',
                    'overrides' => [
                        'api_key' => $askyodaKey,
                        'solution' => [
                            'type' => 'askyoda',
                            'askyoda_api_key' => $askyodaKey,
                            'project_id' => $projectId,
                            'default_options' => $defaults,
                            'llm' => $llm,
                            'metadata' => $metadata,
                        ],
                    ],
                ],
            ],
        ]];
    }

    /**
     * @return array<int, array<string, mixed>>|null
     */
    private function buildCerebrasRotation(
        string $ragieKey,
        array $defaults,
        string $partition,
        array $options
    ): ?array {
        $keys = $this->envList('CEREBRAS_API_KEYS', 'CEREBRAS_API_KEY');
        if ($keys === []) {
            return null;
        }

        $model = $this->resolveModel($options, 'cerebras_model', 'CEREBRAS_MODEL', 'llama-3.3-70b');
        $pool = [];

        foreach ($keys as $index => $apiKey) {
            $pool[] = $this->ragieCatalogEntry(
                slug: 'cerebras',
                apiKey: $apiKey,
                model: $model,
                ragieKey: $ragieKey,
                partition: $partition,
                defaults: $defaults,
                metadata: [
                    'plan' => self::PRESET_FREE,
                    'tier' => 'free',
                    'slot' => $index + 1,
                    'embedding_provider' => 'google-gemini-embedding',
                    'vector_store' => 'qdrant-cloud-free',
                ]
            );
        }

        return $pool;
    }

    /**
     * @param array<string, mixed> $options
     * @return array<int, array<string, mixed>>
     */
    private function buildFreeRotation(string $ragieKey, array $defaults, string $partition, array $options): array
    {
        $geminiInsight = $this->summarizeInsight('gemini', 'google-gemini-file-search');
        $vectorStore = $this->resolveGeminiVectorStore($options);

        return [
            $this->ragieCatalogEntry(
                slug: 'gemini',
                apiKey: $this->requireEnv('GOOGLE_API_KEY'),
                model: $this->resolveModel($options, 'gemini_model', 'GEMINI_MODEL', 'gemini-2.0-flash-exp'),
                ragieKey: $ragieKey,
                partition: $partition,
                defaults: $defaults,
                metadata: [
                    'plan' => self::PRESET_FREE,
                    'tier' => 'free',
                    'embedding_provider' => 'google-gemini-embedding',
                    'vector_store' => 'qdrant-cloud-free',
                    'insight' => $geminiInsight,
                ],
                solutionOverrides: [
                    'type' => 'gemini-file-search',
                    'vector_store' => $vectorStore,
                    'google_api_key' => $this->requireEnv('GOOGLE_API_KEY'),
                ]
            ),
            $this->ragieCatalogEntry(
                slug: 'groq',
                apiKey: $this->requireEnv('GROQ_API_KEY'),
                model: $this->resolveModel($options, 'groq_model', 'GROQ_MODEL', 'llama-3.1-8b-instant'),
                ragieKey: $ragieKey,
                partition: $partition,
                defaults: $defaults,
                metadata: [
                    'plan' => self::PRESET_FREE,
                    'tier' => 'free',
                    'embedding_provider' => 'google-gemini-embedding',
                    'vector_store' => 'qdrant-cloud-free',
                    'insight' => $this->summarizeInsight('groq', 'groq-llama'),
                ]
            ),
        ];
    }

    /**
     * @param array<string, mixed> $metadata
     * @return array<string, mixed>
     */
    private function ragieCatalogEntry(
        string $slug,
        string $apiKey,
        string $model,
        string $ragieKey,
        string $partition,
        array $defaults,
        array $metadata,
        array $solutionOverrides = []
    ): array {
        $this->requireProvider($slug);

        $solution = array_replace_recursive([
            'type' => 'ragie',
            'ragie_api_key' => $ragieKey,
            'ragie_partition' => $partition,
            'default_options' => $defaults,
            'metadata' => array_filter($metadata, static fn (mixed $value): bool => $value !== null),
        ], $solutionOverrides);

        return [
            'catalog' => [
                'slug' => $slug,
                'model_type' => 'generation',
                'overrides' => [
                    'api_key' => $apiKey,
                    'model' => $model,
                    'solution' => $solution,
                ],
            ],
        ];
    }

    /**
     * @param array<string, mixed> $options
     */
    private function resolvePartition(array $options): string
    {
        if (isset($options['ragie_partition']) && is_string($options['ragie_partition']) && $options['ragie_partition'] !== '') {
            return $options['ragie_partition'];
        }

        return $this->env('RAGIE_PARTITION') ?? 'default';
    }

    /**
     * @param array<string, mixed> $options
     * @return array<string, mixed>
     */
    private function extractArrayOption(array $options, string $key): array
    {
        $value = $options[$key] ?? [];
        return is_array($value) ? $value : [];
    }

    /**
     * @return list<string>
     */
    private function envList(string $listKey, ?string $singleKey = null): array
    {
        $rawList = $this->env($listKey);
        if ($rawList !== null) {
            $parts = array_values(array_filter(array_map(
                static fn (string $value): string => trim($value),
                explode(',', $rawList)
            ), static fn (string $value): bool => $value !== ''));

            if ($parts !== []) {
                return $parts;
            }
        }

        if ($singleKey !== null) {
            $single = $this->env($singleKey);
            if ($single !== null) {
                return [$single];
            }
        }

        return [];
    }

    /**
     * @param array<string, mixed> $options
     */
    private function resolveModel(
        array $options,
        string $optionKey,
        string $envKey,
        string $default,
        ?string $fallbackEnvKey = null
    ): string {
        if (isset($options[$optionKey]) && is_string($options[$optionKey]) && trim($options[$optionKey]) !== '') {
            return trim($options[$optionKey]);
        }

        $env = $this->env($envKey);
        if ($env === null && $fallbackEnvKey !== null) {
            $env = $this->env($fallbackEnvKey);
        }

        return $env ?? $default;
    }

    private function summarizeInsight(string $slug, ?string $insightSlug = null): array
    {
        $summary = $this->requireProvider($slug);
        $metadata = $summary->metadata();
        $insights = $metadata['insights'] ?? [];
        if (!is_array($insights) || $insights === []) {
            return [
                'slug' => $slug,
                'name' => $summary->displayName(),
            ];
        }

        $selected = null;
        if ($insightSlug !== null && isset($insights[$insightSlug]) && is_array($insights[$insightSlug])) {
            $selected = $insights[$insightSlug];
        }

        if ($selected === null) {
            foreach ($insights as $entry) {
                if (is_array($entry)) {
                    $selected = $entry;
                    break;
                }
            }
        }

        if (!is_array($selected)) {
            return [
                'slug' => $slug,
                'name' => $summary->displayName(),
            ];
        }

        return [
            'slug' => isset($selected['slug']) && is_string($selected['slug']) ? $selected['slug'] : $slug,
            'name' => isset($selected['name']) && is_string($selected['name']) ? $selected['name'] : $summary->displayName(),
            'recommended_roles' => is_array($selected['recommended_roles'] ?? null)
                ? array_values($selected['recommended_roles'])
                : [],
            'free_tier' => is_array($selected['free_tier'] ?? null) ? $selected['free_tier'] : [],
        ];
    }

    /**
     * @param array<string, mixed> $options
     * @return array<string, string>|string
     */
    private function resolveGeminiVectorStore(array $options): array|string
    {
        if (isset($options['gemini_vector_store'])) {
            $override = $options['gemini_vector_store'];
            if (is_array($override) && $override !== []) {
                return $override;
            }
            if (is_string($override) && trim($override) !== '') {
                return trim($override);
            }
        }

        $datastore = $this->env('GEMINI_DATASTORE_ID');
        if ($datastore !== null) {
            return ['datastore' => $datastore];
        }

        $corpus = $this->env('GEMINI_CORPUS_ID');
        if ($corpus !== null) {
            return ['corpus' => $corpus];
        }

        $alias = $this->env('GEMINI_VECTOR_STORE');
        if ($alias !== null) {
            return trim($alias);
        }

        throw new RuntimeException(
            'Set GEMINI_DATASTORE_ID, GEMINI_CORPUS_ID, or GEMINI_VECTOR_STORE for Gemini File Search pools.'
        );
    }

    private function requireProvider(string $slug): ProviderSummary
    {
        $summary = $this->catalog->get($slug);
        if ($summary === null) {
            throw new RuntimeException(sprintf('Provider slug "%s" missing from catalog.', $slug));
        }

        return $summary;
    }

    private function requireEnv(string $key): string
    {
        $value = $this->env($key);
        if ($value === null) {
            throw new RuntimeException(sprintf('Missing required environment variable "%s".', $key));
        }

        return $value;
    }

    private function env(string $key): ?string
    {
        if (array_key_exists($key, $this->environment)) {
            $value = $this->environment[$key];
        } else {
            $value = getenv($key);
            if ($value === false || $value === null) {
                $value = $_ENV[$key] ?? $_SERVER[$key] ?? null;
            }
        }

        if (!is_string($value)) {
            return null;
        }

        $trimmed = trim($value);
        return $trimmed === '' ? null : $trimmed;
    }
}
</document_content>
</document>

<document index="70">
<source>src/ProviderCatalog/CapabilityMap.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ProviderCatalog/CapabilityMap.php

namespace ParaGra\ProviderCatalog;

use InvalidArgumentException;
use function array_diff;
use function array_key_exists;
use function array_keys;
use function implode;
use function sprintf;

/**
 * Normalized capability flags describing what a provider supports.
 */
final class CapabilityMap
{
    private const ALLOWED_KEYS = [
        'llm_chat',
        'embeddings',
        'vector_store',
        'moderation',
        'image_generation',
        'byok',
    ];

    /** @var array<string, bool> */
    private array $flags;

    /**
     * @param array<string, bool> $flags
     */
    private function __construct(array $flags)
    {
        $this->flags = $flags;
    }

    /**
     * Build the capability map from a raw array.
     *
     * Missing keys default to false, unknown keys trigger an exception
     * so we never silently ignore typos introduced by the sync script.
     *
     * @param array<string, mixed> $values
     */
    public static function fromArray(array $values): self
    {
        $flags = [];
        foreach (self::ALLOWED_KEYS as $key) {
            $flags[$key] = isset($values[$key]) ? (bool) $values[$key] : false;
        }

        $unknown = array_diff(array_keys($values), self::ALLOWED_KEYS);
        if ($unknown !== []) {
            throw new InvalidArgumentException(sprintf(
                'Unknown capability keys detected: %s',
                implode(', ', $unknown)
            ));
        }

        return new self($flags);
    }

    public function supports(string $capability): bool
    {
        if (!array_key_exists($capability, $this->flags)) {
            throw new InvalidArgumentException(sprintf('Capability "%s" is not tracked.', $capability));
        }

        return $this->flags[$capability];
    }

    public function llmChat(): bool
    {
        return $this->flags['llm_chat'];
    }

    public function embeddings(): bool
    {
        return $this->flags['embeddings'];
    }

    public function vectorStore(): bool
    {
        return $this->flags['vector_store'];
    }

    public function moderation(): bool
    {
        return $this->flags['moderation'];
    }

    public function imageGeneration(): bool
    {
        return $this->flags['image_generation'];
    }

    public function byok(): bool
    {
        return $this->flags['byok'];
    }

    /**
     * @return array<string, bool>
     */
    public function toArray(): array
    {
        return $this->flags;
    }
}
</document_content>
</document>

<document index="71">
<source>src/ProviderCatalog/ProviderDiscovery.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ProviderCatalog/ProviderDiscovery.php

namespace ParaGra\ProviderCatalog;

use JsonException;
use ParaGra\Config\ProviderSpec;
use ParaGra\Exception\ConfigurationException;
use RuntimeException;
use function array_filter;
use function array_key_exists;
use function array_map;
use function array_replace_recursive;
use function array_values;
use function file_get_contents;
use function getenv;
use function in_array;
use function is_array;
use function is_file;
use function sprintf;
use function str_ends_with;
use function trim;
use const JSON_THROW_ON_ERROR;

/**
 * Catalog-aware helper that exposes lookups + ProviderSpec builders.
 */
final class ProviderDiscovery
{
    /** @var array<string, ProviderSummary> */
    private array $providers = [];

    /**
     * @param iterable<ProviderSummary> $providers
     */
    public function __construct(iterable $providers)
    {
        foreach ($providers as $provider) {
            $this->providers[$provider->slug()] = $provider;
        }
    }

    public static function fromFile(string $path): self
    {
        if (!is_file($path)) {
            throw new RuntimeException(sprintf('Catalog file "%s" not found.', $path));
        }

        if (str_ends_with($path, '.php')) {
            /** @var array<string, mixed> $catalog */
            $catalog = require $path;
        } else {
            $contents = file_get_contents($path);
            if ($contents === false) {
                throw new RuntimeException(sprintf('Unable to read catalog file "%s".', $path));
            }

            try {
                /** @var array<string, mixed> $catalog */
                $catalog = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);
            } catch (JsonException $e) {
                throw new RuntimeException(sprintf('Invalid catalog JSON: %s', $e->getMessage()), 0, $e);
            }
        }

        return self::fromCatalogArray($catalog);
    }

    /**
     * @param array<string, mixed> $catalog
     */
    public static function fromCatalogArray(array $catalog): self
    {
        if (!array_key_exists('providers', $catalog) || !is_array($catalog['providers'])) {
            throw new RuntimeException('Catalog payload missing "providers" array.');
        }

        $providers = array_map(
            static fn (array $provider): ProviderSummary => ProviderSummary::fromArray($provider),
            $catalog['providers']
        );

        return new self($providers);
    }

    /**
     * @return list<ProviderSummary>
     */
    public function listProviders(): array
    {
        return array_values($this->providers);
    }

    public function get(string $slug): ?ProviderSummary
    {
        return $this->providers[$slug] ?? null;
    }

    /**
     * @return list<ProviderSummary>
     */
    public function filterByCapability(string $capability): array
    {
        return array_values(array_filter(
            $this->providers,
            static fn (ProviderSummary $summary): bool => $summary->capabilities()->supports($capability)
        ));
    }

    public function supportsEmbeddingDimension(string $slug, int $dimension): bool
    {
        $summary = $this->providers[$slug] ?? null;
        if ($summary === null) {
            return false;
        }

        return in_array($dimension, $summary->embeddingDimensions(), true);
    }

    public function preferredVectorStore(string $slug): ?string
    {
        $summary = $this->providers[$slug] ?? null;

        return $summary?->preferredVectorStore();
    }

    /**
     * Build a ProviderSpec for the given provider slug.
     *
     * @param array<string, mixed> $overrides Supports `model`, `api_key`, and nested `solution` overrides.
     */
    public function buildProviderSpec(string $slug, string $modelType = 'generation', array $overrides = []): ProviderSpec
    {
        $summary = $this->get($slug);
        if ($summary === null) {
            throw ConfigurationException::invalid('provider', sprintf('Unknown provider slug "%s".', $slug));
        }

        $model = $overrides['model'] ?? ($summary->defaultModels()[$modelType] ?? null);
        if ($model === null) {
            throw ConfigurationException::invalid(
                'model',
                sprintf('Provider "%s" does not declare a "%s" model preset.', $slug, $modelType)
            );
        }

        $apiKey = $overrides['api_key'] ?? $this->resolveApiKey($summary);

        $solution = $summary->defaultSolution() ?? [
            'type' => 'ragie',
            'metadata' => $summary->metadata(),
        ];

        if (isset($overrides['solution']) && is_array($overrides['solution'])) {
            $solution = array_replace_recursive($solution, $overrides['solution']);
        }

        return ProviderSpec::fromArray([
            'provider' => $summary->slug(),
            'model' => (string) $model,
            'api_key' => (string) $apiKey,
            'solution' => $solution,
        ]);
    }

    private function resolveApiKey(ProviderSummary $summary): string
    {
        $env = $summary->apiKeyEnv();
        if ($env === null) {
            throw ConfigurationException::invalid(
                'api_key_env',
                sprintf('Provider "%s" does not expose an api_key_env value.', $summary->slug())
            );
        }

        $value = getenv($env);
        if ($value === false) {
            throw ConfigurationException::missingEnv($env);
        }

        $trimmed = trim((string) $value);
        if ($trimmed === '') {
            throw ConfigurationException::emptyEnv($env);
        }

        return $trimmed;
    }
}
</document_content>
</document>

<document index="72">
<source>src/ProviderCatalog/ProviderSummary.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ProviderCatalog/ProviderSummary.php

namespace ParaGra\ProviderCatalog;

use InvalidArgumentException;
use function array_filter;
use function array_key_exists;
use function array_map;
use function array_values;
use function count;
use function is_array;
use function is_int;
use function is_string;
use function sprintf;
use function trim;

/**
 * Immutable view of a provider entry returned by the catalog sync script.
 */
final class ProviderSummary
{
    /**
     * @param list<string> $models
     * @param array<string, int> $embeddingDimensions
     * @param array<string, string> $defaultModels
     * @param array<string, mixed> $metadata
     */
    private function __construct(
        private readonly string $slug,
        private readonly string $displayName,
        private readonly string $description,
        private readonly ?string $apiKeyEnv,
        private readonly ?string $baseUrl,
        private readonly CapabilityMap $capabilities,
        private readonly int $modelCount,
        private readonly array $models,
        private readonly array $embeddingDimensions,
        private readonly ?string $preferredVectorStore,
        private readonly array $defaultModels,
        private readonly ?array $defaultSolution,
        private readonly array $metadata,
    ) {
    }

    /**
     * @param array<string, mixed> $data
     */
    public static function fromArray(array $data): self
    {
        foreach (['slug', 'display_name', 'capabilities'] as $required) {
            if (!array_key_exists($required, $data)) {
                throw new InvalidArgumentException(sprintf('Missing provider field "%s".', $required));
            }
        }

        return new self(
            slug: self::sanitizeString($data['slug'], 'slug'),
            displayName: self::sanitizeString($data['display_name'], 'display_name'),
            description: isset($data['description']) ? trim((string) $data['description']) : '',
            apiKeyEnv: isset($data['api_key_env']) && $data['api_key_env'] !== '' ? (string) $data['api_key_env'] : null,
            baseUrl: isset($data['base_url']) && $data['base_url'] !== '' ? (string) $data['base_url'] : null,
            capabilities: CapabilityMap::fromArray((array) $data['capabilities']),
            modelCount: isset($data['model_count']) ? (int) $data['model_count'] : count(self::normalizeModels($data['models'] ?? [])),
            models: self::normalizeModels($data['models'] ?? []),
            embeddingDimensions: self::normalizeEmbeddingDimensions($data['embedding_dimensions'] ?? []),
            preferredVectorStore: isset($data['preferred_vector_store']) && $data['preferred_vector_store'] !== ''
                ? (string) $data['preferred_vector_store']
                : null,
            defaultModels: self::normalizeDefaultModels($data['default_models'] ?? []),
            defaultSolution: isset($data['default_solution']) && is_array($data['default_solution'])
                ? $data['default_solution']
                : null,
            metadata: self::normalizeMetadata($data['metadata'] ?? []),
        );
    }

    public function slug(): string
    {
        return $this->slug;
    }

    public function displayName(): string
    {
        return $this->displayName;
    }

    public function description(): string
    {
        return $this->description;
    }

    public function apiKeyEnv(): ?string
    {
        return $this->apiKeyEnv;
    }

    public function baseUrl(): ?string
    {
        return $this->baseUrl;
    }

    public function capabilities(): CapabilityMap
    {
        return $this->capabilities;
    }

    public function modelCount(): int
    {
        return $this->modelCount;
    }

    /**
     * @return list<string>
     */
    public function models(): array
    {
        return $this->models;
    }

    /**
     * @return array<string, int>
     */
    public function embeddingDimensions(): array
    {
        return $this->embeddingDimensions;
    }

    public function preferredVectorStore(): ?string
    {
        return $this->preferredVectorStore;
    }

    /**
     * @return array<string, string>
     */
    public function defaultModels(): array
    {
        return $this->defaultModels;
    }

    /**
     * @return array<string, mixed>|null
     */
    public function defaultSolution(): ?array
    {
        return $this->defaultSolution;
    }

    /**
     * @return array<string, mixed>
     */
    public function metadata(): array
    {
        return $this->metadata;
    }

    /**
     * @param array<int|string, mixed> $models
     * @return list<string>
     */
    private static function normalizeModels(array $models): array
    {
        if ($models === []) {
            return [];
        }

        $normalized = array_map(
            static fn (mixed $value): string => (string) $value,
            array_values($models)
        );

        return array_values(array_filter($normalized, static fn (string $value): bool => $value !== ''));
    }

    /**
     * @param array<string, mixed> $dimensions
     * @return array<string, int>
     */
    private static function normalizeEmbeddingDimensions(array $dimensions): array
    {
        $normalized = [];
        foreach ($dimensions as $model => $dimension) {
            if (!is_string($model)) {
                continue;
            }
            if (!is_int($dimension)) {
                $dimension = (int) $dimension;
            }
            if ($dimension > 0) {
                $normalized[$model] = $dimension;
            }
        }

        return $normalized;
    }

    /**
     * @param array<string, mixed> $defaults
     * @return array<string, string>
     */
    private static function normalizeDefaultModels(array $defaults): array
    {
        $normalized = [];
        foreach ($defaults as $key => $value) {
            if (is_string($key) && $value !== null && $value !== '') {
                $normalized[$key] = (string) $value;
            }
        }

        return $normalized;
    }

    /**
     * @param array<string, mixed> $metadata
     * @return array<string, mixed>
     */
    private static function normalizeMetadata(array $metadata): array
    {
        return $metadata;
    }

    private static function sanitizeString(mixed $value, string $field): string
    {
        if (!is_string($value)) {
            throw new InvalidArgumentException(sprintf('The "%s" value must be a string.', $field));
        }

        $trimmed = trim($value);
        if ($trimmed === '') {
            throw new InvalidArgumentException(sprintf('The "%s" value cannot be empty.', $field));
        }

        return $trimmed;
    }
}
</document_content>
</document>

<document index="73">
<source>src/Providers/AbstractProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/AbstractProvider.php

namespace ParaGra\Providers;

use InvalidArgumentException;
use ParaGra\Config\ProviderSpec;

use function array_filter;
use function array_map;
use function array_unique;
use function array_values;
use function in_array;
use function sprintf;
use function strtolower;
use function trim;

/**
 * Convenience base class that wires a ProviderSpec into the ProviderInterface
 * and offers capability helpers plus shared metadata utilities.
 */
abstract class AbstractProvider implements ProviderInterface
{
    /** @var list<string> */
    private array $capabilities;

    public function __construct(
        private readonly ProviderSpec $spec,
        array $capabilities = []
    ) {
        $this->capabilities = $this->normalizeCapabilities($capabilities);
    }

    #[\Override]
    public function getProvider(): string
    {
        return $this->spec->provider;
    }

    #[\Override]
    public function getModel(): string
    {
        return $this->spec->model;
    }

    #[\Override]
    public function getCapabilities(): array
    {
        return $this->capabilities;
    }

    #[\Override]
    public function supports(string $capability): bool
    {
        return in_array(strtolower($capability), $this->capabilities, true);
    }

    /**
     * Downstream providers often need the full config (API key, solution data).
     */
    final protected function getSpec(): ProviderSpec
    {
        return $this->spec;
    }

    /**
     * Shortcut for retrieving provider-specific solution configuration.
     *
     * @return array<string, mixed>
     */
    final protected function getSolution(): array
    {
        return $this->spec->solution;
    }

    /**
     * Trim and validate incoming queries before dispatching upstream.
     */
    final protected function sanitizeQuery(string $query): string
    {
        $trimmed = trim($query);
        if ($trimmed === '') {
            throw new InvalidArgumentException('Query text cannot be empty.');
        }

        return $trimmed;
    }

    /**
     * Common metadata payload that every UnifiedResponse should include.
     *
     * @return array<string, string>
     */
    final protected function baseMetadata(): array
    {
        return [
            'provider' => $this->getProvider(),
            'model' => $this->getModel(),
        ];
    }

    /**
     * Helper used by descendants to throw consistent errors.
     */
    final protected function invalidOption(string $name, string $reason): InvalidArgumentException
    {
        return new InvalidArgumentException(sprintf('Invalid option "%s": %s', $name, $reason));
    }

    /**
     * @param array<string> $capabilities
     *
     * @return list<string>
     */
    private function normalizeCapabilities(array $capabilities): array
    {
        $normalized = array_map(static fn(string $capability): string => strtolower(trim($capability)), $capabilities);
        $normalized = array_filter($normalized, static fn(string $capability): bool => $capability !== '');

        /** @var list<string> $unique */
        $unique = array_values(array_unique($normalized));

        return $unique;
    }
}
</document_content>
</document>

<document index="74">
<source>src/Providers/AskYodaProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/AskYodaProvider.php

namespace ParaGra\Providers;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\ClientInterface;
use ParaGra\Config\ProviderSpec;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use const JSON_THROW_ON_ERROR;

use function array_filter;
use function array_map;
use function array_merge;
use function array_values;
use function is_array;
use function is_string;
use function json_decode;
use function sprintf;
use function trim;

final class AskYodaProvider extends AbstractProvider
{
    private const BASE_URI = 'https://api.edenai.run';

    private ClientInterface $httpClient;

    /**
     * @param array<string, mixed> $config
     */
    public function __construct(
        ProviderSpec $spec,
        ?ClientInterface $httpClient = null,
        private readonly array $config = [],
    ) {
        parent::__construct($spec, $config['capabilities'] ?? ['retrieval', 'llm_generation']);
        $this->httpClient = $httpClient ?? new HttpClient([
            'base_uri' => self::BASE_URI,
            'timeout' => 30,
        ]);
    }

    #[\Override]
    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        $clean = $this->sanitizeQuery($query);
        $payload = $this->buildPayload($clean, $options);
        $endpoint = sprintf('/v2/aiproducts/askyoda/v2/%s/ask_llm/', $this->getProjectId());

        $response = $this->httpClient->request('POST', $endpoint, [
            'headers' => [
                'Authorization' => 'Bearer ' . $this->getApiKey(),
                'Content-Type' => 'application/json',
            ],
            'json' => $payload,
        ]);

        /** @var array<string, mixed> $data */
        $data = json_decode((string) $response->getBody(), true, 512, JSON_THROW_ON_ERROR);
        $chunks = $this->normalizeChunks($data);

        $usage = $this->extractUsage($data['usage'] ?? null);
        $cost = isset($data['cost'])
            ? [
                'amount' => (float) $data['cost'],
                'currency' => $this->config['currency'] ?? 'USD',
            ]
            : null;

        $metadata = array_filter(array_merge(
            $this->baseMetadata(),
            [
                'solution_type' => 'askyoda',
                'answer' => $data['result'] ?? null,
                'llm_provider' => $data['llm_provider'] ?? null,
                'llm_model' => $data['llm_model'] ?? null,
            ],
            $this->config['metadata'] ?? []
        ));

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $this->getModel(),
            chunks: $chunks,
            metadata: $metadata,
            usage: $usage,
            cost: $cost,
        );
    }

    /**
     * @return array<string, mixed>
     */
    private function buildPayload(string $query, array $options): array
    {
        $defaults = $this->config['default_options'] ?? [];
        $merged = array_merge($defaults, $options);

        $payload = [
            'query' => $query,
            'k' => $merged['k'] ?? 10,
            'min_score' => $merged['min_score'] ?? 0.3,
            'temperature' => $merged['temperature'] ?? 0.99,
            'max_tokens' => $merged['max_tokens'] ?? 8000,
            'include_payload' => $merged['include_payload'] ?? true,
        ];

        $llmConfig = array_merge(
            $this->config['llm'] ?? [],
            $merged['llm'] ?? []
        );

        if (isset($llmConfig['provider'])) {
            $payload['llm_provider'] = $llmConfig['provider'];
        }

        if (isset($llmConfig['model'])) {
            $payload['llm_model'] = $llmConfig['model'];
        }

        if (isset($merged['system_prompt'])) {
            $payload['system_prompt'] = $merged['system_prompt'];
        }

        return $payload;
    }

    /**
     * @param array<string, mixed> $data
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeChunks(array $data): array
    {
        $chunks = $data['chunks'] ?? [];
        if (!is_array($chunks) || $chunks === []) {
            return $this->buildChunkPlaceholders($data['chunks_ids'] ?? []);
        }

        return array_values(array_filter(array_map(
            function (array $chunk): ?array {
                $text = $this->extractChunkText($chunk);
                if ($text === null) {
                    return null;
                }

                $normalized = [
                    'text' => $text,
                ];

                if (isset($chunk['score'])) {
                    $normalized['score'] = (float) $chunk['score'];
                }

                if (isset($chunk['chunk_id'])) {
                    $normalized['document_id'] = (string) $chunk['chunk_id'];
                }

                if (isset($chunk['metadata']) && is_array($chunk['metadata'])) {
                    $normalized['metadata'] = $chunk['metadata'];
                }

                return $normalized;
            },
            $chunks
        )));
    }

    /**
     * @param array<int, string> $chunkIds
     *
     * @return list<array<string, string>>
     */
    private function buildChunkPlaceholders(array $chunkIds): array
    {
        $chunkIds = array_filter($chunkIds, static fn ($id): bool => is_string($id) && trim($id) !== '');

        return array_values(array_map(
            function (string $id): array {
                $cleanId = trim($id);

                return [
                    'text' => sprintf('Chunk %s', $cleanId),
                    'metadata' => ['chunk_id' => $cleanId],
                ];
            },
            $chunkIds
        ));
    }

    private function extractChunkText(array $chunk): ?string
    {
        $payload = $chunk['payload'] ?? $chunk['chunk'] ?? null;
        if (is_string($payload)) {
            $payload = ['text' => $payload];
        }

        if (is_array($payload)) {
            $text = $payload['text']
                ?? $payload['content']
                ?? null;
            if (is_string($text)) {
                $clean = trim($text);
                return $clean === '' ? null : $clean;
            }
        }

        if (isset($chunk['chunk_text']) && is_string($chunk['chunk_text'])) {
            $clean = trim($chunk['chunk_text']);
            return $clean === '' ? null : $clean;
        }

        return null;
    }

    /**
     * @param array<string, mixed>|null $usage
     *
     * @return array<string, int>|null
     */
    private function extractUsage(?array $usage): ?array
    {
        if ($usage === null) {
            return null;
        }

        $input = isset($usage['input_tokens']) ? (int) $usage['input_tokens'] : null;
        $output = isset($usage['output_tokens']) ? (int) $usage['output_tokens'] : null;
        $total = isset($usage['total_tokens']) ? (int) $usage['total_tokens'] : null;

        return array_filter([
            'input_tokens' => $input,
            'output_tokens' => $output,
            'total_tokens' => $total,
        ], static fn ($value) => $value !== null);
    }

    private function getApiKey(): string
    {
        $solution = $this->getSolution();
        $key = $this->config['askyoda_api_key']
            ?? $solution['askyoda_api_key']
            ?? $solution['api_key']
            ?? null;

        if (!is_string($key) || trim($key) === '') {
            throw new RuntimeException('AskYoda API key is missing.');
        }

        return $key;
    }

    private function getProjectId(): string
    {
        $solution = $this->getSolution();
        $projectId = $this->config['project_id'] ?? $solution['project_id'] ?? null;
        if (!is_string($projectId) || trim($projectId) === '') {
            throw new RuntimeException('AskYoda project_id is missing.');
        }

        return trim($projectId);
    }
}
</document_content>
</document>

<document index="75">
<source>src/Providers/GeminiFileSearchProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/GeminiFileSearchProvider.php

namespace ParaGra\Providers;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\ClientInterface;
use ParaGra\Config\ProviderSpec;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use const JSON_THROW_ON_ERROR;

use function array_filter;
use function array_map;
use function array_merge;
use function array_values;
use function count;
use function implode;
use function is_array;
use function is_string;
use function json_decode;
use function ltrim;
use function rawurlencode;
use function sprintf;
use function str_starts_with;
use function trim;

final class GeminiFileSearchProvider extends AbstractProvider
{
    private ClientInterface $httpClient;

    /**
     * @param array<string, mixed> $config
     */
    public function __construct(
        ProviderSpec $spec,
        ?ClientInterface $httpClient = null,
        private readonly array $config = [],
    ) {
        parent::__construct($spec, $config['capabilities'] ?? ['retrieval']);
        $this->httpClient = $httpClient ?? new HttpClient([
            'base_uri' => 'https://generativelanguage.googleapis.com',
            'timeout' => 30,
        ]);
    }

    #[\Override]
    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        $clean = $this->sanitizeQuery($query);
        $payload = $this->buildPayload($clean, $options);

        $response = $this->httpClient->request('POST', $this->buildEndpoint(), [
            'headers' => [
                'Content-Type' => 'application/json',
            ],
            'json' => $payload,
        ]);

        /** @var array<string, mixed> $data */
        $data = json_decode((string) $response->getBody(), true, 512, JSON_THROW_ON_ERROR);
        $chunks = $this->extractChunks($data);

        $metadata = array_filter(array_merge(
            $this->baseMetadata(),
            [
                'solution_type' => 'gemini-file-search',
                'answer' => $data['candidates'][0]['content']['parts'][0]['text'] ?? null,
                'source_count' => count($chunks),
            ],
            $this->config['metadata'] ?? []
        ));

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $this->getModel(),
            chunks: $chunks,
            metadata: $metadata,
            usage: $this->extractUsage($data['usageMetadata'] ?? null),
        );
    }

    /**
     * @return array<string, mixed>
     */
    private function buildPayload(string $query, array $options): array
    {
        $vectorStoreName = $this->resolveVectorStoreName(
            $this->config['vector_store']
            ?? $this->getSolution()['vector_store']
            ?? null
        );

        $generation = array_merge(
            $this->config['generation'] ?? [],
            $options['generation'] ?? []
        );

        return [
            'contents' => [
                [
                    'role' => 'user',
                    'parts' => [
                        ['text' => $query],
                    ],
                ],
            ],
            'tools' => [
                ['fileSearch' => new \stdClass()],
            ],
            'toolConfig' => [
                'fileSearch' => [
                    'vectorStore' => [
                        ['name' => $vectorStoreName],
                    ],
                ],
            ],
            'generationConfig' => [
                'temperature' => $generation['temperature'] ?? 0.2,
                'maxOutputTokens' => $generation['max_output_tokens'] ?? 1024,
            ],
            'safetySettings' => $this->config['safety'] ?? [],
        ];
    }

    /**
     * @return list<array<string, mixed>>
     */
    private function extractChunks(array $data): array
    {
        $entries = $data['candidates'][0]['groundingMetadata']['searchEntries'] ?? [];
        if (!is_array($entries) || $entries === []) {
            return [];
        }

        return array_values(array_filter(array_map(
            function (array $entry): ?array {
                $chunk = $entry['chunk'] ?? [];
                $parts = $chunk['content']['parts'] ?? [];
                $textParts = array_filter(array_map(
                    static fn (array $part): ?string => isset($part['text']) ? trim((string) $part['text']) : null,
                    is_array($parts) ? $parts : []
                ));
                $text = trim(implode(' ', $textParts));
                if ($text === '') {
                    return null;
                }

                $normalized = [
                    'text' => $text,
                ];

                $score = $entry['score']
                    ?? $chunk['relevanceScore']
                    ?? null;
                if ($score !== null) {
                    $normalized['score'] = (float) $score;
                }

                $metadata = array_filter([
                    'chunk_id' => $chunk['chunkId'] ?? null,
                    'source' => $chunk['source'] ?? null,
                    'uri' => $entry['uri'] ?? null,
                    'title' => $entry['title'] ?? null,
                ], static fn ($value): bool => $value !== null && $value !== '');

                if ($metadata !== []) {
                    $normalized['metadata'] = $metadata;
                }

                return $normalized;
            },
            $entries
        )));
    }

    /**
     * @param array<string, int>|null $usage
     *
     * @return array<string, int>|null
     */
    private function extractUsage(?array $usage): ?array
    {
        if ($usage === null) {
            return null;
        }

        return array_filter([
            'prompt_tokens' => $usage['promptTokenCount'] ?? null,
            'output_tokens' => $usage['candidatesTokenCount'] ?? null,
            'total_tokens' => $usage['totalTokenCount'] ?? null,
        ], static fn ($value): bool => $value !== null);
    }

    private function buildEndpoint(): string
    {
        $apiKey = $this->apiKey();

        return sprintf(
            '/v1beta/models/%s:generateContent?key=%s',
            rawurlencode($this->getModel()),
            rawurlencode($apiKey)
        );
    }

    private function apiKey(): string
    {
        $key = $this->config['google_api_key'] ?? $this->getSolution()['google_api_key'] ?? $this->getSolution()['api_key'] ?? $this->config['api_key'] ?? null;
        if (!is_string($key) || trim($key) === '') {
            throw new RuntimeException('A Gemini API key is required.');
        }

        return trim($key);
    }

    /**
     * @param array<string, mixed>|string|null $vectorStore
     */
    private function resolveVectorStoreName(array|string|null $vectorStore): string
    {
        if ($vectorStore === null) {
            throw new RuntimeException('Gemini File Search requires a "vector_store" entry.');
        }

        if (is_string($vectorStore)) {
            return $this->normalizeVectorStoreName($vectorStore);
        }

        if (!is_array($vectorStore)) {
            throw new RuntimeException('Gemini File Search vector_store must be a string or array.');
        }

        $candidates = [
            $vectorStore['name'] ?? null,
            $vectorStore['resource'] ?? null,
            $vectorStore['datastore'] ?? null,
            $vectorStore['corpus'] ?? null,
            $vectorStore['vector_store'] ?? null,
        ];

        foreach ($candidates as $value) {
            if (is_string($value) && trim($value) !== '') {
                return $this->normalizeVectorStoreName($value);
            }
        }

        throw new RuntimeException(
            'Gemini File Search vector_store must include a "name", "datastore", or "corpus" value.'
        );
    }

    private function normalizeVectorStoreName(string $value): string
    {
        $clean = trim($value);
        if ($clean === '') {
            throw new RuntimeException('Gemini File Search vector_store cannot be empty.');
        }

        $clean = ltrim($clean, '/');

        if (
            str_starts_with($clean, 'fileSearchStores/')
            || str_starts_with($clean, 'corpora/')
            || str_starts_with($clean, 'projects/')
        ) {
            return $clean;
        }

        return sprintf('fileSearchStores/%s', $clean);
    }
}
</document_content>
</document>

<document index="76">
<source>src/Providers/ProviderFactory.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/ProviderFactory.php

namespace ParaGra\Providers;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\ClientInterface;
use InvalidArgumentException;
use ParaGra\Config\ProviderSpec;
use ParaGra\Llm\NeuronAiAdapter;
use Ragie\Client as RagieClient;

use function array_replace;
use function is_string;
use function sprintf;
use function strtolower;
use function trim;

final class ProviderFactory
{
    /**
     * @var callable(ProviderSpec): RagieClient
     */
    private $ragieClientFactory;

    /**
     * @var callable(array<string, mixed>): ClientInterface
     */
    private $httpClientFactory;

    /**
     * @var callable(ProviderSpec): NeuronAiAdapter
     */
    private $neuronFactory;

    /**
     * @param callable(ProviderSpec): RagieClient|null $ragieClientFactory
     * @param callable(array<string, mixed>): ClientInterface|null $httpClientFactory
     * @param callable(ProviderSpec): NeuronAiAdapter|null $neuronFactory
     */
    public function __construct(
        ?callable $ragieClientFactory = null,
        ?callable $httpClientFactory = null,
        ?callable $neuronFactory = null,
    ) {
        $this->ragieClientFactory = $ragieClientFactory ?? static function (ProviderSpec $spec): RagieClient {
            $solution = $spec->solution;
            $apiKey = $solution['ragie_api_key'] ?? $solution['api_key'] ?? null;
            if (!is_string($apiKey) || trim($apiKey) === '') {
                throw new InvalidArgumentException('Ragie provider requires a ragie_api_key in solution config.');
            }

            $baseUrl = $solution['ragie_base_url'] ?? null;

            return new RagieClient(
                $apiKey,
                is_string($baseUrl) ? $baseUrl : null
            );
        };

        $this->httpClientFactory = $httpClientFactory ?? static fn (array $config = []): ClientInterface => new HttpClient(array_replace([
            'timeout' => 30,
        ], $config));

        $this->neuronFactory = $neuronFactory ?? static fn (ProviderSpec $spec): NeuronAiAdapter => new NeuronAiAdapter(
            provider: $spec->provider,
            model: $spec->model,
            apiKey: $spec->apiKey,
            parameters: $spec->solution['llm_parameters'] ?? [],
            systemPrompt: $spec->solution['system_prompt'] ?? null,
        );
    }

    public function createProvider(ProviderSpec $spec): ProviderInterface
    {
        $type = strtolower((string) ($spec->solution['type'] ?? $spec->provider));

        return match ($type) {
            'ragie' => $this->createRagieProvider($spec),
            'gemini-file-search', 'gemini_file_search' => $this->createGeminiProvider($spec),
            'askyoda' => $this->createAskYodaProvider($spec),
            default => throw new InvalidArgumentException(sprintf('Unsupported provider solution "%s".', $type)),
        };
    }

    public function createLlmClient(ProviderSpec $spec): NeuronAiAdapter
    {
        return ($this->neuronFactory)($spec);
    }

    private function createRagieProvider(ProviderSpec $spec): RagieProvider
    {
        $client = ($this->ragieClientFactory)($spec);

        return new RagieProvider(
            $spec,
            $client,
            [
                'default_options' => $spec->solution['default_options'] ?? [],
                'metadata' => $spec->solution['metadata'] ?? [],
            ]
        );
    }

    private function createGeminiProvider(ProviderSpec $spec): GeminiFileSearchProvider
    {
        $client = ($this->httpClientFactory)([
            'base_uri' => 'https://generativelanguage.googleapis.com',
            'timeout' => 30,
        ]);

        return new GeminiFileSearchProvider(
            $spec,
            $client,
            [
                'vector_store' => $spec->solution['vector_store'] ?? null,
                'generation' => $spec->solution['generation'] ?? [],
                'safety' => $spec->solution['safety'] ?? [],
                'metadata' => $spec->solution['metadata'] ?? [],
                'api_key' => $spec->solution['api_key'] ?? $spec->apiKey,
            ]
        );
    }

    private function createAskYodaProvider(ProviderSpec $spec): AskYodaProvider
    {
        $client = ($this->httpClientFactory)([
            'base_uri' => 'https://api.edenai.run',
            'timeout' => 30,
        ]);

        return new AskYodaProvider(
            $spec,
            $client,
            [
                'askyoda_api_key' => $spec->solution['askyoda_api_key'] ?? null,
                'project_id' => $spec->solution['project_id'] ?? null,
                'default_options' => $spec->solution['default_options'] ?? [],
                'metadata' => $spec->solution['metadata'] ?? [],
                'llm' => $spec->solution['llm'] ?? [],
            ]
        );
    }
}
</document_content>
</document>

<document index="77">
<source>src/Providers/ProviderInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/ProviderInterface.php

namespace ParaGra\Providers;

use ParaGra\Response\UnifiedResponse;

/**
 * Contract that every retrieval-capable provider must implement so
 * ParaGra can treat Ragie, Gemini File Search, AskYoda, or anything else
 * through the same entry points.
 */
interface ProviderInterface
{
    /**
     * Machine-friendly provider slug such as "ragie" or "gemini-file-search".
     */
    public function getProvider(): string;

    /**
     * Model identifier reported by the upstream provider (e.g. gpt-4o-mini).
     */
    public function getModel(): string;

    /**
     * Capabilities advertised by this provider (retrieval, rerank, llm_generation, etc.).
     *
     * @return list<string>
     */
    public function getCapabilities(): array;

    /**
     * Whether a given capability is supported (case-insensitive lookup).
     */
    public function supports(string $capability): bool;

    /**
     * Execute a retrieval request and return the normalized response bundle.
     *
     * @param array<string, mixed> $options Provider-specific tuning parameters
     */
    public function retrieve(string $query, array $options = []): UnifiedResponse;
}
</document_content>
</document>

<document index="78">
<source>src/Providers/RagieProvider.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Providers/RagieProvider.php

namespace ParaGra\Providers;

use ParaGra\Config\ProviderSpec;
use ParaGra\Response\UnifiedResponse;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Client as RagieClient;
use Ragie\RetrievalOptions;
use Ragie\RetrievalResult;

use function array_filter;
use function array_map;
use function array_merge;
use function array_replace_recursive;
use function array_values;
use function count;
use function is_array;
use function trim;

/**
 * Adapter that turns Ragie's RetrievalResult payloads into UnifiedResponse objects.
 */
final class RagieProvider extends AbstractProvider
{
    /**
     * @param array<string, mixed> $config
     */
    public function __construct(
        ProviderSpec $spec,
        private readonly RagieClient $client,
        private readonly array $config = [],
    ) {
        parent::__construct($spec, $config['capabilities'] ?? ['retrieval']);
    }

    #[\Override]
    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        $clean = $this->sanitizeQuery($query);
        $mergedOptions = $this->mergeOptions($options);
        $retrievalOptions = $this->buildRetrievalOptions($mergedOptions);

        $result = $this->client->retrieve($clean, $retrievalOptions);

        $metadata = array_merge(
            $this->baseMetadata(),
            [
                'solution_type' => $this->getSolution()['type'] ?? 'ragie',
                'chunk_count' => $result->count(),
            ],
            $this->config['metadata'] ?? []
        );

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $this->getModel(),
            chunks: $this->normalizeChunks($result),
            metadata: $metadata
        );
    }

    /**
     * @param array<string, mixed> $options
     *
     * @return array<string, mixed>
     */
    private function mergeOptions(array $options): array
    {
        $defaults = $this->config['default_options'] ?? [];

        return array_replace_recursive($defaults, $options);
    }

    /**
     * @param array<string, mixed> $options
     */
    private function buildRetrievalOptions(array $options): RetrievalOptions
    {
        $retrieval = RetrievalOptions::create();

        if (isset($options['top_k'])) {
            $retrieval = $retrieval->withTopK((int) $options['top_k']);
        }

        if (isset($options['filter']) && is_array($options['filter'])) {
            $retrieval = $retrieval->withFilter($options['filter']);
        }

        if (array_key_exists('rerank', $options)) {
            $retrieval = $retrieval->withRerank((bool) $options['rerank']);
        }

        if (isset($options['max_chunks_per_document'])) {
            $retrieval = $retrieval->withMaxChunksPerDocument((int) $options['max_chunks_per_document']);
        }

        $partition = $options['partition']
            ?? $this->getSolution()['ragie_partition']
            ?? $this->config['partition']
            ?? null;

        if ($partition !== null) {
            $retrieval = $retrieval->withPartition($partition);
        }

        if (array_key_exists('recency_bias', $options)) {
            $retrieval = $retrieval->withRecencyBias((bool) $options['recency_bias']);
        }

        return $retrieval;
    }

    /**
     * @return list<array<string, mixed>>
     */
    private function normalizeChunks(RetrievalResult $result): array
    {
        $chunks = $result->getChunks();

        return array_values(array_filter(array_map(
            function (ScoredChunk $chunk): ?array {
                $text = trim((string) ($chunk->getText() ?? ''));
                if ($text === '') {
                    return null;
                }

                $normalized = [
                    'text' => $text,
                ];

                $score = $chunk->getScore();
                if ($score !== null) {
                    $normalized['score'] = (float) $score;
                }

                $documentId = $chunk->getDocumentId();
                if ($documentId !== null && trim($documentId) !== '') {
                    $normalized['document_id'] = trim($documentId);
                }

                $documentName = $chunk->getDocumentName();
                if ($documentName !== null && trim($documentName) !== '') {
                    $normalized['document_name'] = trim($documentName);
                }

                if ($chunk->getMetadata() !== null && $chunk->getMetadata() !== []) {
                    $normalized['metadata'] = $chunk->getMetadata();
                }

                if ($chunk->getDocumentMetadata() !== null && $chunk->getDocumentMetadata() !== []) {
                    $normalized['document_metadata'] = $chunk->getDocumentMetadata();
                }

                return $normalized;
            },
            $chunks
        )));
    }
}
</document_content>
</document>

<document index="79">
<source>src/ReferenceCatalog/ProviderCatalogBuilder.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/ReferenceCatalog/ProviderCatalogBuilder.php

namespace ParaGra\ReferenceCatalog;

use DateTimeImmutable;
use DateTimeInterface;
use DateTimeZone;
use InvalidArgumentException;
use RuntimeException;

final class ProviderCatalogBuilder
{
    public function __construct(private readonly string $projectRoot)
    {
    }

    /**
     * @return array<string, mixed>
     */
    public function buildFromSource(string $sourcePath): array
    {
        $absoluteSource = $this->resolvePath($sourcePath);
        $data = $this->decodeJsonFile($absoluteSource);

        if (!isset($data['providers']) || !is_array($data['providers'])) {
            throw new RuntimeException('Source file is missing a providers array.');
        }

        $providers = [];
        foreach ($data['providers'] as $provider) {
            if (!is_array($provider)) {
                throw new InvalidArgumentException('Provider entries must be associative arrays.');
            }
            if (!isset($provider['slug']) || !is_string($provider['slug']) || $provider['slug'] === '') {
                throw new InvalidArgumentException('Each provider entry requires a non-empty slug.');
            }

            $provider['sources'] = $this->buildSourceList($provider['sources'] ?? []);
            $providers[] = $provider;
        }

        usort(
            $providers,
            static fn (array $left, array $right): int => strcmp((string) $left['slug'], (string) $right['slug'])
        );

        $meta = [
            'this_file' => 'reference/catalog/provider_insights.json',
            'schema_version' => $data['__meta__']['schema_version'] ?? 1,
            'generated_at' => (new DateTimeImmutable('now', new DateTimeZone('UTC')))
                ->format(DateTimeInterface::ATOM),
            'source_file' => $this->relativePath($absoluteSource),
            'provider_count' => count($providers),
        ];

        return [
            '__meta__' => $meta,
            'providers' => $providers,
        ];
    }

    /**
     * @param array<string, mixed> $catalog
     *
     * @return list<string>
     */
    public function verifyCatalog(array $catalog): array
    {
        $errors = [];
        if (!isset($catalog['providers']) || !is_array($catalog['providers'])) {
            return ['Catalog is missing a providers list.'];
        }

        foreach ($catalog['providers'] as $provider) {
            $slug = is_array($provider) && isset($provider['slug']) ? (string) $provider['slug'] : '(unknown)';
            $sources = is_array($provider) ? $provider['sources'] ?? [] : [];
            if (!is_array($sources)) {
                $errors[] = sprintf('Provider %s has invalid sources metadata.', $slug);
                continue;
            }

            foreach ($sources as $source) {
                if (!is_array($source) || !isset($source['path'], $source['sha256'])) {
                    $errors[] = sprintf('Provider %s has a malformed source entry.', $slug);
                    continue;
                }

                $path = (string) $source['path'];
                $expected = (string) $source['sha256'];
                try {
                    $actual = $this->hashRelativePath($path);
                } catch (RuntimeException $exception) {
                    $errors[] = sprintf('Provider %s references missing file %s.', $slug, $path);
                    continue;
                }

                if (!hash_equals($expected, $actual)) {
                    $errors[] = sprintf('Provider %s source %s hash mismatch.', $slug, $path);
                }
            }
        }

        return $errors;
    }

    /**
     * @param list<array<string, mixed>> $sources
     *
     * @return list<array<string, int|string>>
     */
    private function buildSourceList(array $sources): array
    {
        $result = [];
        foreach ($sources as $source) {
            if (!is_array($source) || !isset($source['path']) || !is_string($source['path']) || $source['path'] === '') {
                throw new InvalidArgumentException('Each source entry requires a non-empty path.');
            }

            $entry = [
                'path' => $source['path'],
                'sha256' => $this->hashRelativePath($source['path']),
            ];

            if (isset($source['start_line'])) {
                $entry['start_line'] = (int) $source['start_line'];
            }
            if (isset($source['end_line'])) {
                $entry['end_line'] = (int) $source['end_line'];
            }

            $result[] = $entry;
        }

        return $result;
    }

    /**
     * @return array<string, mixed>
     */
    private function decodeJsonFile(string $path): array
    {
        if (!is_file($path)) {
            throw new RuntimeException(sprintf('Unable to find source file at %s', $path));
        }

        $contents = file_get_contents($path);
        if ($contents === false) {
            throw new RuntimeException(sprintf('Unable to read source file at %s', $path));
        }

        $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);
        if (!is_array($decoded)) {
            throw new RuntimeException('Decoded JSON is not an object.');
        }

        return $decoded;
    }

    private function hashRelativePath(string $relativePath): string
    {
        $absolutePath = $this->resolvePath($relativePath);
        if (!is_file($absolutePath)) {
            throw new RuntimeException(sprintf('Missing referenced file: %s', $relativePath));
        }

        $hash = hash_file('sha256', $absolutePath);
        if ($hash === false) {
            throw new RuntimeException(sprintf('Unable to hash file: %s', $relativePath));
        }

        return $hash;
    }

    private function resolvePath(string $path): string
    {
        if ($path === '') {
            throw new InvalidArgumentException('Path cannot be empty.');
        }

        if ($path[0] === DIRECTORY_SEPARATOR) {
            return $path;
        }

        return rtrim($this->projectRoot, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . ltrim($path, DIRECTORY_SEPARATOR);
    }

    private function relativePath(string $absolutePath): string
    {
        $root = rtrim($this->projectRoot, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
        if (str_starts_with($absolutePath, $root)) {
            return substr($absolutePath, strlen($root));
        }

        return $absolutePath;
    }
}
</document_content>
</document>

<document index="80">
<source>src/Response/UnifiedResponse.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Response/UnifiedResponse.php

namespace ParaGra\Response;

use Countable;
use InvalidArgumentException;

use function array_key_exists;
use function array_map;
use function array_values;
use function is_array;
use function is_numeric;
use function is_string;
use function sprintf;
use function trim;

/**
 * Provider-agnostic retrieval payload so every ParaGra provider can emit
 * identical chunk, metadata, cost, and usage data without downstream adapters
 * caring about the original API response shape.
 */
final class UnifiedResponse implements Countable
{
    /** @var list<array<string, mixed>> */
    private array $chunks;

    /** @var list<string>|null */
    private ?array $chunkTexts = null;

    /**
     * @param list<array<string, mixed>> $chunks
     * @param array<string, mixed> $providerMetadata
     * @param array<string, mixed>|null $usage
     * @param array<string, mixed>|null $cost
     */
    public function __construct(
        private readonly string $provider,
        private readonly string $model,
        array $chunks,
        private readonly array $providerMetadata = [],
        private readonly ?array $usage = null,
        private readonly ?array $cost = null,
    ) {
        $this->chunks = $this->validateChunks($chunks);
    }

    /**
     * Convenience factory for creating responses without manually invoking the constructor.
     *
     * @param list<array<string, mixed>> $chunks
     * @param array<string, mixed> $metadata
     * @param array<string, mixed>|null $usage
     * @param array<string, mixed>|null $cost
     */
    public static function fromChunks(
        string $provider,
        string $model,
        array $chunks,
        array $metadata = [],
        ?array $usage = null,
        ?array $cost = null,
    ): self {
        return new self($provider, $model, $chunks, $metadata, $usage, $cost);
    }

    public function getProvider(): string
    {
        return $this->provider;
    }

    public function getModel(): string
    {
        return $this->model;
    }

    /**
     * @return list<array<string, mixed>>
     */
    public function getChunks(): array
    {
        return $this->chunks;
    }

    /**
     * Convenience helper for prompt builders that only need context text.
     *
     * @return list<string>
     */
    public function getChunkTexts(): array
    {
        if ($this->chunkTexts === null) {
            $this->chunkTexts = array_map(
                static fn(array $chunk): string => $chunk['text'],
                $this->chunks
            );
        }

        return $this->chunkTexts;
    }

    /**
     * @return array<string, mixed>
     */
    public function getProviderMetadata(): array
    {
        return $this->providerMetadata;
    }

    /**
     * @return array<string, mixed>|null
     */
    public function getUsage(): ?array
    {
        return $this->usage;
    }

    /**
     * @return array<string, mixed>|null
     */
    public function getCost(): ?array
    {
        return $this->cost;
    }

    public function isEmpty(): bool
    {
        return $this->count() === 0;
    }

    #[\Override]
    public function count(): int
    {
        return count($this->chunks);
    }

    /**
     * Convert the response back to a normalized array payload.
     *
     * @return array{
     *     provider: string,
     *     model: string,
     *     chunks: list<array<string, mixed>>,
     *     metadata: array<string, mixed>,
     *     usage: array<string, mixed>|null,
     *     cost: array<string, mixed>|null
     * }
     */
    public function toArray(): array
    {
        return [
            'provider' => $this->provider,
            'model' => $this->model,
            'chunks' => $this->chunks,
            'metadata' => $this->providerMetadata,
            'usage' => $this->usage,
            'cost' => $this->cost,
        ];
    }

    /**
     * @param list<array<string, mixed>> $chunks
     *
     * @return list<array<string, mixed>>
     */
    private function validateChunks(array $chunks): array
    {
        $normalized = [];

        foreach ($chunks as $index => $chunk) {
            if (!is_array($chunk)) {
                throw new InvalidArgumentException('Chunk entries must be arrays.');
            }

            if (!array_key_exists('text', $chunk) || !is_string($chunk['text'])) {
                throw new InvalidArgumentException(sprintf('Chunk %d is missing a valid "text" field.', $index));
            }

            $text = trim($chunk['text']);
            if ($text === '') {
                throw new InvalidArgumentException(sprintf('Chunk %d has an empty text payload.', $index));
            }

            $normalizedChunk = ['text' => $text];

            if (array_key_exists('score', $chunk) && $chunk['score'] !== null) {
                if (!is_numeric($chunk['score'])) {
                    throw new InvalidArgumentException('Chunk score must be numeric.');
                }

                $normalizedChunk['score'] = (float) $chunk['score'];
            }

            if (array_key_exists('document_id', $chunk) && $chunk['document_id'] !== null) {
                if (!is_string($chunk['document_id'])) {
                    throw new InvalidArgumentException('Document ID must be a string when provided.');
                }

                $docId = trim($chunk['document_id']);
                if ($docId !== '') {
                    $normalizedChunk['document_id'] = $docId;
                }
            }

            if (array_key_exists('document_name', $chunk) && $chunk['document_name'] !== null) {
                if (!is_string($chunk['document_name'])) {
                    throw new InvalidArgumentException('Document name must be a string when provided.');
                }

                $docName = trim($chunk['document_name']);
                if ($docName !== '') {
                    $normalizedChunk['document_name'] = $docName;
                }
            }

            if (array_key_exists('metadata', $chunk) && $chunk['metadata'] !== null) {
                if (!is_array($chunk['metadata'])) {
                    throw new InvalidArgumentException('Chunk metadata must be an array when provided.');
                }

                $normalizedChunk['metadata'] = $chunk['metadata'];
            }

            $normalized[] = $normalizedChunk;
        }

        /** @var list<array<string, mixed>> $normalized */
        $normalized = array_values($normalized);

        return $normalized;
    }
}
</document_content>
</document>

<document index="81">
<source>src/Router/FallbackStrategy.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Router/FallbackStrategy.php

namespace ParaGra\Router;

use ParaGra\Config\PriorityPool;
use ParaGra\Config\ProviderSpec;
use RuntimeException;
use Throwable;

use function array_key_exists;
use function array_search;
use function count;
use function error_log;
use function hash;
use function implode;
use function is_array;
use function is_string;
use function sprintf;
use function strtolower;
use function substr;
use function trim;

/**
 * Executes an operation across priority pools until one succeeds.
 */
final class FallbackStrategy
{
    private const DEFAULT_FAMILY_POLICIES = [
        'free' => ['max_attempts' => null],
        'hybrid' => ['max_attempts' => 2],
        'hosted' => ['max_attempts' => 1],
        'default' => ['max_attempts' => null],
    ];

    /**
     * @var array<string, array{max_attempts: int|null}>
     */
    private array $familyPolicies;

    /**
     * @var callable(string):void
     */
    private $logger;

    public function __construct(
        private readonly PriorityPool $pools,
        private readonly KeyRotator $rotator,
        array $familyPolicies = [],
        ?callable $logger = null,
    ) {
        $this->familyPolicies = $this->normalizePolicies($familyPolicies);
        $this->logger = $logger ?? static function (string $message): void {
            error_log($message);
        };
    }

    /**
     * @param callable(ProviderSpec): mixed $operation
     */
    public function execute(callable $operation): mixed
    {
        $poolCount = $this->pools->getPoolCount();
        $lastException = null;

        for ($priority = 0; $priority < $poolCount; $priority++) {
            $pool = $this->pools->getPool($priority);
            if ($pool === []) {
                continue;
            }

            $family = $this->detectFamily($pool[0]);
            $maxAttempts = $this->resolveMaxAttempts($pool, $family);
            if ($maxAttempts === 0) {
                continue;
            }

            $spec = $this->rotator->selectSpec($pool);
            $currentIndex = $this->findIndex($pool, $spec);
            $attempt = 0;
            $fingerprints = [];

            while ($attempt < $maxAttempts) {
                try {
                    return $operation($spec);
                } catch (Throwable $exception) {
                    $attempt++;
                    $lastException = $exception;
                    $fingerprint = $this->fingerprint($spec->apiKey);
                    $fingerprints[] = $fingerprint;
                    $this->logFailure(
                        $priority,
                        $family,
                        $spec,
                        $exception,
                        $attempt,
                        $maxAttempts,
                        $fingerprint
                    );

                    if ($attempt >= $maxAttempts) {
                        break;
                    }

                    $currentIndex = $this->nextIndex($currentIndex, count($pool));
                    $spec = $pool[$currentIndex];
                }
            }

            $this->logPoolExhausted($priority, $family, $fingerprints, $maxAttempts);
        }

        throw new RuntimeException('All priority pools exhausted', 0, $lastException);
    }

    /**
     * @param array<string, array<string, mixed>> $overrides
     * @return array<string, array{max_attempts: int|null}>
     */
    private function normalizePolicies(array $overrides): array
    {
        $policies = self::DEFAULT_FAMILY_POLICIES;

        foreach ($overrides as $family => $config) {
            if (!is_string($family) || !is_array($config)) {
                continue;
            }

            $key = $this->normalizePolicyKey($family);
            if (!array_key_exists($key, $policies)) {
                $policies[$key] = ['max_attempts' => null];
            }

            $maxAttempts = $config['max_attempts'] ?? $policies[$key]['max_attempts'];
            if ($maxAttempts === null) {
                $policies[$key]['max_attempts'] = null;
                continue;
            }

            $policies[$key]['max_attempts'] = max(1, (int) $maxAttempts);
        }

        return $policies;
    }

    /**
     * @param array<int, ProviderSpec> $pool
     */
    private function resolveMaxAttempts(array $pool, string $family): int
    {
        $size = count($pool);
        if ($size === 0) {
            return 0;
        }

        $policy = $this->familyPolicies[$family] ?? $this->familyPolicies['default'];
        $maxAttempts = $policy['max_attempts'];

        if ($maxAttempts === null) {
            return $size;
        }

        if ($maxAttempts >= $size) {
            return $size;
        }

        return max(1, $maxAttempts);
    }

    /**
     * @param array<int, ProviderSpec> $pool
     */
    private function findIndex(array $pool, ProviderSpec $spec): int
    {
        $index = array_search($spec, $pool, true);

        return $index === false ? 0 : (int) $index;
    }

    private function nextIndex(int $currentIndex, int $poolSize): int
    {
        if ($poolSize === 0) {
            return 0;
        }

        return ($currentIndex + 1) % $poolSize;
    }

    private function detectFamily(ProviderSpec $spec): string
    {
        $solution = $spec->solution;
        $metadata = [];

        if (isset($solution['metadata']) && is_array($solution['metadata'])) {
            $metadata = $solution['metadata'];
        }

        foreach (['plan', 'tier', 'latency_tier'] as $key) {
            if (isset($metadata[$key]) && is_string($metadata[$key])) {
                return $this->normalizeFamilyToken($metadata[$key]);
            }
        }

        return 'hybrid';
    }

    private function normalizePolicyKey(string $family): string
    {
        $token = strtolower(trim($family));
        if ($token === 'default') {
            return 'default';
        }

        return $this->normalizeFamilyToken($token);
    }

    private function normalizeFamilyToken(string $value): string
    {
        $normalized = strtolower(trim($value));

        return match ($normalized) {
            'free', 'free-tier', 'freemium', 'starter' => 'free',
            'hosted', 'managed' => 'hosted',
            default => 'hybrid',
        };
    }

    private function fingerprint(string $apiKey): string
    {
        return substr(hash('sha1', $apiKey), 0, 8);
    }

    /**
     * @param array<int, string> $fingerprints
     */
    private function logPoolExhausted(int $priority, string $family, array $fingerprints, int $maxAttempts): void
    {
        if ($fingerprints === []) {
            return;
        }

        ($this->logger)(sprintf(
            '[ParaGra] Pool %d (%s) exhausted after %d attempt(s); keys=%s',
            $priority,
            $family,
            $maxAttempts,
            implode(',', $fingerprints)
        ));
    }

    private function logFailure(
        int $priority,
        string $family,
        ProviderSpec $spec,
        Throwable $exception,
        int $attempt,
        int $maxAttempts,
        string $fingerprint
    ): void {
        ($this->logger)(sprintf(
            '[ParaGra] Pool %d (%s) attempt %d/%d failed for provider=%s model=%s key#%s: %s',
            $priority,
            $family,
            $attempt,
            $maxAttempts,
            $spec->provider,
            $spec->model,
            $fingerprint,
            $exception->getMessage()
        ));
    }
}
</document_content>
</document>

<document index="82">
<source>src/Router/KeyRotator.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/Router/KeyRotator.php

namespace ParaGra\Router;

use ParaGra\Config\ProviderSpec;
use RuntimeException;

use function count;
use function time;

/**
 * Timestamp-based rotation for pool entries.
 */
final class KeyRotator
{
    /**
     * @var callable(): int
     */
    private $timeProvider;

    public function __construct(?callable $timeProvider = null)
    {
        $this->timeProvider = $timeProvider ?? static fn (): int => time();
    }

    /**
     * @param array<int, ProviderSpec> $pool
     */
    public function selectSpec(array $pool): ProviderSpec
    {
        if ($pool === []) {
            throw new RuntimeException('Cannot select provider from an empty pool.');
        }

        if (count($pool) === 1) {
            return $pool[0];
        }

        $timestamp = ($this->timeProvider)();
        $index = $timestamp % count($pool);

        return $pool[$index];
    }

    /**
     * @param array<int, ProviderSpec> $pool
     */
    public function getNextSpec(array $pool, int $currentIndex): ProviderSpec
    {
        if ($pool === []) {
            throw new RuntimeException('Cannot rotate within an empty pool.');
        }

        $nextIndex = ($currentIndex + 1) % count($pool);

        return $pool[$nextIndex];
    }
}
</document_content>
</document>

<document index="83">
<source>src/Support/ExceptionEnhancer.php</source>
<document_content>
<?php

// this_file: paragra-php/src/Support/ExceptionEnhancer.php

declare(strict_types=1);

namespace ParaGra\Support;

use Ragie\Api\ApiException;
use Throwable;

/**
 * Enhances exceptions with additional context for better debugging.
 *
 * Provides utilities to add helpful information to exceptions,
 * especially for API errors.
 *
 * @example
 * ```php
 * try {
 *     $client->retrieve($query);
 * } catch (ApiException $final e) {
 *     $enhanced = ExceptionEnhancer::enhance($e, ['query' => $query]);
 *     error_log($enhanced->getMessage());
 * }
 * ```
 */
class ExceptionEnhancer
{
    /**
     * Enhance an API exception with additional context.
     *
     * Extracts HTTP status, response body, and adds context to the message.
     *
     * @param ApiException $exception The original API exception
     * @param array<string, mixed> $context Additional context (query, params, etc.)
     * @return ApiException Enhanced exception with better message
     */
    public static function enhanceApiException(ApiException $exception, array $context = []): ApiException
    {
        $parts = [];

        // Add HTTP status
        $code = $exception->getCode();
        if ($code > 0) {
            $parts[] = sprintf('[%d]', $code);
        }

        // Add original message
        $parts[] = $exception->getMessage();

        // Add response body if available
        $responseBody = $exception->getResponseBody();
        if ($responseBody !== null && is_string($responseBody)) {
            $decoded = json_decode($responseBody, true);
            if (isset($decoded['detail'])) {
                $parts[] = sprintf('Detail: %s', $decoded['detail']);
            } elseif (isset($decoded['message'])) {
                $parts[] = sprintf('Detail: %s', $decoded['message']);
            }
        }

        // Add context
        if (!empty($context)) {
            $contextStr = [];
            foreach ($context as $key => $value) {
                if (is_scalar($value)) {
                    $contextStr[] = sprintf('%s=%s', $key, $value);
                } elseif (is_array($value)) {
                    $contextStr[] = sprintf('%s=%s', $key, json_encode($value));
                }
            }
            if (!empty($contextStr)) {
                $parts[] = sprintf('Context: %s', implode(', ', $contextStr));
            }
        }

        $enhancedMessage = implode(' | ', $parts);

        // Return new exception with enhanced message
        return new ApiException(
            $enhancedMessage,
            $exception->getCode(),
            $exception->getResponseHeaders(),
            $exception->getResponseBody()
        );
    }

    /**
     * Get a user-friendly error message from any exception.
     *
     * Strips technical details for end-user display.
     *
     * @param Throwable $exception Any exception
     * @return string User-friendly error message
     */
    public static function getUserMessage(Throwable $exception): string
    {
        if ($exception instanceof ApiException) {
            $code = $exception->getCode();

            if ($code === 429) {
                return 'Rate limit exceeded. Please try again in a moment.';
            }

            if ($code === 401 || $code === 403) {
                return 'Authentication failed. Please check your API key.';
            }

            if ($code >= 500) {
                return 'Service temporarily unavailable. Please try again later.';
            }

            if ($code >= 400) {
                return 'Invalid request. Please check your input.';
            }
        }

        return 'An error occurred while processing your request.';
    }
}
</document_content>
</document>

<document index="84">
<source>src/Util/ConfigValidator.php</source>
<document_content>
<?php

// this_file: paragra-php/src/Util/ConfigValidator.php

declare(strict_types=1);

namespace ParaGra\Util;

use ParaGra\Exception\ConfigurationException;

/**
 * Helper for validating configuration and environment variables.
 *
 * Provides static methods for checking required configuration values
 * with clear error messages.
 *
 * @example
 * ```php
 * // Validate single required env var
 * $apiKey = ConfigValidator::requireEnv('RAGIE_API_KEY');
 *
 * // Validate multiple env vars at once
 * ConfigValidator::requireAll(['RAGIE_API_KEY', 'OPENAI_API_KEY']);
 * ```
 */
class ConfigValidator
{
    /**
     * Require that an environment variable exists and is not empty.
     *
     * @param string $varName Name of the environment variable
     *
     * @throws ConfigurationException If variable is missing or empty
     * @return string The value of the environment variable
     */
    public static function requireEnv(string $varName): string
    {
        $value = $_ENV[$varName] ?? getenv($varName);

        if ($value === false) {
            throw ConfigurationException::missingEnv($varName);
        }

        $trimmed = trim((string)$value);
        if ($trimmed === '') {
            throw ConfigurationException::emptyEnv($varName);
        }

        return $trimmed;
    }

    /**
     * Require multiple environment variables at once.
     *
     * @param array<int, string> $varNames List of required variable names
     *
     * @throws ConfigurationException If any variable is missing or empty
     */
    public static function requireAll(array $varNames): void
    {
        foreach ($varNames as $varName) {
            self::requireEnv($varName);
        }
    }

    /**
     * Get environment variable with fallback default.
     *
     * Unlike requireEnv(), this allows missing variables.
     *
     * @param string $varName Name of the environment variable
     * @param string $default Default value if variable is missing or empty
     * @return string The value or default
     */
    public static function getEnv(string $varName, string $default = ''): string
    {
        $value = $_ENV[$varName] ?? getenv($varName);

        if ($value === false) {
            return $default;
        }

        $trimmed = trim((string)$value);
        return $trimmed === '' ? $default : $trimmed;
    }
}
</document_content>
</document>

<document index="85">
<source>src/VectorStore/ChromaVectorStore.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/ChromaVectorStore.php

namespace ParaGra\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use Throwable;

use function array_map;
use function array_values;
use function count;
use function is_array;
use function is_numeric;
use function is_string;
use function json_decode;
use function max;
use function rawurlencode;
use function rtrim;
use function sprintf;
use function str_ends_with;
use function trim;

use const JSON_THROW_ON_ERROR;

/**
 * REST adapter for ChromaDB v2 collections.
 */
final class ChromaVectorStore implements VectorStoreInterface
{
    private ClientInterface $httpClient;

    private VectorNamespace $defaultNamespace;

    public function __construct(
        private readonly string $baseUrl,
        private readonly string $tenant,
        private readonly string $database,
        private readonly string $collection,
        ?VectorNamespace $defaultNamespace = null,
        private readonly ?string $authToken = null,
        ?ClientInterface $httpClient = null,
    ) {
        $this->defaultNamespace = $defaultNamespace ?? new VectorNamespace($collection, $collection);
        $this->httpClient = $httpClient ?? new Client([
            'base_uri' => $this->normalizeBaseUrl($baseUrl),
            'timeout' => 30,
        ]);
    }

    #[\Override]
    public function getProvider(): string
    {
        return 'chroma';
    }

    #[\Override]
    public function getDefaultNamespace(): VectorNamespace
    {
        return $this->defaultNamespace;
    }

    #[\Override]
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        if ($records === []) {
            return ['upserted' => 0, 'updated' => 0];
        }

        $tenant = $options['tenant'] ?? $this->tenant;
        $database = $options['database'] ?? $this->database;
        $collection = $this->resolveCollection($namespace);

        $ids = [];
        $embeddings = [];
        $metadatas = [];
        $documents = [];
        $hasDocuments = false;

        foreach ($records as $record) {
            $ids[] = (string) $record['id'];
            $embeddings[] = array_map(static fn (float $value): float => $value, array_values($record['values']));
            $metadata = is_array($record['metadata'] ?? null) ? $record['metadata'] : [];
            $metadatas[] = $metadata;

            $document = $this->extractDocument($metadata);
            if ($document !== null) {
                $documents[] = $document;
                $hasDocuments = true;
            } else {
                $documents[] = '';
            }
        }

        $payload = [
            'ids' => $ids,
            'embeddings' => $embeddings,
            'metadatas' => $metadatas,
        ];

        if ($hasDocuments) {
            $payload['documents'] = $documents;
        }

        $path = $this->buildCollectionPath($tenant, $database, $collection, 'upsert');
        $this->request('POST', $path, $payload, $options);

        return ['upserted' => count($records), 'updated' => 0];
    }

    #[\Override]
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        if ($ids === []) {
            return ['deleted' => 0];
        }

        $tenant = $options['tenant'] ?? $this->tenant;
        $database = $options['database'] ?? $this->database;
        $collection = $this->resolveCollection($namespace);
        $path = $this->buildCollectionPath($tenant, $database, $collection, 'delete');

        $this->request('POST', $path, [
            'ids' => array_values($ids),
        ], $options);

        return ['deleted' => count($ids)];
    }

    #[\Override]
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $tenant = $options['tenant'] ?? $this->tenant;
        $database = $options['database'] ?? $this->database;
        $collection = $this->resolveCollection($namespace);

        $payload = [
            'query_embeddings' => [array_values($vector)],
            'n_results' => (int) ($options['top_k'] ?? 10),
            'include' => $this->buildIncludeList($options),
        ];

        $filter = $options['filter'] ?? $this->buildWhereFilter($namespace->getMetadata());
        if (is_array($filter) && $filter !== []) {
            $payload['where'] = $filter;
        }

        $path = $this->buildCollectionPath($tenant, $database, $collection, 'query');
        $response = $this->request('POST', $path, $payload, $options);

        $chunks = $this->normalizeQueryResults($response);
        $metadata = [
            'tenant' => $tenant,
            'database' => $database,
            'collection' => $collection,
            'match_count' => count($chunks),
        ];

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $collection,
            chunks: $chunks,
            metadata: $metadata,
        );
    }

    /**
     * @param array<string, mixed> $payload
     * @param array<string, mixed> $options
     *
     * @return array<string, mixed>
     */
    private function request(string $method, string $path, array $payload = [], array $options = []): array
    {
        $requestOptions = [
            'headers' => $this->buildDefaultHeaders(),
        ];

        if ($payload !== []) {
            $requestOptions['json'] = $payload;
        }

        if (isset($options['timeout_ms'])) {
            $timeout = (int) $options['timeout_ms'];
            if ($timeout > 0) {
                $requestOptions['timeout'] = $timeout / 1000;
            }
        }

        try {
            $response = $this->httpClient->request($method, $path, $requestOptions);
        } catch (Throwable $exception) {
            throw new RuntimeException(
                sprintf('Chroma request failed: %s', $exception->getMessage()),
                0,
                $exception
            );
        }

        $body = (string) $response->getBody();
        if ($body === '') {
            return [];
        }

        return json_decode($body, true, 512, JSON_THROW_ON_ERROR) ?? [];
    }

    private function buildCollectionPath(string $tenant, string $database, string $collection, string $suffix): string
    {
        return sprintf(
            'tenants/%s/databases/%s/collections/%s/%s',
            rawurlencode($tenant),
            rawurlencode($database),
            rawurlencode($collection),
            trim($suffix, '/')
        );
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     */
    private function buildWhereFilter(array $metadata): array
    {
        if ($metadata === []) {
            return [];
        }

        $conditions = [];

        foreach ($metadata as $key => $value) {
            if (is_array($value)) {
                $conditions[] = [
                    $key => ['$in' => array_values($value)],
                ];
                continue;
            }

            $conditions[] = [
                $key => $value,
            ];
        }

        if (count($conditions) === 1) {
            return $conditions[0];
        }

        return ['$and' => $conditions];
    }

    /**
     * @return list<string>
     */
    private function buildIncludeList(array $options): array
    {
        $includes = ['documents', 'metadatas'];

        if (!empty($options['include_vectors'])) {
            $includes[] = 'embeddings';
        }

        return $includes;
    }

    /**
     * @param array<string, mixed> $response
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeQueryResults(array $response): array
    {
        $ids = $this->unwrapFirstList($response['ids'] ?? []);
        $documents = $this->unwrapFirstList($response['documents'] ?? []);
        $metadatas = $this->unwrapFirstList($response['metadatas'] ?? []);
        $distances = $this->unwrapFirstList($response['distances'] ?? []);

        $max = max(count($ids), count($documents), count($metadatas), count($distances));
        $chunks = [];

        for ($i = 0; $i < $max; $i++) {
            $metadata = is_array($metadatas[$i] ?? null) ? $metadatas[$i] : [];
            $document = isset($documents[$i]) && is_string($documents[$i])
                ? trim((string) $documents[$i])
                : null;

            $text = $document !== null && $document !== '' ? $document : $this->extractText($metadata);
            if ($text === null) {
                continue;
            }

            $chunk = ['text' => $text];

            if (isset($ids[$i]) && is_string($ids[$i]) && trim($ids[$i]) !== '') {
                $chunk['document_id'] = trim($ids[$i]);
            }

            if (isset($distances[$i]) && is_numeric($distances[$i])) {
                $chunk['score'] = $this->distanceToScore((float) $distances[$i]);
            }

            $documentName = $metadata['title'] ?? $metadata['document_name'] ?? null;
            if (is_string($documentName) && trim($documentName) !== '') {
                $chunk['document_name'] = trim($documentName);
                unset($metadata['title'], $metadata['document_name']);
            }

            unset($metadata['text'], $metadata['content']);
            if ($metadata !== []) {
                $chunk['metadata'] = $metadata;
            }

            $chunks[] = $chunk;
        }

        return $chunks;
    }

    /**
     * @param mixed $list
     *
     * @return list<mixed>
     */
    private function unwrapFirstList(mixed $list): array
    {
        if (!is_array($list) || $list === []) {
            return [];
        }

        $first = $list[0] ?? null;
        if (is_array($first)) {
            return array_values($first);
        }

        return array_values($list);
    }

    /**
     * @param array<string, mixed> $metadata
     */
    private function extractDocument(array $metadata): ?string
    {
        $text = $metadata['text'] ?? $metadata['content'] ?? null;
        if (!is_string($text)) {
            return null;
        }

        $clean = trim($text);

        return $clean === '' ? null : $clean;
    }

    /**
     * @param array<string, mixed> $metadata
     */
    private function extractText(array $metadata): ?string
    {
        $text = $metadata['text'] ?? $metadata['content'] ?? null;
        if (!is_string($text)) {
            return null;
        }

        $clean = trim($text);

        return $clean === '' ? null : $clean;
    }

    private function resolveCollection(VectorNamespace $namespace): string
    {
        return $namespace->getCollection() ?? $namespace->getName() ?? $this->collection;
    }

    private function distanceToScore(float $distance): float
    {
        $normalized = $distance < 0 ? 0 : $distance;

        return 1.0 / (1.0 + $normalized);
    }

    private function normalizeBaseUrl(string $baseUrl): string
    {
        $trimmed = rtrim($baseUrl, '/');
        if (!str_ends_with($trimmed, '/api/v2')) {
            $trimmed .= '/api/v2';
        }

        if (!str_ends_with($trimmed, '/')) {
            $trimmed .= '/';
        }

        return $trimmed;
    }

    /**
     * @return array<string, string>
     */
    private function buildDefaultHeaders(): array
    {
        $headers = [
            'Accept' => 'application/json',
        ];

        if ($this->authToken !== null && trim($this->authToken) !== '') {
            $headers['Authorization'] = sprintf('Bearer %s', trim($this->authToken));
        }

        return $headers;
    }
}
</document_content>
</document>

<document index="86">
<source>src/VectorStore/GeminiFileSearchVectorStore.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/GeminiFileSearchVectorStore.php

namespace ParaGra\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use Throwable;

use function array_chunk;
use function array_filter;
use function array_is_list;
use function count;
use function is_bool;
use function is_array;
use function is_numeric;
use function is_scalar;
use function is_string;
use function json_decode;
use function json_encode;
use function ltrim;
use function preg_replace;
use function rawurlencode;
use function sprintf;
use function str_starts_with;
use function strtolower;
use function trim;
use function uniqid;

use const JSON_THROW_ON_ERROR;

/**
 * Thin REST adapter for Gemini File Search stores (`fileSearchStores/*` or `corpora/*`).
 *
 * Google handles vector generation internally. ParaGra only needs to create documents
 * that contain chunk text plus metadata, delete them when requested, and issue semantic
 * queries that return normalized `UnifiedResponse` chunks.
 */
final class GeminiFileSearchVectorStore implements VectorStoreInterface
{
    private const MAX_BATCH_SIZE = 16;

    private ClientInterface $httpClient;

    private VectorNamespace $defaultNamespace;

    public function __construct(
        private readonly string $apiKey,
        private readonly string $resourceName,
        ?VectorNamespace $defaultNamespace = null,
        ?ClientInterface $httpClient = null,
    ) {
        $this->defaultNamespace = $defaultNamespace ?? new VectorNamespace(
            name: 'gemini-file-search',
            collection: $this->resourceName,
            eventuallyConsistent: true,
        );

        $this->httpClient = $httpClient ?? new Client([
            'base_uri' => 'https://generativelanguage.googleapis.com',
            'timeout' => 30,
        ]);
    }

    #[\Override]
    public function getProvider(): string
    {
        return 'gemini-file-search';
    }

    #[\Override]
    public function getDefaultNamespace(): VectorNamespace
    {
        return $this->defaultNamespace;
    }

    #[\Override]
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        if ($records === []) {
            return ['upserted' => 0, 'updated' => 0];
        }

        $resource = $this->resolveResource($namespace, $options);
        $requests = [];

        foreach ($records as $record) {
            $payload = $this->buildDocumentRequest($record);
            if ($payload !== null) {
                $requests[] = $payload;
            }
        }

        if ($requests === []) {
            return ['upserted' => 0, 'updated' => 0];
        }

        foreach (array_chunk($requests, self::MAX_BATCH_SIZE) as $batch) {
            $this->request(
                'POST',
                $this->buildPath($resource, 'documents:batchCreate'),
                ['requests' => $batch]
            );
        }

        return ['upserted' => count($requests), 'updated' => 0];
    }

    #[\Override]
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        if ($ids === []) {
            return ['deleted' => 0];
        }

        $resource = $this->resolveResource($namespace, $options);
        $deleted = 0;

        foreach ($ids as $id) {
            $documentId = $this->sanitizeDocumentId($id);
            $this->request(
                'DELETE',
                $this->buildPath($resource, sprintf('documents/%s', rawurlencode($documentId)))
            );
            $deleted++;
        }

        return ['deleted' => $deleted];
    }

    /**
     * @param list<float> $vector Ignored; Gemini queries require a text prompt supplied via $options['query'].
     */
    #[\Override]
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $query = $options['query'] ?? null;
        if (!is_string($query) || trim($query) === '') {
            throw new RuntimeException('Gemini File Search queries require a non-empty "query" option.');
        }

        $resource = $this->resolveResource($namespace, $options);
        $topK = (int) ($options['top_k'] ?? 5);
        if ($topK <= 0) {
            $topK = 5;
        }

        $payload = [
            'query' => trim($query),
            'chunkControl' => [
                'maxChunks' => $topK,
            ],
        ];

        $filters = $options['filter'] ?? $namespace->getMetadata();
        if (is_array($filters) && $filters !== []) {
            $payload['metadataFilters'] = $this->buildMetadataFilters($filters);
        }

        $response = $this->request(
            'POST',
            $this->buildPath($resource, 'documents:query'),
            $payload
        );

        $chunks = $this->normalizeRelevantChunks($response['relevantChunks'] ?? []);
        $metadata = array_filter([
            'resource' => $resource,
            'match_count' => count($chunks),
        ]);

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $namespace->getCollection() ?? $resource,
            chunks: $chunks,
            metadata: $metadata,
        );
    }

    /**
     * @param array<string, mixed> $record
     */
    private function buildDocumentRequest(array $record): ?array
    {
        $metadata = is_array($record['metadata'] ?? null) ? $record['metadata'] : [];
        $text = $this->extractText($metadata);
        if ($text === null) {
            $recordId = isset($record['id']) ? trim((string) $record['id']) : '(unknown)';
            throw new RuntimeException(sprintf(
                'Gemini File Search upsert requires chunk text via metadata["text"] (record id: %s).',
                $recordId === '' ? '(empty)' : $recordId
            ));
        }

        $documentId = $this->sanitizeDocumentId($record['id'] ?? null);
        $displayName = $this->extractDisplayName($metadata, $documentId);
        $customMetadata = $this->formatCustomMetadata($metadata);

        $document = [
            'document' => [
                'displayName' => $displayName,
                'jsonData' => json_encode([
                    'id' => $documentId,
                    'text' => $text,
                    'metadata' => $metadata,
                ], JSON_THROW_ON_ERROR),
            ],
            'documentId' => $documentId,
        ];

        if ($customMetadata !== []) {
            $document['document']['customMetadata'] = $customMetadata;
        }

        return $document;
    }

    /**
     * @return list<array{key: string, value: string}>
     */
    private function formatCustomMetadata(array $metadata): array
    {
        $entries = [];
        foreach ($metadata as $key => $value) {
            if (!is_string($key)) {
                continue;
            }

            if (is_array($value) && array_is_list($value)) {
                foreach ($value as $entry) {
                    if (is_scalar($entry)) {
                        $entries[] = [
                            'key' => $key,
                            'value' => $this->stringifyMetadataValue($entry),
                        ];
                    }
                }
                continue;
            }

            if (is_scalar($value)) {
                $entries[] = [
                    'key' => $key,
                    'value' => $this->stringifyMetadataValue($value),
                ];
            }
        }

        return $entries;
    }

    private function stringifyMetadataValue(mixed $value): string
    {
        if (is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (is_numeric($value)) {
            return (string) $value;
        }

        return trim((string) $value);
    }

    private function extractText(array &$metadata): ?string
    {
        foreach (['text', 'body', 'content'] as $key) {
            if (isset($metadata[$key]) && is_string($metadata[$key])) {
                $text = trim($metadata[$key]);
                unset($metadata[$key]);
                if ($text !== '') {
                    return $text;
                }
            }
        }

        return null;
    }

    private function extractDisplayName(array &$metadata, string $fallback): string
    {
        foreach (['display_name', 'title', 'name'] as $key) {
            if (isset($metadata[$key]) && is_string($metadata[$key])) {
                $value = trim($metadata[$key]);
                unset($metadata[$key]);
                if ($value !== '') {
                    return $value;
                }
            }
        }

        return $fallback;
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $filters
     *
     * @return list<array{key: string, value: string}>
     */
    private function buildMetadataFilters(array $filters): array
    {
        $entries = [];
        foreach ($filters as $key => $value) {
            if (!is_string($key)) {
                continue;
            }

            if (is_array($value) && array_is_list($value)) {
                foreach ($value as $entry) {
                    if (is_scalar($entry)) {
                        $entries[] = ['key' => $key, 'value' => $this->stringifyMetadataValue($entry)];
                    }
                }
                continue;
            }

            if (is_scalar($value)) {
                $entries[] = ['key' => $key, 'value' => $this->stringifyMetadataValue($value)];
            }
        }

        return $entries;
    }

    /**
     * @param list<array<string, mixed>> $entries
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeRelevantChunks(array $entries): array
    {
        $chunks = [];

        foreach ($entries as $entry) {
            if (!is_array($entry)) {
                continue;
            }

            $text = trim((string) ($entry['text'] ?? ''));
            if ($text === '') {
                continue;
            }

            $chunk = ['text' => $text];

            if (isset($entry['relevanceScore'])) {
                $chunk['score'] = (float) $entry['relevanceScore'];
            }

            if (isset($entry['documentId']) && trim((string) $entry['documentId']) !== '') {
                $chunk['document_id'] = trim((string) $entry['documentId']);
            }

            if (isset($entry['chunkId']) && trim((string) $entry['chunkId']) !== '') {
                $metadata = $chunk['metadata'] ?? [];
                $metadata['chunk_id'] = trim((string) $entry['chunkId']);
                $chunk['metadata'] = $metadata;
            }

            if (isset($entry['metadata']) && is_array($entry['metadata']) && $entry['metadata'] !== []) {
                $metadata = $chunk['metadata'] ?? [];
                $chunk['metadata'] = $metadata + $entry['metadata'];
            }

            if (isset($entry['pageSpan']) && is_array($entry['pageSpan'])) {
                $metadata = $chunk['metadata'] ?? [];
                $metadata['page_span'] = $entry['pageSpan'];
                $chunk['metadata'] = $metadata;
            }

            $chunks[] = $chunk;
        }

        return $chunks;
    }

    /**
     * @param array<string, mixed> $payload
     *
     * @return array<string, mixed>
     */
    private function request(string $method, string $path, array $payload = []): array
    {
        $options = [
            'query' => ['key' => $this->apiKey],
        ];

        if ($payload !== []) {
            $options['json'] = $payload;
        }

        try {
            $response = $this->httpClient->request($method, $path, $options);
        } catch (Throwable $exception) {
            throw new RuntimeException(
                sprintf('Gemini File Search request failed: %s', $exception->getMessage()),
                (int) $exception->getCode(),
                $exception
            );
        }

        $body = (string) $response->getBody();
        if (trim($body) === '') {
            return [];
        }

        return json_decode($body, true, 512, JSON_THROW_ON_ERROR);
    }

    private function buildPath(string $resource, string $suffix): string
    {
        $resource = ltrim($resource, '/');
        if ($suffix === '') {
            return sprintf('/v1beta/%s', $resource);
        }

        return sprintf('/v1beta/%s/%s', $resource, $suffix);
    }

    private function resolveResource(VectorNamespace $namespace, array $options): string
    {
        if (isset($options['resource']) && is_string($options['resource']) && trim($options['resource']) !== '') {
            return $this->normalizeResource($options['resource']);
        }

        if ($namespace->getCollection() !== null) {
            return $this->normalizeResource($namespace->getCollection());
        }

        return $this->normalizeResource($this->resourceName);
    }

    private function normalizeResource(string $resource): string
    {
        $clean = trim($resource);
        if ($clean === '') {
            throw new RuntimeException('Gemini File Search resource names cannot be empty.');
        }

        $clean = ltrim($clean, '/');
        if (
            !str_starts_with($clean, 'fileSearchStores/')
            && !str_starts_with($clean, 'corpora/')
            && !str_starts_with($clean, 'projects/')
        ) {
            return sprintf('fileSearchStores/%s', $clean);
        }

        return $clean;
    }

    private function sanitizeDocumentId(mixed $value): string
    {
        $stringValue = is_string($value) ? trim($value) : '';
        if ($stringValue === '') {
            $stringValue = uniqid('doc-', true);
        }

        $safe = preg_replace('/[^a-zA-Z0-9\-\_\.]+/', '-', $stringValue) ?? $stringValue;
        $safe = trim($safe, '-_ .');
        if ($safe === '') {
            $safe = uniqid('doc-', true);
        }

        return strtolower($safe);
    }
}
</document_content>
</document>

<document index="87">
<source>src/VectorStore/PineconeVectorStore.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/PineconeVectorStore.php

namespace ParaGra\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use Throwable;

use function array_filter;
use function array_map;
use function array_values;
use function count;
use function is_array;
use function is_string;
use function json_decode;
use function str_ends_with;
use function trim;
use function sprintf;

use const JSON_THROW_ON_ERROR;

/**
 * HTTP adapter for Pinecone's 2024 data plane API.
 */
final class PineconeVectorStore implements VectorStoreInterface
{
    private ClientInterface $httpClient;

    private VectorNamespace $defaultNamespace;

    public function __construct(
        private readonly string $baseUrl,
        private readonly string $apiKey,
        private readonly string $indexName,
        ?VectorNamespace $defaultNamespace = null,
        private readonly string $apiVersion = '2024-07',
        ?ClientInterface $httpClient = null,
    ) {
        $this->defaultNamespace = $defaultNamespace ?? new VectorNamespace('default');
        $this->httpClient = $httpClient ?? new Client([
            'base_uri' => $this->normalizeBaseUrl($baseUrl),
            'timeout' => 30,
        ]);
    }

    public function getProvider(): string
    {
        return 'pinecone';
    }

    public function getDefaultNamespace(): VectorNamespace
    {
        return $this->defaultNamespace;
    }

    /**
     * @param list<array{
     *     id: string,
     *     values: list<float>,
     *     metadata?: array<string, mixed>
     * }> $records
     *
     * @return array{upserted: int, updated: int, task_id?: string}
     */
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        $payload = [
            'namespace' => $namespace->getName(),
            'vectors' => array_map(fn (array $record): array => [
                'id' => (string) $record['id'],
                'values' => array_map(static fn (float $value): float => $value, $record['values']),
                'metadata' => $record['metadata'] ?? [],
            ], $records),
        ];

        $response = $this->request('POST', 'vectors/upsert', $payload);
        $count = (int) ($response['upsertedCount'] ?? $response['upserted_count'] ?? count($records));

        return ['upserted' => $count, 'updated' => 0];
    }

    /**
     * @param list<string> $ids
     *
     * @return array{deleted: int}
     */
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        $payload = [
            'namespace' => $namespace->getName(),
            'ids' => array_values($ids),
        ];

        $response = $this->request('POST', 'vectors/delete', $payload);

        return ['deleted' => (int) ($response['deletedCount'] ?? $response['deleted_count'] ?? count($ids))];
    }

    /**
     * @param list<float> $vector
     */
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $payload = [
            'namespace' => $namespace->getName(),
            'vector' => array_values($vector),
            'topK' => (int) ($options['top_k'] ?? 10),
            'includeMetadata' => true,
            'includeValues' => (bool) ($options['include_vectors'] ?? false),
        ];

        $filter = $options['filter'] ?? $this->buildMetadataFilter($namespace->getMetadata());
        if (is_array($filter) && $filter !== []) {
            $payload['filter'] = $filter;
        }

        $response = $this->request('POST', 'query', $payload);
        $chunks = $this->normalizeMatches($response['matches'] ?? []);

        $metadata = array_filter([
            'namespace' => $namespace->toArray(),
            'match_count' => count($chunks),
        ]);

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $this->indexName,
            chunks: $chunks,
            metadata: $metadata,
        );
    }

    /**
     * @param list<array<string, mixed>> $matches
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeMatches(array $matches): array
    {
        $chunks = [];

        foreach ($matches as $match) {
            if (!is_array($match)) {
                continue;
            }

            $metadata = is_array($match['metadata'] ?? null) ? $match['metadata'] : [];
            $text = $this->extractText($metadata);
            if ($text === null) {
                continue;
            }

            $chunk = [
                'text' => $text,
            ];

            if (isset($match['score'])) {
                $chunk['score'] = (float) $match['score'];
            }

            if (isset($match['id']) && trim((string) $match['id']) !== '') {
                $chunk['document_id'] = trim((string) $match['id']);
            }

            $documentName = $metadata['title'] ?? $metadata['document_name'] ?? null;
            if (is_string($documentName) && trim($documentName) !== '') {
                $chunk['document_name'] = trim($documentName);
                unset($metadata['title'], $metadata['document_name']);
            }

            unset($metadata['text'], $metadata['content']);
            if ($metadata !== []) {
                $chunk['metadata'] = $metadata;
            }

            $chunks[] = $chunk;
        }

        return array_values($chunks);
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     */
    private function buildMetadataFilter(array $metadata): array
    {
        $filter = [];

        foreach ($metadata as $key => $value) {
            if (is_array($value)) {
                $filter[$key] = ['$in' => array_values($value)];
                continue;
            }

            $filter[$key] = ['$eq' => $value];
        }

        return $filter;
    }

    private function extractText(array &$metadata): ?string
    {
        foreach (['text', 'content', 'body'] as $key) {
            if (isset($metadata[$key]) && is_string($metadata[$key])) {
                $text = trim($metadata[$key]);
                unset($metadata[$key]);
                if ($text !== '') {
                    return $text;
                }
            }
        }

        return null;
    }

    /**
     * @param array<string, mixed> $payload
     *
     * @return array<string, mixed>
     */
    private function request(string $method, string $uri, array $payload): array
    {
        try {
            $response = $this->httpClient->request($method, $uri, [
                'headers' => [
                    'Accept' => 'application/json',
                    'Api-Key' => $this->apiKey,
                    'X-Pinecone-API-Version' => $this->apiVersion,
                ],
                'json' => $payload,
            ]);
        } catch (Throwable $exception) {
            throw new RuntimeException(
                sprintf('Pinecone request to "%s" failed: %s', $uri, $exception->getMessage()),
                (int) $exception->getCode(),
                $exception
            );
        }

        $contents = (string) $response->getBody();
        if ($contents === '') {
            return [];
        }

        /** @var array<string, mixed> $decoded */
        $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);

        return $decoded;
    }

    private function normalizeBaseUrl(string $baseUrl): string
    {
        $trimmed = trim($baseUrl);
        if ($trimmed === '') {
            throw new RuntimeException('Pinecone base URL cannot be empty.');
        }

        return str_ends_with($trimmed, '/') ? $trimmed : $trimmed . '/';
    }
}
</document_content>
</document>

<document index="88">
<source>src/VectorStore/QdrantVectorStore.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/QdrantVectorStore.php

namespace ParaGra\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use Throwable;

use function array_filter;
use function array_map;
use function array_values;
use function count;
use function is_array;
use function is_string;
use function json_decode;
use function sprintf;
use function str_ends_with;
use function trim;

use const JSON_THROW_ON_ERROR;

/**
 * HTTP adapter for Qdrant's REST API.
 */
final class QdrantVectorStore implements VectorStoreInterface
{
    private ClientInterface $httpClient;

    private VectorNamespace $defaultNamespace;

    public function __construct(
        private readonly string $baseUrl,
        private readonly string $collection,
        private readonly ?string $apiKey = null,
        ?VectorNamespace $defaultNamespace = null,
        ?ClientInterface $httpClient = null,
    ) {
        $this->defaultNamespace = $defaultNamespace ?? new VectorNamespace($collection);
        $this->httpClient = $httpClient ?? new Client([
            'base_uri' => $this->normalizeBaseUrl($baseUrl),
            'timeout' => 30,
        ]);
    }

    public function getProvider(): string
    {
        return 'qdrant';
    }

    public function getDefaultNamespace(): VectorNamespace
    {
        return $this->defaultNamespace;
    }

    /**
     * @param list<array{
     *     id: string,
     *     values: list<float>,
     *     metadata?: array<string, mixed>
     * }> $records
     *
     * @return array{upserted: int, updated: int, task_id?: string}
     */
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        $payload = [
            'wait' => (bool) ($options['wait_for_sync'] ?? false),
            'points' => array_map(fn (array $record): array => [
                'id' => (string) $record['id'],
                'vector' => array_map(static fn (float $value): float => $value, $record['values']),
                'payload' => $record['metadata'] ?? [],
            ], $records),
        ];

        $this->request('PUT', sprintf('collections/%s/points', $namespace->getName()), $payload);

        return ['upserted' => count($records), 'updated' => 0];
    }

    /**
     * @param list<string> $ids
     *
     * @return array{deleted: int}
     */
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        $payload = [
            'points' => array_values($ids),
            'wait' => (bool) ($options['wait_for_sync'] ?? false),
        ];

        $this->request('POST', sprintf('collections/%s/points/delete', $namespace->getName()), $payload);

        return ['deleted' => count($ids)];
    }

    /**
     * @param list<float> $vector
     */
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $payload = [
            'vector' => array_values($vector),
            'limit' => (int) ($options['top_k'] ?? 10),
            'with_payload' => true,
            'with_vector' => (bool) ($options['include_vectors'] ?? false),
        ];

        $filter = $options['filter'] ?? $this->buildMetadataFilter($namespace->getMetadata());
        if (is_array($filter) && $filter !== []) {
            $payload['filter'] = $filter;
        }

        $response = $this->request('POST', sprintf('collections/%s/points/search', $namespace->getName()), $payload);
        $result = $this->normalizeHits($response['result'] ?? []);

        $metadata = array_filter([
            'collection' => $namespace->getName(),
            'match_count' => count($result),
        ]);

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $namespace->getName(),
            chunks: $result,
            metadata: $metadata,
        );
    }

    /**
     * @param list<array<string, mixed>> $hits
     *
     * @return list<array<string, mixed>>
     */
    private function normalizeHits(array $hits): array
    {
        $chunks = [];

        foreach ($hits as $hit) {
            if (!is_array($hit)) {
                continue;
            }

            $payload = is_array($hit['payload'] ?? null) ? $hit['payload'] : [];
            $text = $this->extractText($payload);
            if ($text === null) {
                continue;
            }

            $chunk = ['text' => $text];

            if (isset($hit['score'])) {
                $chunk['score'] = (float) $hit['score'];
            }

            if (isset($hit['id']) && trim((string) $hit['id']) !== '') {
                $chunk['document_id'] = trim((string) $hit['id']);
            }

            $documentName = $payload['title'] ?? $payload['document_name'] ?? null;
            if (is_string($documentName) && trim($documentName) !== '') {
                $chunk['document_name'] = trim($documentName);
                unset($payload['title'], $payload['document_name']);
            }

            if ($payload !== []) {
                $chunk['metadata'] = $payload;
            }

            $chunks[] = $chunk;
        }

        return array_values($chunks);
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     */
    private function buildMetadataFilter(array $metadata): array
    {
        if ($metadata === []) {
            return [];
        }

        $conditions = [];

        foreach ($metadata as $key => $value) {
            if (is_array($value)) {
                $conditions[] = [
                    'key' => $key,
                    'match' => ['any' => array_values($value)],
                ];
                continue;
            }

            $conditions[] = [
                'key' => $key,
                'match' => ['value' => $value],
            ];
        }

        return ['must' => $conditions];
    }

    private function extractText(array &$payload): ?string
    {
        foreach (['text', 'content', 'body'] as $key) {
            if (isset($payload[$key]) && is_string($payload[$key])) {
                $text = trim($payload[$key]);
                unset($payload[$key]);
                if ($text !== '') {
                    return $text;
                }
            }
        }

        return null;
    }

    /**
     * @param array<string, mixed> $payload
     *
     * @return array<string, mixed>
     */
    private function request(string $method, string $uri, array $payload): array
    {
        $headers = [
            'Accept' => 'application/json',
        ];

        if ($this->apiKey !== null && trim($this->apiKey) !== '') {
            $headers['api-key'] = $this->apiKey;
        }

        try {
            $response = $this->httpClient->request($method, $uri, [
                'headers' => $headers,
                'json' => $payload,
            ]);
        } catch (Throwable $exception) {
            throw new RuntimeException(
                sprintf('Qdrant request to "%s" failed: %s', $uri, $exception->getMessage()),
                (int) $exception->getCode(),
                $exception
            );
        }

        $contents = (string) $response->getBody();
        if ($contents === '') {
            return [];
        }

        /** @var array<string, mixed> $decoded */
        $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);

        return $decoded;
    }

    private function normalizeBaseUrl(string $url): string
    {
        $trimmed = trim($url);
        if ($trimmed === '') {
            throw new RuntimeException('Qdrant base URL cannot be empty.');
        }

        return str_ends_with($trimmed, '/') ? $trimmed : $trimmed . '/';
    }
}
</document_content>
</document>

<document index="89">
<source>src/VectorStore/VectorNamespace.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/VectorNamespace.php

namespace ParaGra\VectorStore;

use InvalidArgumentException;

use function array_is_list;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_string;
use function preg_replace;
use function sprintf;
use function strlen;
use function strtolower;
use function trim;

/**
 * Represents a logical namespace/collection within a vector store.
 *
 * Captures slugged identifiers, optional collections (indexes), metadata
 * filters, and eventual consistency hints so adapters can share the same
 * connection contract.
 */
final class VectorNamespace
{
    private string $name;

    private ?string $collection;

    /**
     * @var array<string, string|int|float|bool|list<string|int|float|bool>>
     */
    private array $metadata;

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     */
    public function __construct(
        string $name,
        ?string $collection = null,
        private readonly bool $eventuallyConsistent = false,
        array $metadata = [],
    ) {
        $this->name = $this->normalizeName($name);
        $this->collection = $this->normalizeCollection($collection);
        $this->metadata = $this->validateMetadata($metadata);
    }

    public function getName(): string
    {
        return $this->name;
    }

    public function getCollection(): ?string
    {
        return $this->collection;
    }

    public function isEventuallyConsistent(): bool
    {
        return $this->eventuallyConsistent;
    }

    /**
     * @return array<string, string|int|float|bool|list<string|int|float|bool>>
     */
    public function getMetadata(): array
    {
        return $this->metadata;
    }

    /**
     * @return array{
     *     name: string,
     *     collection: string|null,
     *     eventual_consistency: bool,
     *     metadata: array<string, string|int|float|bool|list<string|int|float|bool>>
     * }
     */
    public function toArray(): array
    {
        return [
            'name' => $this->name,
            'collection' => $this->collection,
            'eventual_consistency' => $this->eventuallyConsistent,
            'metadata' => $this->metadata,
        ];
    }

    private function normalizeName(string $name): string
    {
        $clean = trim($name);
        if ($clean === '') {
            throw new InvalidArgumentException('Vector namespace name cannot be empty.');
        }

        $slug = strtolower((string) preg_replace('/[^a-zA-Z0-9]+/', '-', $clean));
        $slug = trim($slug, '-');
        if ($slug === '') {
            throw new InvalidArgumentException(sprintf('Vector namespace name "%s" is invalid.', $name));
        }

        if ($slug !== '' && strlen($slug) > 64) {
            throw new InvalidArgumentException('Vector namespace names must be <= 64 characters.');
        }

        return $slug;
    }

    private function normalizeCollection(?string $collection): ?string
    {
        if ($collection === null) {
            return null;
        }

        $clean = trim($collection);

        return $clean === '' ? null : $clean;
    }

    /**
     * @param array<string, string|int|float|bool|list<string|int|float|bool>> $metadata
     *
     * @return array<string, string|int|float|bool|list<string|int|float|bool>>
     */
    private function validateMetadata(array $metadata): array
    {
        $validated = [];
        foreach ($metadata as $key => $value) {
            if (!is_string($key)) {
                throw new InvalidArgumentException('Metadata keys must be strings.');
            }

            $cleanKey = trim($key);
            if ($cleanKey === '') {
                throw new InvalidArgumentException('Metadata keys must be non-empty strings.');
            }

            $validated[$cleanKey] = $this->normalizeMetadataValue($value, $cleanKey);
        }

        return $validated;
    }

    /**
     * @return string|int|float|bool|list<string|int|float|bool>
     */
    private function normalizeMetadataValue(mixed $value, string $key): string|int|float|bool|array
    {
        if ($this->isScalar($value)) {
            return $value;
        }

        if (!is_array($value) || $value === []) {
            throw new InvalidArgumentException(
                sprintf('Metadata values must be scalar or non-empty lists (key: %s).', $key)
            );
        }

        if (!array_is_list($value)) {
            throw new InvalidArgumentException(
                sprintf('Metadata lists must be indexed sequentially (key: %s).', $key)
            );
        }

        $list = [];
        foreach ($value as $entry) {
            if (!$this->isScalar($entry)) {
                throw new InvalidArgumentException(
                    sprintf('Metadata list entries must be scalar (key: %s).', $key)
                );
            }
            $list[] = $entry;
        }

        return $list;
    }

    private function isScalar(mixed $value): bool
    {
        return is_string($value) || is_int($value) || is_float($value) || is_bool($value);
    }
}
</document_content>
</document>

<document index="90">
<source>src/VectorStore/VectorStoreInterface.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/VectorStoreInterface.php

namespace ParaGra\VectorStore;

use ParaGra\Response\UnifiedResponse;

/**
 * Abstraction that standardizes CRUD + query operations across vector stores
 * such as Pinecone, Weaviate, Qdrant, Chroma, or Gemini File Search.
 */
interface VectorStoreInterface
{
    /**
     * Machine-friendly provider slug (pinecone, qdrant, etc.).
     */
    public function getProvider(): string;

    /**
     * Default namespace used when callers omit an explicit target.
     */
    public function getDefaultNamespace(): VectorNamespace;

    /**
     * Insert or update embeddings within the namespace.
     *
     * @param list<array{
     *     id: string,
     *     values: list<float>,
     *     metadata?: array<string, mixed>
     * }> $records
     * @param array{
     *     consistency?: 'strong'|'eventual',
     *     wait_for_sync?: bool,
     *     timeout_ms?: int
     * } $options
     *
     * @return array{upserted: int, updated: int, task_id?: string}
     */
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array;

    /**
     * Delete embeddings by ID.
     *
     * @param list<string> $ids
     * @param array{
     *     wait_for_sync?: bool,
     *     timeout_ms?: int
     * } $options
     *
     * @return array{deleted: int}
     */
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array;

    /**
     * Execute a KNN search against the namespace.
     *
     * @param list<float> $vector
     * @param array{
     *     top_k?: int,
     *     filter?: array<string, mixed>,
     *     include_vectors?: bool
     * } $options
     */
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse;
}
</document_content>
</document>

<document index="91">
<source>src/VectorStore/WeaviateVectorStore.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/src/VectorStore/WeaviateVectorStore.php

namespace ParaGra\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use ParaGra\Response\UnifiedResponse;
use RuntimeException;
use Throwable;

use function array_filter;
use function array_is_list;
use function array_map;
use function array_values;
use function count;
use function implode;
use function in_array;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_numeric;
use function is_string;
use function json_decode;
use function max;
use function preg_match;
use function preg_replace;
use function sprintf;
use function str_ends_with;
use function trim;

use const JSON_THROW_ON_ERROR;

/**
 * HTTP + GraphQL adapter covering Weaviate batch upserts, deletions, and vector queries.
 */
final class WeaviateVectorStore implements VectorStoreInterface
{
    private ClientInterface $httpClient;

    private VectorNamespace $defaultNamespace;

    /** @var list<string> */
    private array $defaultProperties;

    /**
     * @param list<string> $defaultProperties
     */
    public function __construct(
        private readonly string $baseUrl,
        private readonly string $className,
        private readonly ?string $apiKey = null,
        ?VectorNamespace $defaultNamespace = null,
        private readonly string $consistencyLevel = 'ONE',
        array $defaultProperties = ['text'],
        ?ClientInterface $httpClient = null,
    ) {
        $this->defaultNamespace = $defaultNamespace ?? new VectorNamespace($className, $className);
        $this->defaultProperties = $this->sanitizeProperties($defaultProperties);
        $this->httpClient = $httpClient ?? new Client([
            'base_uri' => $this->normalizeBaseUrl($baseUrl),
            'timeout' => 30,
        ]);
    }

    #[\Override]
    public function getProvider(): string
    {
        return 'weaviate';
    }

    #[\Override]
    public function getDefaultNamespace(): VectorNamespace
    {
        return $this->defaultNamespace;
    }

    #[\Override]
    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        if ($records === []) {
            return ['upserted' => 0, 'updated' => 0];
        }

        $class = $this->resolveClass($namespace);
        $tenant = $this->resolveTenant($namespace, $options);

        $payload = [
            'objects' => array_map(
                fn (array $record): array => $this->formatUpsertRecord($class, $record, $tenant),
                $records
            ),
        ];

        $query = $this->buildConsistencyQuery($options);
        $headers = $this->buildHeaders($tenant);

        $this->request('POST', 'batch/objects', $payload, $query, $headers);

        return ['upserted' => count($records), 'updated' => 0];
    }

    #[\Override]
    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        if ($ids === []) {
            return ['deleted' => 0];
        }

        $class = $this->resolveClass($namespace);
        $tenant = $this->resolveTenant($namespace, $options);

        $where = $this->buildIdFilter($ids);
        $match = [
            'class' => $class,
            'where' => $where,
        ];

        if ($tenant !== null) {
            $match['tenant'] = $tenant;
        }

        $payload = [
            'match' => $match,
            'output' => 'minimal',
            'dryRun' => false,
        ];

        $headers = $this->buildHeaders($tenant);
        $query = $this->buildConsistencyQuery($options);
        $response = $this->request('DELETE', 'batch/objects', $payload, $query, $headers);

        $deleted = (int) ($response['results']['successful'] ?? $response['results']['successfullyDeleted'] ?? count($ids));

        return ['deleted' => $deleted];
    }

    #[\Override]
    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $class = $this->resolveClass($namespace);
        $tenant = $this->resolveTenant($namespace, $options);
        $consistency = $this->resolveConsistencyLevel($options);

        $properties = $this->resolveProperties($options['properties'] ?? null);
        $limit = (int) ($options['top_k'] ?? 10);
        $includeVectors = (bool) ($options['include_vectors'] ?? false);

        $whereFilter = $options['filter'] ?? $this->buildMetadataFilter($namespace);

        $queryString = $this->buildGraphqlQuery($class, $limit, $properties, $includeVectors);
        $variables = [
            'vector' => array_map(static fn (float $value): float => $value, array_values($vector)),
            'where' => $whereFilter,
            'tenant' => $tenant,
            'consistency' => $consistency,
        ];

        $headers = $this->buildHeaders($tenant);
        $response = $this->request('POST', 'graphql', [
            'query' => $queryString,
            'variables' => $variables,
        ], [], $headers);

        if (isset($response['errors']) && is_array($response['errors']) && $response['errors'] !== []) {
            $message = (string) ($response['errors'][0]['message'] ?? 'Unknown GraphQL error');
            throw new RuntimeException(sprintf('Weaviate GraphQL query failed: %s', $message));
        }

        $results = $response['data']['Get'][$class] ?? [];
        $chunks = $this->normalizeGraphqlResults(is_array($results) ? $results : [], $includeVectors);

        $metadata = array_filter([
            'class' => $class,
            'match_count' => count($chunks),
            'tenant' => $tenant,
        ]);

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: $class,
            chunks: $chunks,
            metadata: $metadata,
        );
    }

    /**
     * @param array{
     *     id: string,
     *     values: list<float>,
     *     metadata?: array<string, mixed>
     * } $record
     *
     * @return array<string, mixed>
     */
    private function formatUpsertRecord(string $class, array $record, ?string $tenant): array
    {
        $properties = $record['metadata'] ?? [];
        if (!is_array($properties)) {
            $properties = [];
        }

        $payload = [
            'id' => (string) $record['id'],
            'class' => $class,
            'vector' => array_map(static fn (float $value): float => $value, $record['values']),
            'properties' => $properties,
        ];

        if ($tenant !== null) {
            $payload['tenant'] = $tenant;
        }

        return $payload;
    }

    /**
     * @param list<string> $ids
     *
     * @return array<string, mixed>
     */
    private function buildIdFilter(array $ids): array
    {
        $ids = array_values($ids);
        if (count($ids) === 1) {
            return [
                'path' => ['id'],
                'operator' => 'Equal',
                'valueText' => $ids[0],
            ];
        }

        return [
            'path' => ['id'],
            'operator' => 'ContainsAny',
            'valueStringArray' => $ids,
        ];
    }

    /**
     * @return array<string, string>
     */
    private function buildConsistencyQuery(array $options): array
    {
        $level = (string) ($options['consistency_level'] ?? $this->consistencyLevel);
        $trimmed = trim($level);

        return $trimmed === '' ? [] : ['consistency_level' => $trimmed];
    }

    private function resolveConsistencyLevel(array $options): ?string
    {
        $level = (string) ($options['consistency_level'] ?? $this->consistencyLevel);
        $trimmed = trim($level);

        return $trimmed === '' ? null : $trimmed;
    }

    /**
     * @return list<string>
     */
    private function resolveProperties(?array $overrides): array
    {
        if ($overrides === null) {
            return $this->defaultProperties;
        }

        return $this->sanitizeProperties($overrides) ?: $this->defaultProperties;
    }

    /**
     * @param list<string> $properties
     *
     * @return list<string>
     */
    private function sanitizeProperties(array $properties): array
    {
        $sanitized = [];

        foreach ($properties as $property) {
            if (!is_string($property)) {
                continue;
            }

            $clean = trim($property);
            if ($clean === '') {
                continue;
            }

            $slug = (string) preg_replace('/[^A-Za-z0-9_]/', '', $clean);
            if ($slug === '' || in_array($slug, $sanitized, true)) {
                continue;
            }

            $sanitized[] = $slug;
        }

        return $sanitized === [] ? ['text'] : $sanitized;
    }

    private function resolveClass(VectorNamespace $namespace): string
    {
        return $namespace->getCollection() ?? $this->className;
    }

    private function resolveTenant(VectorNamespace $namespace, array $options): ?string
    {
        $tenant = $options['tenant'] ?? null;
        if (is_string($tenant) && trim($tenant) !== '') {
            return trim($tenant);
        }

        $metadata = $namespace->getMetadata();
        $candidate = $metadata['tenant'] ?? null;

        return is_string($candidate) && trim($candidate) !== '' ? trim($candidate) : null;
    }

    private function buildGraphqlQuery(string $class, int $limit, array $properties, bool $includeVectors): string
    {
        $propertySelection = '';
        foreach ($properties as $property) {
            $propertySelection .= '      ' . $property . PHP_EOL;
        }

        $additionalFields = ['id', 'score', 'distance', 'certainty'];
        if ($includeVectors) {
            $additionalFields[] = 'vector';
        }

        $additionalSelection = implode(PHP_EOL, array_values(array_unique($additionalFields)));

        return sprintf(
            <<<'GQL'
query($vector: [Float!], $where: WhereFilter, $tenant: String, $consistency: ConsistencyLevel) {
  Get {
    %s(
      limit: %d
      nearVector: { vector: $vector }
      where: $where
      tenant: $tenant
      consistencyLevel: $consistency
    ) {
%s      _additional {
        %s
      }
    }
  }
}
GQL,
            $class,
            $limit,
            $propertySelection,
            $additionalSelection
        );
    }

    /**
     * @return list<array<string, mixed>>
     */
    private function normalizeGraphqlResults(array $results, bool $includeVectors): array
    {
        $chunks = [];

        foreach ($results as $item) {
            if (!is_array($item)) {
                continue;
            }

            $additional = is_array($item['_additional'] ?? null) ? $item['_additional'] : [];
            unset($item['_additional']);

            $properties = $item;
            $text = $this->extractText($properties);
            if ($text === null) {
                continue;
            }

            $chunk = ['text' => $text];

            $score = $this->resolveScore($additional);
            if ($score !== null) {
                $chunk['score'] = $score;
            }

            if (isset($additional['id']) && is_string($additional['id']) && trim($additional['id']) !== '') {
                $chunk['document_id'] = trim($additional['id']);
            }

            $documentName = $properties['document_name'] ?? $properties['title'] ?? null;
            if (is_string($documentName) && trim($documentName) !== '') {
                $chunk['document_name'] = trim($documentName);
                unset($properties['document_name'], $properties['title']);
            } else {
                unset($properties['document_name'], $properties['title']);
            }

            if ($includeVectors && isset($additional['vector']) && is_array($additional['vector'])) {
                $chunk['vector'] = array_map(
                    static fn ($value): float => (float) $value,
                    array_values($additional['vector'])
                );
            }

            if ($properties !== []) {
                $chunk['metadata'] = $properties;
            }

            $chunks[] = $chunk;
        }

        return $chunks;
    }

    private function extractText(array &$properties): ?string
    {
        foreach (['text', 'content', 'body'] as $key) {
            if (isset($properties[$key]) && is_string($properties[$key])) {
                $text = trim($properties[$key]);
                unset($properties[$key]);
                if ($text !== '') {
                    return $text;
                }
            }
        }

        return null;
    }

    /**
     * @param array<string, mixed>|null $metadata
     *
     * @return array<string, mixed>|null
     */
    private function buildMetadataFilter(VectorNamespace $namespace): ?array
    {
        $metadata = $namespace->getMetadata();
        unset($metadata['tenant']);

        if ($metadata === []) {
            return null;
        }

        $operands = [];
        foreach ($metadata as $key => $value) {
            if (is_array($value)) {
                if ($value === [] || !array_is_list($value)) {
                    continue;
                }

                $operands[] = [
                    'path' => [$key],
                    'operator' => 'ContainsAny',
                ] + $this->buildArrayValue($value);
                continue;
            }

            $operands[] = [
                'path' => [$key],
                'operator' => 'Equal',
            ] + $this->buildScalarValue($value);
        }

        if ($operands === []) {
            return null;
        }

        return ['operator' => 'And', 'operands' => $operands];
    }

    /**
     * @param list<string|int|float|bool> $values
     *
     * @return array<string, list<string|int|float|bool>>
     */
    private function buildArrayValue(array $values): array
    {
        $first = $values[0];

        if (is_int($first)) {
            return ['valueIntArray' => array_map(static fn (int $v): int => $v, $values)];
        }

        if (is_float($first)) {
            return ['valueNumberArray' => array_map(static fn (float $v): float => $v, $values)];
        }

        if (is_bool($first)) {
            return ['valueBooleanArray' => array_map(static fn (bool $v): bool => $v, $values)];
        }

        return ['valueStringArray' => array_map(static fn ($v): string => (string) $v, $values)];
    }

    /**
     * @return array<string, string|int|float|bool>
     */
    private function buildScalarValue(string|int|float|bool $value): array
    {
        if (is_int($value)) {
            return ['valueInt' => $value];
        }

        if (is_float($value)) {
            return ['valueNumber' => $value];
        }

        if (is_bool($value)) {
            return ['valueBoolean' => $value];
        }

        return ['valueText' => $value];
    }

    private function resolveScore(array $additional): ?float
    {
        foreach (['score', 'certainty'] as $key) {
            if (isset($additional[$key]) && is_numeric($additional[$key])) {
                return (float) $additional[$key];
            }
        }

        if (isset($additional['distance']) && is_numeric($additional['distance'])) {
            $distance = (float) $additional['distance'];

            return max(0.0, 1 - $distance);
        }

        return null;
    }

    /**
     * @param array<string, mixed> $payload
     * @param array<string, string> $query
     * @param array<string, string> $headers
     *
     * @return array<string, mixed>
     */
    private function request(string $method, string $uri, array $payload, array $query, array $headers): array
    {
        $options = [
            'headers' => $headers,
        ];

        if ($payload !== []) {
            $options['json'] = $payload;
        }

        if ($query !== []) {
            $options['query'] = $query;
        }

        try {
            $response = $this->httpClient->request($method, $uri, $options);
        } catch (Throwable $exception) {
            throw new RuntimeException(
                sprintf('Weaviate request to "%s" failed: %s', $uri, $exception->getMessage()),
                (int) $exception->getCode(),
                $exception
            );
        }

        $contents = (string) $response->getBody();
        if ($contents === '') {
            return [];
        }

        /** @var array<string, mixed> $decoded */
        $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);

        return $decoded;
    }

    /**
     * @return array<string, string>
     */
    private function buildHeaders(?string $tenant): array
    {
        $headers = [
            'Accept' => 'application/json',
        ];

        if ($this->apiKey !== null && trim($this->apiKey) !== '') {
            $headers['Authorization'] = 'Bearer ' . trim($this->apiKey);
        }

        if ($tenant !== null) {
            $headers['X-Weaviate-Tenant'] = $tenant;
        }

        return $headers;
    }

    private function normalizeBaseUrl(string $baseUrl): string
    {
        $trimmed = trim($baseUrl);
        if ($trimmed === '') {
            throw new RuntimeException('Weaviate base URL cannot be empty.');
        }

        $normalized = str_ends_with($trimmed, '/') ? $trimmed : $trimmed . '/';
        if (preg_match('#/v1/?$#', $normalized) === 1) {
            return str_ends_with($normalized, '/') ? $normalized : $normalized . '/';
        }

        return $normalized . 'v1/';
    }
}
</document_content>
</document>

<document index="92">
<source>tests/Assistant/AskYodaHostedAdapterTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Assistant/AskYodaHostedAdapterTest.php

namespace ParaGra\Tests\Assistant;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Assistant\AskYodaHostedAdapter;
use ParaGra\Assistant\AskYodaHostedResult;
use ParaGra\Llm\AskYodaClient;
use PHPUnit\Framework\TestCase;

final class AskYodaHostedAdapterTest extends TestCase
{
    public function test_ask_returns_result_and_emits_success_telemetry(): void
    {
        $handler = new MockHandler([
            new Response(200, [], json_encode([
                'result' => 'AskYoda answer',
                'chunks_ids' => ['alpha', 'beta'],
                'llm_provider' => 'google',
                'llm_model' => 'gemini-2.0-flash-exp',
                'cost' => 0.01,
            ], JSON_THROW_ON_ERROR)),
        ]);
        $client = $this->askYodaClient($handler);
        $adapter = new AskYodaHostedAdapter($client);

        $events = [];
        $result = $adapter->ask('Explain ParaGra', telemetry: function (string $event, array $context) use (&$events): void {
            $events[] = [$event, $context];
        });

        self::assertInstanceOf(AskYodaHostedResult::class, $result);
        self::assertSame('AskYoda answer', $result->getResponse()->getResult());
        self::assertGreaterThanOrEqual(0, $result->getDurationMs());
        self::assertSame(2, $result->getChunkCount());

        self::assertNotEmpty($events);
        [$event, $context] = $events[0];
        self::assertSame('askyoda.success', $event);
        self::assertSame(2, $context['chunk_count'] ?? null);
        self::assertArrayHasKey('duration_ms', $context);
    }

    public function test_ask_emits_failure_event_before_throwing(): void
    {
        $handler = new MockHandler([
            new Response(500, [], 'internal error'),
        ]);
        $client = $this->askYodaClient($handler);
        $adapter = new AskYodaHostedAdapter($client);

        $events = [];

        $this->expectException(\RuntimeException::class);
        try {
            $adapter->ask('Fallback please', telemetry: function (string $event, array $context) use (&$events): void {
                $events[] = [$event, $context];
            });
        } finally {
            self::assertNotEmpty($events);
            self::assertSame('askyoda.failure', $events[0][0] ?? null);
            self::assertArrayHasKey('error', $events[0][1]);
        }
    }

    private function askYodaClient(MockHandler $handler): AskYodaClient
    {
        $http = new HttpClient([
            'handler' => HandlerStack::create($handler),
        ]);

        return new AskYodaClient(
            apiKey: 'eden-key',
            projectId: 'eden-project',
            httpClient: $http
        );
    }
}
</document_content>
</document>

<document index="93">
<source>tests/Assistant/RagAnswerTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Assistant/RagAnswerTest.php

namespace ParaGra\Tests\Assistant;

use ParaGra\Assistant\RagAnswer;
use ParaGra\Llm\ChatResponse;
use ParaGra\Llm\ChatUsage;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;
use Ragie\RetrievalResult;

#[CoversClass(RagAnswer::class)]
#[UsesClass(ChatResponse::class)]
#[UsesClass(ChatUsage::class)]
final class RagAnswerTest extends TestCase
{
    public function test_accessors_expose_context_usage_and_metadata(): void
    {
        $retrieval = $this->createStub(RetrievalResult::class);
        $retrieval->method('getChunkTexts')->willReturn(['chunk-1', 'chunk-2']);

        $usage = new ChatUsage(promptTokens: 42, completionTokens: 17, totalTokens: 59);
        $chatResponse = new ChatResponse(
            text: 'final answer',
            usage: $usage,
            rawResponse: ['id' => 'chat-123']
        );

        $answer = new RagAnswer(
            question: 'What is ParaGra?',
            answer: 'A multi-provider RAG orchestrator.',
            retrievalResult: $retrieval,
            chatResponse: $chatResponse,
            prompt: 'prompt text',
            executionTimeMs: 1200,
            metadata: [
                'fallback_used' => true,
                'fallback_provider' => 'askyoda',
                'notes' => 'rate-limit fallback',
            ]
        );

        self::assertSame('What is ParaGra?', $answer->getQuestion());
        self::assertSame('A multi-provider RAG orchestrator.', $answer->getAnswer());
        self::assertSame(['chunk-1', 'chunk-2'], $answer->getContextTexts());
        self::assertSame($usage, $answer->getChatUsage());
        self::assertSame($chatResponse, $answer->getChatResponse());
        self::assertSame('prompt text', $answer->getPrompt());
        self::assertSame(1200, $answer->getExecutionTimeMs());
        self::assertTrue($answer->isFallback());
        self::assertSame('askyoda', $answer->getFallbackProvider());
        self::assertSame('rate-limit fallback', $answer->getMetadata()['notes']);
    }

    public function test_fallback_helpers_when_metadata_missing(): void
    {
        $retrieval = $this->createStub(RetrievalResult::class);
        $retrieval->method('getChunkTexts')->willReturn([]);

        $chatResponse = new ChatResponse(
            text: 'content',
            usage: new ChatUsage(1, 1, 2),
            rawResponse: null
        );

        $answer = new RagAnswer(
            question: 'Q',
            answer: 'A',
            retrievalResult: $retrieval,
            chatResponse: $chatResponse,
            prompt: 'prompt',
            executionTimeMs: 5,
            metadata: ['source' => 'primary']
        );

        self::assertFalse($answer->isFallback());
        self::assertNull($answer->getFallbackProvider());
        self::assertSame(['source' => 'primary'], $answer->getMetadata());
    }
}
</document_content>
</document>

<document index="94">
<source>tests/Assistant/RagAnswererTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Assistant/RagAnswererTest.php

namespace ParaGra\Tests\Assistant;

use ParaGra\Assistant\RagAnswer;
use ParaGra\Assistant\RagAnswerer;
use ParaGra\Exception\ConfigurationException;
use ParaGra\Llm\AskYodaClient;
use ParaGra\Llm\AskYodaResponse;
use ParaGra\Llm\ChatRequestOptions;
use ParaGra\Llm\ChatResponse;
use ParaGra\Llm\ChatUsage;
use ParaGra\Llm\OpenAiChatClient;
use ParaGra\Llm\PromptBuilder;
use ParaGra\Moderation\ModerationException;
use ParaGra\Moderation\ModerationResult;
use ParaGra\Moderation\ModeratorInterface;
use ParaGra\Tests\Logging\SpyLogger;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Ragie\Api\ApiException;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Client as RagieClient;
use Ragie\Exception\InvalidQueryException;
use Ragie\Logging\StructuredLogger;
use Ragie\Metrics\CostTracker;
use Ragie\Metrics\MetricsCollector;
use Ragie\RetrievalOptions;
use Ragie\RetrievalResult;

final class RagAnswererTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        // Clear environment variables before each test
        unset($_ENV['RAGIE_API_KEY']);
        unset($_ENV['OPENAI_API_KEY']);
        unset($_ENV['OPENAI_BASE_URL']);
        unset($_ENV['OPENAI_API_MODEL']);
    }

    public function testAnswerCombinesRetrievalAndChat(): void
    {
        $retrievalResult = $this->fakeRetrievalResult([
            ['text' => 'First context snippet', 'score' => 0.9, 'document_id' => 'doc-1'],
            ['text' => 'Second snippet', 'score' => 0.8, 'document_id' => 'doc-2'],
        ]);

        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient
            ->expects($this->once())
            ->method('retrieve')
            ->with(
                'What is Ragie?',
                $this->logicalOr($this->isInstanceOf(RetrievalOptions::class), $this->isNull())
            )
            ->willReturn($retrievalResult);

        $chatResponse = new ChatResponse(
            text: 'Ragie is a retrieval service.',
            usage: new ChatUsage(promptTokens: 30, completionTokens: 12, totalTokens: 42),
            rawResponse: null
        );

        $chatClient = $this->createMock(OpenAiChatClient::class);
        \assert($chatClient instanceof OpenAiChatClient);
        $chatClient
            ->expects($this->once())
            ->method('generateText')
            ->with($this->callback(function (string $prompt): bool {
                $this->assertStringContainsString('First context snippet', $prompt);
                $this->assertStringContainsString('Second snippet', $prompt);
                $this->assertStringContainsString('What is Ragie?', $prompt);

                return true;
            }), $this->isInstanceOf(ChatRequestOptions::class))
            ->willReturn($chatResponse);

        $answerer = new RagAnswerer(
            ragieClient: $ragieClient,
            chatClient: $chatClient,
            promptBuilder: new PromptBuilder(),
        );

        $answer = $answerer->answer('What is Ragie?');

        $this->assertInstanceOf(RagAnswer::class, $answer);
        $this->assertSame('Ragie is a retrieval service.', $answer->getAnswer());
        $this->assertCount(2, $answer->getContextTexts());
        $this->assertSame(42, $answer->getChatUsage()->totalTokens);
        $this->assertStringContainsString('What is Ragie?', $answer->getPrompt());
    }

    public function testAnswerEmitsChatCompletionLog(): void
    {
        $retrievalResult = $this->fakeRetrievalResult([
            ['text' => 'Snippet', 'score' => 0.9],
        ]);

        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrievalResult);
        $ragieClient->method('getMetricsCollector')->willReturn(null);
        $ragieClient->method('getCostTracker')->willReturn(null);
        $ragieClient->method('getStructuredLogger')->willReturn(null);
        $ragieClient->expects($this->once())
            ->method('withStructuredLogger')
            ->willReturnSelf();

        $chatResponse = new ChatResponse(
            text: 'Answer',
            usage: new ChatUsage(promptTokens: 10, completionTokens: 5, totalTokens: 15),
            rawResponse: null
        );

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient->expects($this->once())
            ->method('generateText')
            ->willReturn($chatResponse);

        $spy = new SpyLogger();

        $answerer = new RagAnswerer(
            ragieClient: $ragieClient,
            chatClient: $chatClient,
            promptBuilder: new PromptBuilder(),
            structuredLogger: new StructuredLogger($spy)
        );

        $answerer->answer('What is Ragie?');

        $messages = array_column($spy->records, 'message');
        $this->assertContains('ragie.chat.success', $messages);
    }

    public function testFallbackLogsStructuredEvent(): void
    {
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->expects($this->once())
            ->method('retrieve')
            ->willThrowException(new ApiException('rate', 429));
        $ragieClient->method('getMetricsCollector')->willReturn(null);
        $ragieClient->method('getCostTracker')->willReturn(null);
        $ragieClient->method('getStructuredLogger')->willReturn(null);
        $ragieClient->expects($this->once())
            ->method('withStructuredLogger')
            ->willReturnSelf();

        $askYodaClient = $this->createMock(AskYodaClient::class);
        $askYodaClient->expects($this->once())
            ->method('ask')
            ->willReturn(new AskYodaResponse([
                'result' => 'Fallback answer',
                'llm_provider' => 'edenai',
                'llm_model' => 'askyoda-large',
                'cost' => 0.02,
                'usage' => [
                    'input_tokens' => 20,
                    'output_tokens' => 10,
                    'total_tokens' => 30,
                ],
                'chunks_ids' => ['chunk-1'],
            ]));

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient->expects($this->never())->method('generateText');

        $spy = new SpyLogger();

        $answerer = new RagAnswerer(
            ragieClient: $ragieClient,
            chatClient: $chatClient,
            promptBuilder: new PromptBuilder(),
            askYodaClient: $askYodaClient,
            structuredLogger: new StructuredLogger($spy)
        );

        $answer = $answerer->answer('Need fallback');
        $this->assertSame('Fallback answer', $answer->getAnswer());

        $messages = array_column($spy->records, 'message');
        $this->assertContains('ragie.fallback.used', $messages);
        $this->assertContains('ragie.chat.success', $messages);
    }

    public function testWithStructuredLoggerReturnsInstance(): void
    {
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->method('getMetricsCollector')->willReturn(null);
        $ragieClient->method('getCostTracker')->willReturn(null);
        $ragieClient->method('getStructuredLogger')->willReturn(null);
        $ragieClient->expects($this->once())
            ->method('withStructuredLogger')
            ->willReturnSelf();

        $chatClient = $this->createMock(OpenAiChatClient::class);

        $answerer = new RagAnswerer(
            ragieClient: $ragieClient,
            chatClient: $chatClient,
            promptBuilder: new PromptBuilder()
        );

        $spy = new SpyLogger();
        $logger = new StructuredLogger($spy);

        $result = $answerer->withStructuredLogger($logger);

        $this->assertSame($answerer, $result);
    }

    /**
     * @param array<int, array{text: string, score: float, document_id?: string}> $chunks
     */
    private function fakeRetrievalResult(array $chunks): RetrievalResult
    {
        $scoredChunks = [];
        $index = 0;
        foreach ($chunks as $chunk) {
            $scoredChunks[] = new ScoredChunk([
                'text' => $chunk['text'],
                'score' => $chunk['score'],
                'id' => 'chunk-' . $index,
                'index' => $index,
                'metadata' => [],
                'document_id' => $chunk['document_id'] ?? 'doc-' . $index,
                'document_name' => 'Document ' . $index,
                'document_metadata' => [],
                'links' => [],
            ]);
            $index++;
        }

        $retrieval = new Retrieval([
            'scored_chunks' => $scoredChunks,
        ]);

        return new RetrievalResult($retrieval);
    }

    public function testFromEnvCreatesAnswerer(): void
    {
        $_ENV['RAGIE_API_KEY'] = 'test-ragie-key';
        $_ENV['OPENAI_API_KEY'] = 'test-openai-key';

        $answerer = RagAnswerer::fromEnv();

        $this->assertInstanceOf(RagAnswerer::class, $answerer);
    }

    public function testFromEnvThrowsWhenRagieApiKeyMissing(): void
    {
        // Ensure RAGIE_API_KEY is truly not set
        unset($_ENV['RAGIE_API_KEY']);
        if (getenv('RAGIE_API_KEY') !== false) {
            putenv('RAGIE_API_KEY');
        }

        $_ENV['OPENAI_API_KEY'] = 'test-openai-key';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('RAGIE_API_KEY');

        RagAnswerer::fromEnv();
    }

    public function testFromEnvThrowsWhenOpenAiApiKeyMissing(): void
    {
        // Ensure OPENAI_API_KEY is truly not set
        unset($_ENV['OPENAI_API_KEY']);
        if (getenv('OPENAI_API_KEY') !== false) {
            putenv('OPENAI_API_KEY');
        }

        $_ENV['RAGIE_API_KEY'] = 'test-ragie-key';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('OPENAI_API_KEY');

        RagAnswerer::fromEnv();
    }

    public function testFromEnvUsesDefaultOpenAiModel(): void
    {
        $_ENV['RAGIE_API_KEY'] = 'test-ragie-key';
        $_ENV['OPENAI_API_KEY'] = 'test-openai-key';

        $answerer = RagAnswerer::fromEnv();

        // We can't directly inspect the internal chatClient config,
        // but we can verify the answerer was created successfully
        $this->assertInstanceOf(RagAnswerer::class, $answerer);
    }

    public function testAnswerSanitizesQuestionBeforeProcessing(): void
    {
        $dirtyQuestion = "  What is Ragie?\0  ";

        $retrievalResult = $this->fakeRetrievalResult([
            ['text' => 'Snippet', 'score' => 0.9, 'document_id' => 'doc-1'],
        ]);

        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient
            ->expects($this->once())
            ->method('retrieve')
            ->with('What is Ragie?', $this->isInstanceOf(RetrievalOptions::class))
            ->willReturn($retrievalResult);

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient
            ->expects($this->once())
            ->method('generateText')
            ->with($this->isType('string'), $this->isInstanceOf(ChatRequestOptions::class))
            ->willReturn(new ChatResponse(
                text: 'Answer',
                usage: new ChatUsage(promptTokens: 1, completionTokens: 1, totalTokens: 2),
                rawResponse: null
            ));

        $answerer = new RagAnswerer($ragieClient, $chatClient, new PromptBuilder());

        $answer = $answerer->answer($dirtyQuestion);

        $this->assertSame('What is Ragie?', $answer->getQuestion());
    }

    public function testAnswerRejectsControlCharacters(): void
    {
        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $chatClient = $this->createMock(OpenAiChatClient::class);

        $answerer = new RagAnswerer($ragieClient, $chatClient, new PromptBuilder());

        $this->expectException(InvalidQueryException::class);

        $answerer->answer("Hello\x07World");
    }

    public function testAnswerRecordsOpenAiCostAndModerationMetrics(): void
    {
        $retrievalResult = $this->fakeRetrievalResult([
            ['text' => 'Snippet', 'score' => 0.9],
        ]);

        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->expects($this->once())
            ->method('retrieve')
            ->willReturn($retrievalResult);

        $chatResponse = new ChatResponse(
            text: 'Telemetry answer.',
            usage: new ChatUsage(promptTokens: 60, completionTokens: 10, totalTokens: 70),
            rawResponse: null
        );

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient->expects($this->once())
            ->method('generateText')
            ->willReturn($chatResponse);

        $moderator = $this->createMock(ModeratorInterface::class);
        $moderator->expects($this->once())
            ->method('moderate')
            ->willReturn(new ModerationResult(
                flagged: false,
                categories: ['hate' => false],
                categoryScores: ['hate' => 0.01]
            ));

        $metrics = new MetricsCollector();
        $costTracker = new CostTracker();

        $answerer = new RagAnswerer(
            $ragieClient,
            $chatClient,
            new PromptBuilder(),
            null,
            null,
            null,
            $moderator,
            $metrics,
            $costTracker
        );

        $answerer->answer('Explain telemetry');

        $this->assertSame(1, $costTracker->getOpenAiCalls());
        $this->assertSame(60, $costTracker->getPromptTokens());

        $moderationEvents = array_values(array_filter(
            $metrics->getEvents(),
            fn (array $event): bool => ($event['type'] ?? null) === 'moderation'
        ));

        $this->assertCount(1, $moderationEvents);
        $this->assertFalse($moderationEvents[0]['flagged']);
        $this->assertSame(['hate' => false], $moderationEvents[0]['categories']);
    }

    public function testAnswerRecordsModerationFailureMetrics(): void
    {
        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->expects($this->never())->method('retrieve');

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient->expects($this->never())->method('generateText');

        $moderationException = new ModerationException(
            'flagged',
            ['violence' => true],
            ['violence' => 0.9]
        );

        $moderator = $this->createMock(ModeratorInterface::class);
        $moderator->expects($this->once())
            ->method('moderate')
            ->willThrowException($moderationException);

        $metrics = new MetricsCollector();
        $costTracker = new CostTracker();

        $answerer = new RagAnswerer(
            $ragieClient,
            $chatClient,
            new PromptBuilder(),
            null,
            null,
            null,
            $moderator,
            $metrics,
            $costTracker
        );

        try {
            $answerer->answer('Forbidden content');
            $this->fail('Expected ModerationException to be thrown');
        } catch (ModerationException $e) {
            $this->assertSame('flagged', $e->getMessage());
        }

        $moderationEvents = array_values(array_filter(
            $metrics->getEvents(),
            fn (array $event): bool => ($event['type'] ?? null) === 'moderation'
        ));

        $this->assertCount(1, $moderationEvents);
        $this->assertTrue($moderationEvents[0]['flagged']);
        $this->assertSame(['violence' => true], $moderationEvents[0]['categories']);
    }

    public function testFallbackRecordsAskYodaMetricsOnRateLimit(): void
    {
        $retrievalException = new ApiException('rate limited', 429);

        /** @var RagieClient&MockObject $ragieClient */
        $ragieClient = $this->createMock(RagieClient::class);
        $ragieClient->expects($this->once())
            ->method('retrieve')
            ->willThrowException($retrievalException);

        $chatClient = $this->createMock(OpenAiChatClient::class);
        $chatClient->expects($this->never())->method('generateText');

        $askYodaClient = $this->createMock(AskYodaClient::class);
        $askYodaClient->expects($this->once())
            ->method('ask')
            ->willReturn(new AskYodaResponse([
                'result' => 'Fallback answer',
                'chunks_ids' => ['chunk-1', 'chunk-2'],
                'llm_provider' => 'askyoda',
                'llm_model' => 'edenai',
                'usage' => [
                    'input_tokens' => 15,
                    'output_tokens' => 10,
                    'total_tokens' => 25,
                ],
            ]));

        $metrics = new MetricsCollector();
        $costTracker = new CostTracker();

        $answerer = new RagAnswerer(
            $ragieClient,
            $chatClient,
            new PromptBuilder(),
            null,
            null,
            $askYodaClient,
            null,
            $metrics,
            $costTracker
        );

        $answer = $answerer->answer('Fallback please?');

        $retrievalEvents = array_values(array_filter(
            $metrics->getEvents(),
            fn (array $event): bool => ($event['type'] ?? null) === 'retrieval'
                && ($event['source'] ?? null) === 'askyoda'
        ));

        $this->assertCount(1, $retrievalEvents);
        $this->assertTrue($retrievalEvents[0]['success']);
        $this->assertSame(2, $retrievalEvents[0]['chunk_count']);
        $this->assertTrue($answer->isFallback());
        $this->assertSame('askyoda', $answer->getFallbackProvider());
    }
}
</document_content>
</document>

<document index="95">
<source>tests/Config/PriorityPoolTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Config/PriorityPoolTest.php

namespace ParaGra\Tests\Config;

use InvalidArgumentException;
use ParaGra\Config\PriorityPool;
use ParaGra\Config\ProviderSpec;
use ParaGra\ProviderCatalog\ProviderDiscovery;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;

use function dirname;
use function putenv;

#[CoversClass(PriorityPool::class)]
#[UsesClass(ProviderSpec::class)]
final class PriorityPoolTest extends TestCase
{
    public function test_from_array_when_config_valid_then_returns_nested_specs(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'key-1',
                    'solution' => [
                        'type' => 'ragie',
                        'ragie_api_key' => 'ragie-1',
                    ],
                ],
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'key-2',
                    'solution' => [
                        'type' => 'ragie',
                        'ragie_api_key' => 'ragie-2',
                    ],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'key-3',
                    'solution' => [
                        'type' => 'ragie',
                        'ragie_api_key' => 'ragie-3',
                    ],
                ],
            ],
        ];

        $pool = PriorityPool::fromArray($config);

        self::assertSame(2, $pool->getPoolCount());
        $firstPool = $pool->getPool(0);
        self::assertCount(2, $firstPool);
        self::assertInstanceOf(ProviderSpec::class, $firstPool[0]);
        self::assertSame('key-1', $firstPool[0]->apiKey);

        $secondPool = $pool->getPool(1);
        self::assertCount(1, $secondPool);
        self::assertSame('openai', $secondPool[0]->provider);

        self::assertSame([], $pool->getPool(5));
    }

    public function test_from_array_when_pool_contains_non_array_then_throws(): void
    {
        $config = [
            [
                'provider' => 'openai',
                'model' => 'gpt-4o-mini',
                'api_key' => 'key',
                'solution' => ['type' => 'ragie'],
            ],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Pool "0" entry "0" must be an array.');

        PriorityPool::fromArray($config);
    }

    public function test_from_array_when_spec_invalid_then_bubbles_exception(): void
    {
        $config = [
            [
                [
                    'provider' => 'openai',
                    'model' => '   ',
                    'api_key' => 'key',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('model');

        PriorityPool::fromArray($config);
    }

    public function test_constructor_when_pool_not_array_then_throws(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Pool "0" must be an array.');

        /** @phpstan-ignore-next-line intentionally passing invalid structure */
        new PriorityPool(['not-an-array']);
    }

    public function test_constructor_when_pool_contains_non_provider_spec_then_throws(): void
    {
        $validSpec = new ProviderSpec(
            provider: 'cerebras',
            model: 'llama-3.1',
            apiKey: 'key-1',
            solution: ['type' => 'ragie'],
        );

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('contains invalid entry of type "string"');

        /** @phpstan-ignore-next-line intentionally mixed contents */
        new PriorityPool([[$validSpec, 'oops']]);
    }

    public function test_from_array_when_pool_not_array_then_throws(): void
    {
        $config = [
            /** @phpstan-ignore-next-line intentionally invalid */
            'not-a-pool',
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Pool "0" must be an array of provider specs.');

        PriorityPool::fromArray($config);
    }

    public function test_from_array_when_solution_contains_nested_metadata_then_preserved(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'key-1',
                    'solution' => [
                        'type' => 'ragie',
                        'metadata' => [
                            'tier' => 'free',
                            'notes' => 'rotation',
                        ],
                        'default_options' => [
                            'top_k' => 8,
                            'rerank' => true,
                        ],
                    ],
                ],
            ],
        ];

        $pool = PriorityPool::fromArray($config);
        $specs = $pool->getPool(0);

        self::assertCount(1, $specs);
        self::assertSame('free', $specs[0]->solution['metadata']['tier']);
        self::assertTrue($specs[0]->solution['default_options']['rerank']);
        self::assertSame(8, $specs[0]->solution['default_options']['top_k']);
    }

    public function test_from_array_when_catalog_entry_then_builds_spec_with_overrides(): void
    {
        $catalogPath = dirname(__DIR__, 2) . '/config/providers/catalog.php';
        $catalog = ProviderDiscovery::fromFile($catalogPath);
        putenv('OPENAI_API_KEY=test-openai');

        try {
            $config = [
                [
                    [
                        'catalog' => [
                            'slug' => 'openai',
                            'model_type' => 'generation',
                            'overrides' => [
                                'solution' => [
                                    'metadata' => [
                                        'tier' => 'paid',
                                    ],
                                ],
                            ],
                        ],
                        'latency_tier' => 'medium',
                        'cost_ceiling' => 0.08,
                        'compliance' => ['soc2'],
                    ],
                ],
            ];

            $pool = PriorityPool::fromArray($config, $catalog);
            $specs = $pool->getPool(0);

            self::assertCount(1, $specs);
            self::assertSame('openai', $specs[0]->provider);
            self::assertSame('test-openai', $specs[0]->apiKey);
            self::assertSame('gpt-4o-mini', $specs[0]->model);
            self::assertSame('medium', $specs[0]->solution['metadata']['latency_tier']);
            self::assertSame(0.08, $specs[0]->solution['metadata']['cost_ceiling']);
            self::assertSame(['soc2'], $specs[0]->solution['metadata']['compliance']);
            self::assertSame('paid', $specs[0]->solution['metadata']['tier']);
        } finally {
            putenv('OPENAI_API_KEY');
        }
    }

    public function test_from_array_when_catalog_entry_without_discovery_then_throws(): void
    {
        $config = [
            [
                [
                    'catalog' => [
                        'slug' => 'openai',
                    ],
                ],
            ],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Catalog-backed provider entries require a provider catalog');

        PriorityPool::fromArray($config);
    }

    public function test_catalog_entry_metadata_overrides_merge_all_sources(): void
    {
        $expectedSpec = new ProviderSpec(
            provider: 'voyage',
            model: 'voyage-2',
            apiKey: 'voyage-key',
            solution: ['type' => 'embedding']
        );

        $catalog = $this->createMock(ProviderDiscovery::class);
        $catalog->expects(self::once())
            ->method('buildProviderSpec')
            ->with(
                'voyage',
                'embeddings',
                self::callback(function (array $overrides): bool {
                    self::assertArrayHasKey('solution', $overrides);
                    self::assertArrayHasKey('metadata', $overrides['solution']);
                    $metadata = $overrides['solution']['metadata'];

                    self::assertSame('free-final', $metadata['tier']);
                    self::assertSame('final-latency', $metadata['latency_tier']);
                    self::assertSame(0.04, $metadata['cost_ceiling']);
                    self::assertSame(['soc2'], $metadata['compliance']);
                    self::assertSame('spec-override', $metadata['notes']);
                    self::assertSame('us', $metadata['region']);

                    return true;
                })
            )
            ->willReturn($expectedSpec);

        $config = [
            [
                [
                    'catalog' => [
                        'slug' => 'askyoda',
                        'model_type' => 'generation',
                        'metadata' => [
                            'tier' => 'catalog-base',
                            'latency_tier' => 'catalog-latency',
                        ],
                        'metadata_overrides' => [
                            'notes' => 'catalog-note',
                            'region' => 'catalog-region',
                        ],
                    ],
                    'catalog_slug' => 'voyage',
                    'catalog_model_type' => 'embeddings',
                    'catalog_overrides' => [
                        'solution' => [
                            'metadata' => [
                                'cost_ceiling' => 0.12,
                                'latency_tier' => 'override-latency',
                            ],
                        ],
                    ],
                    'metadata_overrides' => [
                        'notes' => 'spec-override',
                        'region' => 'us',
                    ],
                    'tier' => 'free-final',
                    'latency_tier' => 'final-latency',
                    'cost_ceiling' => 0.04,
                    'compliance' => ['soc2'],
                ],
            ],
        ];

        $pool = PriorityPool::fromArray($config, $catalog);
        $specs = $pool->getPool(0);

        self::assertCount(1, $specs);
        self::assertSame($expectedSpec, $specs[0]);
    }

    public function test_catalog_reference_when_slug_blank_then_throws(): void
    {
        $catalog = $this->createStub(ProviderDiscovery::class);

        $config = [
            [
                [
                    'catalog' => [
                        'slug' => '   ',
                    ],
                ],
            ],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('slug');

        PriorityPool::fromArray($config, $catalog);
    }
}
</document_content>
</document>

<document index="96">
<source>tests/Config/ProviderSpecTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Config/ProviderSpecTest.php

namespace ParaGra\Tests\Config;

use InvalidArgumentException;
use ParaGra\Config\ProviderSpec;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(ProviderSpec::class)]
final class ProviderSpecTest extends TestCase
{
    public function test_from_array_when_data_valid_then_returns_instance(): void
    {
        $data = [
            'provider' => ' openai ',
            'model' => ' gpt-4o-mini ',
            'api_key' => ' sk-test ',
            'solution' => [
                'type' => 'ragie',
                'ragie_api_key' => 'ragie-test',
                'ragie_partition' => 'default',
            ],
        ];

        $spec = ProviderSpec::fromArray($data);

        self::assertSame('openai', $spec->provider, 'Provider should be trimmed.');
        self::assertSame('gpt-4o-mini', $spec->model);
        self::assertSame('sk-test', $spec->apiKey);
        self::assertSame('ragie', $spec->solution['type']);

        $expected = [
            'provider' => 'openai',
            'model' => 'gpt-4o-mini',
            'api_key' => 'sk-test',
            'solution' => [
                'type' => 'ragie',
                'ragie_api_key' => 'ragie-test',
                'ragie_partition' => 'default',
            ],
        ];

        self::assertSame($expected, $spec->toArray(), 'Round-trip array payload should stay stable.');
    }

    public function test_from_array_when_required_key_missing_then_throws(): void
    {
        $data = [
            'model' => 'gpt-4o-mini',
            'api_key' => 'sk-test',
            'solution' => ['type' => 'ragie'],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('provider');

        ProviderSpec::fromArray($data);
    }

    public function test_from_array_when_solution_not_array_then_throws(): void
    {
        $data = [
            'provider' => 'openai',
            'model' => 'gpt-4o-mini',
            'api_key' => 'sk-test',
            'solution' => 'ragie',
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('solution');

        ProviderSpec::fromArray($data);
    }

    public function test_from_array_when_string_empty_then_throws(): void
    {
        $data = [
            'provider' => '   ',
            'model' => 'gpt-4o-mini',
            'api_key' => 'sk-test',
            'solution' => ['type' => 'ragie'],
        ];

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('provider');

        ProviderSpec::fromArray($data);
    }
}
</document_content>
</document>

<document index="97">
<source>tests/Embedding/CohereEmbeddingConfigTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/CohereEmbeddingConfigTest.php

namespace ParaGra\Tests\Embedding;

use InvalidArgumentException;
use ParaGra\Embedding\CohereEmbeddingConfig;
use ParaGra\Exception\ConfigurationException;
use PHPUnit\Framework\TestCase;

final class CohereEmbeddingConfigTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        unset(
            $_ENV['COHERE_API_KEY'],
            $_ENV['COHERE_EMBED_MODEL'],
            $_ENV['COHERE_EMBED_INPUT_TYPE'],
            $_ENV['COHERE_EMBED_TRUNCATE'],
            $_ENV['COHERE_EMBED_TYPES'],
            $_ENV['COHERE_EMBED_BASE_URL'],
            $_ENV['COHERE_EMBED_ENDPOINT'],
            $_ENV['COHERE_EMBED_MAX_BATCH']
        );
        putenv('COHERE_API_KEY');
        putenv('COHERE_EMBED_MODEL');
        putenv('COHERE_EMBED_INPUT_TYPE');
        putenv('COHERE_EMBED_TRUNCATE');
        putenv('COHERE_EMBED_TYPES');
        putenv('COHERE_EMBED_BASE_URL');
        putenv('COHERE_EMBED_ENDPOINT');
        putenv('COHERE_EMBED_MAX_BATCH');
    }

    public function test_from_env_uses_defaults(): void
    {
        $_ENV['COHERE_API_KEY'] = 'ckey';

        $config = CohereEmbeddingConfig::fromEnv();

        self::assertSame('ckey', $config->apiKey);
        self::assertSame('embed-english-v3.0', $config->model);
        self::assertSame('search_document', $config->inputType);
        self::assertNull($config->truncate);
        self::assertSame(['float'], $config->embeddingTypes);
        self::assertSame(96, $config->maxBatchSize);
        self::assertSame('https://api.cohere.ai', $config->baseUri);
        self::assertSame('/v1/embed', $config->endpoint);
        self::assertSame(1024, $config->defaultDimensions);
    }

    public function test_from_env_honors_custom_values(): void
    {
        $_ENV['COHERE_API_KEY'] = 'custom';
        $_ENV['COHERE_EMBED_MODEL'] = 'embed-english-light-v3.0';
        $_ENV['COHERE_EMBED_INPUT_TYPE'] = 'search_query';
        $_ENV['COHERE_EMBED_TRUNCATE'] = 'END';
        $_ENV['COHERE_EMBED_TYPES'] = 'float,int8';
        $_ENV['COHERE_EMBED_BASE_URL'] = 'https://proxy.example/api';
        $_ENV['COHERE_EMBED_ENDPOINT'] = '/v2024/embed';
        $_ENV['COHERE_EMBED_MAX_BATCH'] = '24';

        $config = CohereEmbeddingConfig::fromEnv();

        self::assertSame('custom', $config->apiKey);
        self::assertSame('embed-english-light-v3.0', $config->model);
        self::assertSame('search_query', $config->inputType);
        self::assertSame('END', $config->truncate);
        self::assertSame(['float', 'int8'], $config->embeddingTypes);
        self::assertSame('https://proxy.example/api', $config->baseUri);
        self::assertSame('/v2024/embed', $config->endpoint);
        self::assertSame(24, $config->maxBatchSize);
        self::assertSame(384, $config->defaultDimensions);
    }

    public function test_from_env_rejects_invalid_embedding_type(): void
    {
        $_ENV['COHERE_API_KEY'] = 'ckey';
        $_ENV['COHERE_EMBED_TYPES'] = 'float,weird';

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('COHERE_EMBED_TYPES');

        CohereEmbeddingConfig::fromEnv();
    }

    public function test_from_env_requires_api_key(): void
    {
        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('COHERE_API_KEY');

        CohereEmbeddingConfig::fromEnv();
    }
}
</document_content>
</document>

<document index="98">
<source>tests/Embedding/CohereEmbeddingProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/CohereEmbeddingProviderTest.php

namespace ParaGra\Tests\Embedding;

use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use ParaGra\Embedding\CohereEmbeddingConfig;
use ParaGra\Embedding\CohereEmbeddingProvider;
use ParaGra\Embedding\EmbeddingRequest;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use RuntimeException;

final class CohereEmbeddingProviderTest extends TestCase
{
    public function test_embed_sends_payload_and_returns_vectors(): void
    {
        $config = new CohereEmbeddingConfig(
            apiKey: 'ckey',
            model: 'embed-english-v3.0',
            inputType: 'search_document',
            truncate: 'END',
            embeddingTypes: ['float'],
            maxBatchSize: 8,
            baseUri: 'https://api.cohere.ai',
            endpoint: '/v1/embed',
            defaultDimensions: 1024,
        );

        $request = new EmbeddingRequest(
            inputs: [
                ['id' => 'doc-1', 'text' => ' First chunk ', 'metadata' => ['source' => 'kb']],
                'Second chunk',
            ],
            normalize: true,
        );

        $responseBody = json_encode([
            'id' => 'embed-123',
            'embeddings' => [
                'float' => [
                    [3.0, 4.0],
                    [1.0, 0.0],
                ],
            ],
            'meta' => [
                'billed_units' => ['input_tokens' => 64],
            ],
        ], JSON_THROW_ON_ERROR);

        $response = new Response(200, [], $responseBody);

        /** @var ClientInterface&MockObject $client */
        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->with(
                'POST',
                'https://api.cohere.ai/v1/embed',
                $this->callback(function (array $options): bool {
                    self::assertSame('Bearer ckey', $options['headers']['Authorization']);
                    self::assertSame('application/json', $options['headers']['Content-Type']);
                    self::assertSame('application/json', $options['headers']['Accept']);
                    self::assertSame([
                        'model' => 'embed-english-v3.0',
                        'texts' => ['First chunk', 'Second chunk'],
                        'input_type' => 'search_document',
                        'truncate' => 'END',
                        'embedding_types' => ['float'],
                    ], $options['json']);

                    return true;
                })
            )
            ->willReturn($response);

        $provider = new CohereEmbeddingProvider($config, $client);
        $result = $provider->embed($request);

        self::assertSame('cohere', $result['provider']);
        self::assertSame('embed-english-v3.0', $result['model']);
        self::assertSame(2, $result['dimensions']);
        self::assertCount(2, $result['vectors']);
        self::assertSame('doc-1', $result['vectors'][0]['id']);
        self::assertEqualsWithDelta([0.6, 0.8], $result['vectors'][0]['values'], 1e-9);
        self::assertSame(['source' => 'kb'], $result['vectors'][0]['metadata']);
        self::assertSame(['input_tokens' => 64], $result['usage']);
    }

    public function test_embed_throws_when_batch_limit_exceeded(): void
    {
        $config = new CohereEmbeddingConfig(
            apiKey: 'ckey',
            model: 'embed-english-v3.0',
            maxBatchSize: 1,
            embeddingTypes: ['float'],
            inputType: 'search_document',
        );

        $provider = new CohereEmbeddingProvider($config, $this->createMock(ClientInterface::class));

        $request = new EmbeddingRequest(['one', 'two']);

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('batch limit');

        $provider->embed($request);
    }

    public function test_embed_rejects_dimension_override(): void
    {
        $config = new CohereEmbeddingConfig(
            apiKey: 'ckey',
            model: 'embed-english-v3.0',
            embeddingTypes: ['float'],
            inputType: 'search_document',
        );

        $request = new EmbeddingRequest(['text'], dimensions: 123);

        $provider = new CohereEmbeddingProvider($config, $this->createMock(ClientInterface::class));

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('dimensions');

        $provider->embed($request);
    }

    public function test_embed_wraps_http_errors(): void
    {
        $config = new CohereEmbeddingConfig(
            apiKey: 'ckey',
            model: 'embed-english-v3.0',
            embeddingTypes: ['float'],
            inputType: 'search_document',
        );

        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->willThrowException(new RequestException('boom', new Request('POST', 'https://api.cohere.ai/v1/embed')));

        $provider = new CohereEmbeddingProvider($config, $client);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Cohere embeddings request failed');

        $provider->embed(new EmbeddingRequest(['text']));
    }

    public function test_metadata_methods(): void
    {
        $config = new CohereEmbeddingConfig(
            apiKey: 'ckey',
            model: 'embed-multilingual-light-v3.0',
            embeddingTypes: ['float'],
            inputType: 'search_document',
            maxBatchSize: 4,
            defaultDimensions: 384,
        );

        $provider = new CohereEmbeddingProvider($config, $this->createMock(ClientInterface::class));

        $dimensions = $provider->getSupportedDimensions();

        self::assertSame('cohere', $provider->getProvider());
        self::assertSame('embed-multilingual-light-v3.0', $provider->getModel());
        self::assertContains(384, $dimensions);
        self::assertContains(1024, $dimensions);
        self::assertSame(4, $provider->getMaxBatchSize());
    }
}
</document_content>
</document>

<document index="99">
<source>tests/Embedding/EmbeddingRequestTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/EmbeddingRequestTest.php

namespace ParaGra\Tests\Embedding;

use InvalidArgumentException;
use ParaGra\Embedding\EmbeddingRequest;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(EmbeddingRequest::class)]
final class EmbeddingRequestTest extends TestCase
{
    public function test_it_normalizes_inputs_and_metadata(): void
    {
        $request = new EmbeddingRequest(
            inputs: [
                '  first chunk  ',
                [
                    'id' => ' doc-2 ',
                    'text' => ' second chunk ',
                    'metadata' => [
                        'source' => 'docs',
                        'lang' => 'en',
                        'score' => 0.92,
                        'tags' => ['faq', 'intro'],
                    ],
                ],
            ],
            dimensions: 1536,
            normalize: false,
            metadataFilter: [
                'source' => ['docs', 'kb'],
                'lang' => 'en',
            ],
        );

        self::assertSame(2, $request->getBatchSize());
        self::assertSame(1536, $request->getDimensions());
        self::assertFalse($request->shouldNormalize());
        self::assertSame(
            [
                [
                    'id' => null,
                    'text' => 'first chunk',
                    'metadata' => null,
                ],
                [
                    'id' => 'doc-2',
                    'text' => 'second chunk',
                    'metadata' => [
                        'source' => 'docs',
                        'lang' => 'en',
                        'score' => 0.92,
                        'tags' => ['faq', 'intro'],
                    ],
                ],
            ],
            $request->getInputs(),
        );
        self::assertSame(
            [
                'source' => ['docs', 'kb'],
                'lang' => 'en',
            ],
            $request->getMetadataFilter(),
        );
    }

    public function test_it_rejects_empty_batches(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('EmbeddingRequest requires at least one input.');

        new EmbeddingRequest([]);
    }

    public function test_it_rejects_empty_text_payload(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Embedding input 0 must include non-empty text.');

        new EmbeddingRequest(['   ']);
    }

    public function test_it_rejects_non_string_inputs(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Embedding inputs must be strings or arrays.');

        new EmbeddingRequest([42]);
    }

    public function test_it_rejects_invalid_metadata_filter_types(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('metadata filter');

        new EmbeddingRequest(
            inputs: ['one'],
            metadataFilter: ['source' => ['docs' => 'kb']]
        );
    }

    public function test_to_array_exposes_full_payload(): void
    {
        $request = new EmbeddingRequest(['alpha'], metadataFilter: ['lang' => 'en']);

        self::assertSame(
            [
                'inputs' => [
                    [
                        'id' => null,
                        'text' => 'alpha',
                        'metadata' => null,
                    ],
                ],
                'dimensions' => null,
                'normalize' => true,
                'metadata_filter' => ['lang' => 'en'],
            ],
            $request->toArray(),
        );
    }

    public function test_dimensions_must_be_positive(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Dimensions must be positive');

        new EmbeddingRequest(inputs: ['text'], dimensions: 0);
    }
}
</document_content>
</document>

<document index="100">
<source>tests/Embedding/GeminiEmbeddingConfigTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/GeminiEmbeddingConfigTest.php

namespace ParaGra\Tests\Embedding;

use Gemini\Enums\TaskType;
use ParaGra\Embedding\GeminiEmbeddingConfig;
use ParaGra\Exception\ConfigurationException;
use PHPUnit\Framework\TestCase;

final class GeminiEmbeddingConfigTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        unset(
            $_ENV['GEMINI_EMBED_API_KEY'],
            $_ENV['GEMINI_EMBED_MODEL'],
            $_ENV['GEMINI_EMBED_MAX_BATCH'],
            $_ENV['GEMINI_EMBED_DIMENSIONS'],
            $_ENV['GEMINI_EMBED_BASE_URL'],
            $_ENV['GEMINI_EMBED_TASK_TYPE'],
            $_ENV['GEMINI_EMBED_TITLE'],
            $_ENV['GOOGLE_API_KEY']
        );

        putenv('GEMINI_EMBED_API_KEY');
        putenv('GEMINI_EMBED_MODEL');
        putenv('GEMINI_EMBED_MAX_BATCH');
        putenv('GEMINI_EMBED_DIMENSIONS');
        putenv('GEMINI_EMBED_BASE_URL');
        putenv('GEMINI_EMBED_TASK_TYPE');
        putenv('GEMINI_EMBED_TITLE');
        putenv('GOOGLE_API_KEY');
    }

    public function test_from_env_with_google_fallback_and_overrides(): void
    {
        $_ENV['GOOGLE_API_KEY'] = 'google-key';
        $_ENV['GEMINI_EMBED_MODEL'] = 'embedding-001';
        $_ENV['GEMINI_EMBED_MAX_BATCH'] = '120';
        $_ENV['GEMINI_EMBED_DIMENSIONS'] = '3072';
        $_ENV['GEMINI_EMBED_BASE_URL'] = 'https://custom.example/v1beta/';
        $_ENV['GEMINI_EMBED_TASK_TYPE'] = 'retrieval_document';
        $_ENV['GEMINI_EMBED_TITLE'] = 'ParaGra batch';

        $config = GeminiEmbeddingConfig::fromEnv();

        self::assertSame('google-key', $config->apiKey);
        self::assertSame('embedding-001', $config->model);
        self::assertSame(120, $config->maxBatchSize);
        self::assertSame('https://custom.example/v1beta/', $config->baseUrl);
        self::assertSame(TaskType::RETRIEVAL_DOCUMENT, $config->taskType);
        self::assertSame('ParaGra batch', $config->title);
        self::assertSame(3072, $config->defaultDimensions);
    }

    public function test_from_env_requires_some_api_key(): void
    {
        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('GEMINI_EMBED_API_KEY');

        GeminiEmbeddingConfig::fromEnv();
    }

    public function test_from_env_rejects_invalid_dimension_override(): void
    {
        $_ENV['GEMINI_EMBED_API_KEY'] = 'key';
        $_ENV['GEMINI_EMBED_MODEL'] = 'embedding-001';
        $_ENV['GEMINI_EMBED_DIMENSIONS'] = '1024';

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('does not support overriding dimensions');

        GeminiEmbeddingConfig::fromEnv();
    }

    public function test_from_env_rejects_unknown_task_type(): void
    {
        $_ENV['GEMINI_EMBED_API_KEY'] = 'key';
        $_ENV['GEMINI_EMBED_TASK_TYPE'] = 'not-a-task';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('Unsupported task type');

        GeminiEmbeddingConfig::fromEnv();
    }
}
</document_content>
</document>

<document index="101">
<source>tests/Embedding/GeminiEmbeddingProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/GeminiEmbeddingProviderTest.php

namespace ParaGra\Tests\Embedding;

use Gemini\Contracts\ClientContract as GeminiClient;
use Gemini\Contracts\Resources\EmbeddingModalContract;
use Gemini\Enums\TaskType;
use Gemini\Requests\GenerativeModel\EmbedContentRequest;
use Gemini\Responses\GenerativeModel\BatchEmbedContentsResponse;
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\GeminiEmbeddingConfig;
use ParaGra\Embedding\GeminiEmbeddingProvider;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use RuntimeException;

final class GeminiEmbeddingProviderTest extends TestCase
{
    public function test_embed_sends_requests_and_normalizes_vectors(): void
    {
        $config = new GeminiEmbeddingConfig(
            apiKey: 'test',
            model: 'text-embedding-004',
            maxBatchSize: 5,
            baseUrl: null,
            taskType: TaskType::RETRIEVAL_DOCUMENT,
            title: 'ParaGra embeddings',
            defaultDimensions: 1536,
        );

        $request = new EmbeddingRequest(
            inputs: [
                ['id' => 'doc-1', 'text' => ' First chunk ', 'metadata' => ['source' => 'kb']],
                'Second chunk',
            ],
            dimensions: 512,
            normalize: true,
        );

        $response = BatchEmbedContentsResponse::from([
            'embeddings' => [
                ['values' => [3.0, 4.0]],
                ['values' => [0.0, 1.0]],
            ],
        ]);

        [$provider, $resource] = $this->makeProvider($config);
        $capturedBodies = [];
        $resource
            ->expects(self::once())
            ->method('batchEmbedContents')
            ->with(
                self::callback(function (EmbedContentRequest $req) use (&$capturedBodies): bool {
                    $capturedBodies[] = $req->body();
                    return true;
                }),
                self::callback(function (EmbedContentRequest $req) use (&$capturedBodies): bool {
                    $capturedBodies[] = $req->body();
                    return true;
                })
            )
            ->willReturn($response);

        $result = $provider->embed($request);

        self::assertSame('gemini', $result['provider']);
        self::assertSame('text-embedding-004', $result['model']);
        self::assertSame(2, $result['dimensions']);
        self::assertCount(2, $result['vectors']);
        self::assertSame('doc-1', $result['vectors'][0]['id']);
        self::assertEqualsWithDelta([0.6, 0.8], $result['vectors'][0]['values'], 1e-9);
        self::assertSame(['source' => 'kb'], $result['vectors'][0]['metadata']);
        self::assertNull($result['vectors'][1]['id']);
        self::assertEqualsWithDelta([0.0, 1.0], $result['vectors'][1]['values'], 1e-9);
        self::assertNull($result['usage']);

        self::assertCount(2, $capturedBodies);
        self::assertSame('RETRIEVAL_DOCUMENT', $capturedBodies[0]['taskType']);
        self::assertSame(512, $capturedBodies[0]['outputDimensionality']);
        self::assertSame('ParaGra embeddings', $capturedBodies[0]['title']);
        self::assertSame('Second chunk', $capturedBodies[1]['content']['parts'][0]['text']);
    }

    public function test_embed_disallows_dimension_override_for_fixed_models(): void
    {
        $config = new GeminiEmbeddingConfig(
            apiKey: 'key',
            model: 'embedding-001',
            maxBatchSize: 2,
            defaultDimensions: 3072,
        );

        $provider = new GeminiEmbeddingProvider($config, $this->createMock(GeminiClient::class));
        $request = new EmbeddingRequest(['alpha'], dimensions: 1024);

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('does not support overriding dimensions');

        $provider->embed($request);
    }

    public function test_embed_throws_when_batch_exceeds_limit(): void
    {
        $config = new GeminiEmbeddingConfig(
            apiKey: 'key',
            model: 'text-embedding-004',
            maxBatchSize: 1,
        );

        $provider = new GeminiEmbeddingProvider($config, $this->createMock(GeminiClient::class));
        $request = new EmbeddingRequest(['one', 'two']);

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('batch exceeds the configured batch limit');

        $provider->embed($request);
    }

    public function test_embed_wraps_gemini_errors(): void
    {
        $config = new GeminiEmbeddingConfig(
            apiKey: 'key',
            model: 'text-embedding-004',
            maxBatchSize: 2,
        );

        /** @var EmbeddingModalContract&MockObject $resource */
        $resource = $this->createMock(EmbeddingModalContract::class);
        $resource
            ->expects(self::once())
            ->method('batchEmbedContents')
            ->willThrowException(new \RuntimeException('boom'));

        /** @var GeminiClient&MockObject $client */
        $client = $this->createMock(GeminiClient::class);
        $client
            ->method('embeddingModel')
            ->willReturn($resource);

        $provider = new GeminiEmbeddingProvider($config, $client);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Gemini embeddings request failed');

        $provider->embed(new EmbeddingRequest(['chunk']));
    }

    public function test_metadata_helpers(): void
    {
        $config = new GeminiEmbeddingConfig(
            apiKey: 'key',
            model: 'text-embedding-004',
            maxBatchSize: 3,
            defaultDimensions: 768,
        );

        $provider = new GeminiEmbeddingProvider($config, $this->createMock(GeminiClient::class));
        $dimensions = $provider->getSupportedDimensions();

        self::assertSame('gemini', $provider->getProvider());
        self::assertSame('text-embedding-004', $provider->getModel());
        self::assertContains(768, $dimensions);
        self::assertSame(3, $provider->getMaxBatchSize());
    }

    /**
     * @return array{
     *     0: GeminiEmbeddingProvider,
     *     1: EmbeddingModalContract&MockObject
     * }
     */
    private function makeProvider(GeminiEmbeddingConfig $config): array
    {
        /** @var EmbeddingModalContract&MockObject $resource */
        $resource = $this->createMock(EmbeddingModalContract::class);

        /** @var GeminiClient&MockObject $client */
        $client = $this->createMock(GeminiClient::class);
        $client
            ->expects(self::once())
            ->method('embeddingModel')
            ->with($config->model)
            ->willReturn($resource);

        return [new GeminiEmbeddingProvider($config, $client), $resource];
    }
}
</document_content>
</document>

<document index="102">
<source>tests/Embedding/OpenAiEmbeddingConfigTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/OpenAiEmbeddingConfigTest.php

namespace ParaGra\Tests\Embedding;

use ParaGra\Embedding\OpenAiEmbeddingConfig;
use ParaGra\Exception\ConfigurationException;
use PHPUnit\Framework\TestCase;

final class OpenAiEmbeddingConfigTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        unset(
            $_ENV['OPENAI_API_KEY'],
            $_ENV['OPENAI_EMBED_MODEL'],
            $_ENV['OPENAI_EMBED_BASE_URL'],
            $_ENV['OPENAI_EMBED_MAX_BATCH'],
            $_ENV['OPENAI_EMBED_DIMENSIONS']
        );
    }

    public function test_from_env_with_defaults(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'embed-key';

        $config = OpenAiEmbeddingConfig::fromEnv();

        self::assertSame('embed-key', $config->apiKey);
        self::assertSame('text-embedding-3-small', $config->model);
        self::assertNull($config->baseUrl);
        self::assertSame(2048, $config->maxBatchSize);
        self::assertSame(1536, $config->defaultDimensions);
    }

    public function test_from_env_with_custom_values(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'override-key';
        $_ENV['OPENAI_EMBED_MODEL'] = 'text-embedding-3-large';
        $_ENV['OPENAI_EMBED_BASE_URL'] = 'https://proxy.example/v1';
        $_ENV['OPENAI_EMBED_MAX_BATCH'] = '512';
        $_ENV['OPENAI_EMBED_DIMENSIONS'] = '256';

        $config = OpenAiEmbeddingConfig::fromEnv();

        self::assertSame('override-key', $config->apiKey);
        self::assertSame('text-embedding-3-large', $config->model);
        self::assertSame('https://proxy.example/v1', $config->baseUrl);
        self::assertSame(512, $config->maxBatchSize);
        self::assertSame(256, $config->defaultDimensions);
    }

    public function test_from_env_treats_zero_dimension_and_batch_as_null_and_default(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key';
        $_ENV['OPENAI_EMBED_DIMENSIONS'] = '0';
        $_ENV['OPENAI_EMBED_MAX_BATCH'] = '0';

        $config = OpenAiEmbeddingConfig::fromEnv();

        self::assertSame(2048, $config->maxBatchSize, 'Zero batch should reset to default.');
        self::assertNull($config->defaultDimensions, 'Zero dimension string should become null.');
    }

    public function test_from_env_requires_api_key(): void
    {
        unset($_ENV['OPENAI_API_KEY']);
        if (getenv('OPENAI_API_KEY') !== false) {
            putenv('OPENAI_API_KEY');
        }

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('OPENAI_API_KEY');

        OpenAiEmbeddingConfig::fromEnv();
    }
}
</document_content>
</document>

<document index="103">
<source>tests/Embedding/OpenAiEmbeddingProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/OpenAiEmbeddingProviderTest.php

namespace ParaGra\Tests\Embedding;

use InvalidArgumentException;
use OpenAI\Contracts\ClientContract as OpenAiClient;
use OpenAI\Contracts\Resources\EmbeddingsContract as OpenAiEmbeddingsResource;
use OpenAI\Responses\Embeddings\CreateResponse;
use OpenAI\Responses\Meta\MetaInformation;
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\OpenAiEmbeddingConfig;
use ParaGra\Embedding\OpenAiEmbeddingProvider;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use RuntimeException;

final class OpenAiEmbeddingProviderTest extends TestCase
{
    public function test_embed_sends_payload_and_returns_normalized_vectors(): void
    {
        $config = new OpenAiEmbeddingConfig(
            apiKey: 'test-key',
            model: 'text-embedding-3-small',
            baseUrl: null,
            maxBatchSize: 5,
            defaultDimensions: 768,
        );

        $request = new EmbeddingRequest(
            inputs: [
                [
                    'id' => 'doc-1',
                    'text' => ' First chunk ',
                    'metadata' => ['source' => 'kb'],
                ],
                'Second chunk',
            ],
            normalize: true,
        );

        $response = $this->fakeEmbeddingsResponse([
            [3.0, 4.0],
            [1.0, 0.0],
        ]);

        [$provider, $resource] = $this->makeProvider($config);
        $resource
            ->expects(self::once())
            ->method('create')
            ->with($this->callback(function (array $payload): bool {
                self::assertSame('text-embedding-3-small', $payload['model']);
                self::assertSame(['First chunk', 'Second chunk'], $payload['input']);
                self::assertSame(768, $payload['dimensions']);

                return true;
            }))
            ->willReturn($response);

        $result = $provider->embed($request);

        self::assertSame('openai', $result['provider']);
        self::assertSame('text-embedding-3-small', $result['model']);
        self::assertSame(2, $result['dimensions']);
        self::assertCount(2, $result['vectors']);
        self::assertSame('doc-1', $result['vectors'][0]['id']);
        self::assertEqualsWithDelta([0.6, 0.8], $result['vectors'][0]['values'], 1e-9);
        self::assertSame(['source' => 'kb'], $result['vectors'][0]['metadata']);
        self::assertNull($result['vectors'][1]['id']);
        self::assertSame([1.0, 0.0], $result['vectors'][1]['values']);
        self::assertSame(
            ['prompt_tokens' => 42, 'total_tokens' => 84],
            $result['usage'],
        );
    }

    public function test_embed_respects_request_dimensions_and_skip_normalization(): void
    {
        $config = new OpenAiEmbeddingConfig(
            apiKey: 'test',
            model: 'text-embedding-3-large',
            baseUrl: null,
            maxBatchSize: 3,
            defaultDimensions: null,
        );

        $request = new EmbeddingRequest(
            inputs: ['alpha', 'beta'],
            dimensions: 512,
            normalize: false,
        );

        $response = $this->fakeEmbeddingsResponse([
            [0.25, 0.25, 0.25, 0.25],
            [0.5, 0.5, 0.5, 0.5],
        ]);

        [$provider, $resource] = $this->makeProvider($config);
        $resource
            ->expects(self::once())
            ->method('create')
            ->with($this->callback(function (array $payload): bool {
                self::assertSame(512, $payload['dimensions'], 'Request dimensions should override defaults.');

                return true;
            }))
            ->willReturn($response);

        $result = $provider->embed($request);

        self::assertSame([0.25, 0.25, 0.25, 0.25], $result['vectors'][0]['values']);
        self::assertSame([0.5, 0.5, 0.5, 0.5], $result['vectors'][1]['values']);
    }

    public function test_embed_throws_when_batch_exceeds_limit(): void
    {
        $config = new OpenAiEmbeddingConfig(
            apiKey: 'test',
            model: 'text-embedding-3-small',
            baseUrl: null,
            maxBatchSize: 1,
            defaultDimensions: 1536,
        );

        $request = new EmbeddingRequest(['one', 'two']);

        $provider = new OpenAiEmbeddingProvider($config, $this->createMock(OpenAiClient::class));

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('exceeds the configured batch limit');

        $provider->embed($request);
    }

    public function test_embed_wraps_client_errors(): void
    {
        $config = new OpenAiEmbeddingConfig(
            apiKey: 'test',
            model: 'text-embedding-3-small',
            baseUrl: null,
            maxBatchSize: 2,
            defaultDimensions: 1536,
        );

        $request = new EmbeddingRequest(['single']);

        /** @var OpenAiEmbeddingsResource&MockObject $resource */
        $resource = $this->createMock(OpenAiEmbeddingsResource::class);
        $resource
            ->expects(self::once())
            ->method('create')
            ->willThrowException(new \RuntimeException('boom'));

        /** @var OpenAiClient&MockObject $client */
        $client = $this->createMock(OpenAiClient::class);
        $client
            ->expects(self::once())
            ->method('embeddings')
            ->willReturn($resource);

        $provider = new OpenAiEmbeddingProvider($config, $client);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Failed to generate embeddings');

        $provider->embed($request);
    }

    public function test_metadata_methods(): void
    {
        $config = new OpenAiEmbeddingConfig(
            apiKey: 'test',
            model: 'text-embedding-3-small',
            baseUrl: null,
            maxBatchSize: 7,
            defaultDimensions: 1024,
        );

        $provider = new OpenAiEmbeddingProvider($config, $this->createMock(OpenAiClient::class));

        $dimensions = $provider->getSupportedDimensions();

        self::assertSame('openai', $provider->getProvider());
        self::assertSame('text-embedding-3-small', $provider->getModel());
        self::assertContains(1024, $dimensions, 'Config default should appear in supported dims.');
        self::assertContains(1536, $dimensions, 'Known OpenAI dimension should be exposed.');
        self::assertSame(7, $provider->getMaxBatchSize());
    }

    /**
     * @return array{0: OpenAiEmbeddingProvider, 1: OpenAiEmbeddingsResource&MockObject}
     */
    private function makeProvider(OpenAiEmbeddingConfig $config): array
    {
        /** @var OpenAiEmbeddingsResource&MockObject $resource */
        $resource = $this->createMock(OpenAiEmbeddingsResource::class);

        /** @var OpenAiClient&MockObject $client */
        $client = $this->createMock(OpenAiClient::class);
        $client
            ->expects(self::once())
            ->method('embeddings')
            ->willReturn($resource);

        return [new OpenAiEmbeddingProvider($config, $client), $resource];
    }

    /**
     * @param list<list<float>> $vectors
     */
    private function fakeEmbeddingsResponse(array $vectors): CreateResponse
    {
        $data = [];
        foreach ($vectors as $index => $values) {
            $data[] = [
                'object' => 'embedding',
                'index' => $index,
                'embedding' => $values,
            ];
        }

        return CreateResponse::from([
            'object' => 'list',
            'model' => 'text-embedding-3-small',
            'data' => $data,
            'usage' => [
                'prompt_tokens' => 42,
                'total_tokens' => 84,
            ],
        ], MetaInformation::from([]));
    }
}
</document_content>
</document>

<document index="104">
<source>tests/Embedding/VoyageEmbeddingConfigTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/VoyageEmbeddingConfigTest.php

namespace ParaGra\Tests\Embedding;

use InvalidArgumentException;
use ParaGra\Embedding\VoyageEmbeddingConfig;
use ParaGra\Exception\ConfigurationException;
use PHPUnit\Framework\TestCase;

final class VoyageEmbeddingConfigTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        $vars = [
            'VOYAGE_API_KEY',
            'VOYAGE_EMBED_MODEL',
            'VOYAGE_EMBED_BASE_URL',
            'VOYAGE_EMBED_ENDPOINT',
            'VOYAGE_EMBED_MAX_BATCH',
            'VOYAGE_EMBED_TIMEOUT',
            'VOYAGE_EMBED_INPUT_TYPE',
            'VOYAGE_EMBED_TRUNCATE',
            'VOYAGE_EMBED_ENCODING',
            'VOYAGE_EMBED_DIMENSIONS',
        ];

        foreach ($vars as $var) {
            unset($_ENV[$var]);
            if (getenv($var) !== false) {
                putenv($var);
            }
        }
    }

    public function test_from_env_with_defaults(): void
    {
        $_ENV['VOYAGE_API_KEY'] = 'vk';

        $config = VoyageEmbeddingConfig::fromEnv();

        self::assertSame('vk', $config->apiKey);
        self::assertSame('voyage-3', $config->model);
        self::assertSame('https://api.voyageai.com', $config->baseUri);
        self::assertSame('/v1/embeddings', $config->endpoint);
        self::assertSame(128, $config->maxBatchSize);
        self::assertSame(30, $config->timeout);
        self::assertSame('document', $config->inputType);
        self::assertTrue($config->truncate);
        self::assertSame('float', $config->encodingFormat);
        self::assertSame(1024, $config->defaultDimensions);
    }

    public function test_from_env_with_custom_values(): void
    {
        $_ENV['VOYAGE_API_KEY'] = 'custom-key';
        $_ENV['VOYAGE_EMBED_MODEL'] = 'voyage-3-large';
        $_ENV['VOYAGE_EMBED_BASE_URL'] = 'https://proxy.example';
        $_ENV['VOYAGE_EMBED_ENDPOINT'] = '/embeddings';
        $_ENV['VOYAGE_EMBED_MAX_BATCH'] = '16';
        $_ENV['VOYAGE_EMBED_TIMEOUT'] = '5';
        $_ENV['VOYAGE_EMBED_INPUT_TYPE'] = 'query';
        $_ENV['VOYAGE_EMBED_TRUNCATE'] = 'false';
        $_ENV['VOYAGE_EMBED_ENCODING'] = 'FLOAT';
        $_ENV['VOYAGE_EMBED_DIMENSIONS'] = '2048';

        $config = VoyageEmbeddingConfig::fromEnv();

        self::assertSame('custom-key', $config->apiKey);
        self::assertSame('voyage-3-large', $config->model);
        self::assertSame('https://proxy.example', $config->baseUri);
        self::assertSame('/embeddings', $config->endpoint);
        self::assertSame(16, $config->maxBatchSize);
        self::assertSame(5, $config->timeout);
        self::assertSame('query', $config->inputType);
        self::assertFalse($config->truncate);
        self::assertSame('float', $config->encodingFormat);
        self::assertSame(2048, $config->defaultDimensions);
    }

    public function test_from_env_requires_api_key(): void
    {
        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('VOYAGE_API_KEY');

        VoyageEmbeddingConfig::fromEnv();
    }

    public function test_from_env_rejects_invalid_input_type(): void
    {
        $_ENV['VOYAGE_API_KEY'] = 'vk';
        $_ENV['VOYAGE_EMBED_INPUT_TYPE'] = 'unsupported';

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('VOYAGE_EMBED_INPUT_TYPE');

        VoyageEmbeddingConfig::fromEnv();
    }

    public function test_from_env_rejects_invalid_encoding(): void
    {
        $_ENV['VOYAGE_API_KEY'] = 'vk';
        $_ENV['VOYAGE_EMBED_ENCODING'] = '???';

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('VOYAGE_EMBED_ENCODING');

        VoyageEmbeddingConfig::fromEnv();
    }

    public function test_from_env_rejects_invalid_dimensions(): void
    {
        $_ENV['VOYAGE_API_KEY'] = 'vk';
        $_ENV['VOYAGE_EMBED_DIMENSIONS'] = '-100';

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('VOYAGE_EMBED_DIMENSIONS');

        VoyageEmbeddingConfig::fromEnv();
    }
}
</document_content>
</document>

<document index="105">
<source>tests/Embedding/VoyageEmbeddingProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Embedding/VoyageEmbeddingProviderTest.php

namespace ParaGra\Tests\Embedding;

use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\Psr7\Response;
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Embedding\VoyageEmbeddingConfig;
use ParaGra\Embedding\VoyageEmbeddingProvider;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use RuntimeException;

final class VoyageEmbeddingProviderTest extends TestCase
{
    public function test_embed_sends_payload_and_returns_vectors(): void
    {
        $config = new VoyageEmbeddingConfig(
            apiKey: 'vk',
            model: 'voyage-3',
            baseUri: 'https://api.voyageai.com',
            endpoint: '/v1/embeddings',
            maxBatchSize: 4,
            timeout: 12,
            inputType: 'query',
            truncate: false,
            encodingFormat: 'float',
            defaultDimensions: 1024,
        );

        $request = new EmbeddingRequest(
            inputs: [
                ['id' => 'a', 'text' => ' First ', 'metadata' => ['lang' => 'en']],
                ['id' => 'b', 'text' => 'Second'],
            ],
            normalize: true,
        );

        $responseBody = json_encode([
            'data' => [
                ['embedding' => [3.0, 4.0], 'index' => 0],
                ['embedding' => [0.0, 0.0], 'index' => 1],
            ],
            'model' => 'voyage-3',
            'usage' => ['prompt_tokens' => 64],
        ], JSON_THROW_ON_ERROR);

        $response = new Response(200, [], $responseBody);

        /** @var ClientInterface&MockObject $client */
        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->with(
                'POST',
                'https://api.voyageai.com/v1/embeddings',
                $this->callback(function (array $options): bool {
                    self::assertSame('Bearer vk', $options['headers']['Authorization']);
                    self::assertSame('application/json', $options['headers']['Content-Type']);
                    self::assertSame(12, $options['timeout']);
                    self::assertSame('voyage-3', $options['json']['model']);
                    self::assertSame(['First', 'Second'], $options['json']['input']);
                    self::assertSame('query', $options['json']['input_type']);
                    self::assertFalse($options['json']['truncate']);
                    self::assertSame('float', $options['json']['encoding_format']);
                    self::assertSame(1024, $options['json']['output_dimension']);

                    return true;
                })
            )
            ->willReturn($response);

        $provider = new VoyageEmbeddingProvider($config, $client);
        $result = $provider->embed($request);

        self::assertSame('voyage', $result['provider']);
        self::assertSame('voyage-3', $result['model']);
        self::assertSame(2, $result['dimensions']);
        self::assertCount(2, $result['vectors']);
        self::assertSame('a', $result['vectors'][0]['id']);
        self::assertEqualsWithDelta([0.6, 0.8], $result['vectors'][0]['values'], 1e-9);
        self::assertSame(['lang' => 'en'], $result['vectors'][0]['metadata']);
        self::assertSame(['prompt_tokens' => 64], $result['usage']);
    }

    public function test_embed_supports_embeddings_key_shape(): void
    {
        $config = new VoyageEmbeddingConfig(
            apiKey: 'vk',
            model: 'voyage-3-lite',
            defaultDimensions: 512,
        );

        $request = new EmbeddingRequest(['text'], normalize: false);

        $response = new Response(200, [], json_encode([
            'embeddings' => [
                [1, 2],
            ],
        ], JSON_THROW_ON_ERROR));

        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->willReturn($response);

        $provider = new VoyageEmbeddingProvider($config, $client);
        $result = $provider->embed($request);

        self::assertSame(2, $result['dimensions']);
        self::assertSame([[ 'id' => null, 'values' => [1.0, 2.0], 'metadata' => null ]], $result['vectors']);
    }

    public function test_embed_enforces_batch_limit(): void
    {
        $config = new VoyageEmbeddingConfig(
            apiKey: 'vk',
            model: 'voyage-3',
            maxBatchSize: 1,
        );

        $provider = new VoyageEmbeddingProvider($config, $this->createMock(ClientInterface::class));

        $this->expectException(\InvalidArgumentException::class);
        $this->expectExceptionMessage('batch');

        $provider->embed(new EmbeddingRequest(['one', 'two']));
    }

    public function test_embed_wraps_http_errors(): void
    {
        $config = new VoyageEmbeddingConfig(apiKey: 'vk', model: 'voyage-3');

        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->willThrowException(new RequestException('fail', new Request('POST', 'https://api.voyageai.com/v1/embeddings')));

        $provider = new VoyageEmbeddingProvider($config, $client);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Voyage embeddings request failed');

        $provider->embed(new EmbeddingRequest(['only']));
    }

    public function test_embed_throws_when_response_missing_vectors(): void
    {
        $config = new VoyageEmbeddingConfig(apiKey: 'vk', model: 'voyage-3');

        $response = new Response(200, [], json_encode(['data' => []], JSON_THROW_ON_ERROR));

        $client = $this->createMock(ClientInterface::class);
        $client
            ->expects(self::once())
            ->method('request')
            ->willReturn($response);

        $provider = new VoyageEmbeddingProvider($config, $client);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('Voyage embeddings response missing vectors');

        $provider->embed(new EmbeddingRequest(['text']));
    }

    public function test_metadata_helpers(): void
    {
        $config = new VoyageEmbeddingConfig(
            apiKey: 'vk',
            model: 'voyage-3-large',
            maxBatchSize: 32,
            defaultDimensions: 2048,
        );

        $provider = new VoyageEmbeddingProvider($config, $this->createMock(ClientInterface::class));
        $dimensions = $provider->getSupportedDimensions();

        self::assertSame('voyage', $provider->getProvider());
        self::assertSame('voyage-3-large', $provider->getModel());
        self::assertContains(2048, $dimensions);
        self::assertContains(1024, $dimensions);
        self::assertContains(512, $dimensions);
        self::assertSame(32, $provider->getMaxBatchSize());
    }
}
</document_content>
</document>

<document index="106">
<source>tests/ExternalSearch/TwatSearchRetrieverTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ExternalSearch/TwatSearchRetrieverTest.php

namespace ParaGra\Tests\ExternalSearch;

use ParaGra\ExternalSearch\ExternalSearchException;
use ParaGra\ExternalSearch\TwatSearchRetriever;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\TestCase;

use function json_encode;

/**
 * @covers \ParaGra\ExternalSearch\TwatSearchRetriever
 */
final class TwatSearchRetrieverTest extends TestCase
{
    public function testSearchNormalizesResultsAndMetadata(): void
    {
        $runnerCalls = [];
        $runner = function (array $command, array $env, float $timeout) use (&$runnerCalls): array {
            $runnerCalls[] = $command;

            return [
                'exit_code' => 0,
                'stdout' => (string) json_encode([
                    [
                        'source_engine' => 'brave',
                        'title' => 'ParaGra overview',
                        'url' => 'https://example.com/paragra',
                        'snippet' => 'ParaGra orchestrates Ragie, Gemini File Search, and more.',
                        'score' => 0.91,
                        'position' => 1,
                    ],
                    [
                        'source_engine' => 'duckduckgo',
                        'title' => 'Secondary',
                        'url' => 'https://example.com/secondary',
                        'snippet' => 'Second result text.',
                        'score' => null,
                        'position' => 2,
                        'extra_info' => ['type' => 'web'],
                        'raw' => ['hostname' => 'example.com'],
                    ],
                ]),
                'stderr' => '',
            ];
        };

        $retriever = new TwatSearchRetriever(
            defaultEngines: ['brave', 'duckduckgo'],
            defaultNumResults: 5,
            defaultMaxResults: 4,
            maxAttempts: 1,
            retryDelayMs: 0,
            timeoutSeconds: 1.0,
            cacheTtlSeconds: 60,
            cacheLimit: 4,
            processRunner: $runner,
        );

        $response = $retriever->search('ParaGra docs', [
            'engines' => 'brave,duckduckgo',
            'num_results' => 3,
            'max_results' => 1,
        ]);

        self::assertCount(1, $response);
        $chunk = $response->getChunks()[0];
        self::assertSame('ParaGra overview', $chunk['document_name']);
        self::assertSame('https://example.com/paragra', $chunk['document_id']);
        self::assertSame('ParaGra overview' . "\n\n" . 'ParaGra orchestrates Ragie, Gemini File Search, and more.', $chunk['text']);
        self::assertSame(0.91, $chunk['score']);
        self::assertSame('brave', $chunk['metadata']['engine']);

        $metadata = $response->getProviderMetadata();
        self::assertSame(['brave', 'duckduckgo'], $metadata['engines']);
        self::assertSame(3, $metadata['num_results']);
        self::assertSame(1, $metadata['max_results']);
        self::assertFalse($metadata['cache_hit']);
        self::assertSame(1, $metadata['retry_count']);
        self::assertSame('twat-search', $response->getProvider());
        self::assertSame('twat-search-cli', $response->getModel());

        self::assertNotEmpty($runnerCalls);
        $command = $runnerCalls[0];
        self::assertSame('twat-search', $command[0]);
        self::assertSame('web', $command[1]);
        self::assertSame('q', $command[2]);
        self::assertSame('ParaGra docs', $command[3]);
        self::assertContains('-e', $command);
        self::assertContains('--num_results', $command);
    }

    public function testSearchCachesResponsesWhenEnabled(): void
    {
        $callCount = 0;
        $runner = function (array $command, array $env, float $timeout) use (&$callCount): array {
            $callCount++;

            return [
                'exit_code' => 0,
                'stdout' => (string) json_encode([
                    [
                        'source_engine' => 'brave',
                        'title' => 'Cached entry',
                        'snippet' => 'Cached snippet',
                        'url' => 'https://example.com/cache',
                    ],
                ]),
                'stderr' => '',
            ];
        };

        $retriever = new TwatSearchRetriever(
            maxAttempts: 1,
            retryDelayMs: 0,
            cacheTtlSeconds: 10,
            cacheLimit: 2,
            processRunner: $runner,
        );

        $first = $retriever->search('Cache me');
        $second = $retriever->search('Cache me');

        self::assertInstanceOf(UnifiedResponse::class, $first);
        self::assertInstanceOf(UnifiedResponse::class, $second);
        self::assertSame(1, $callCount, 'Process runner should only execute once due to caching.');
        self::assertFalse($first->getProviderMetadata()['cache_hit']);
        self::assertTrue($second->getProviderMetadata()['cache_hit']);
        self::assertSame($first->getChunks(), $second->getChunks());
    }

    public function testSearchRetriesOnFailure(): void
    {
        $callCount = 0;
        $runner = function (array $command, array $env, float $timeout) use (&$callCount): array {
            $callCount++;

            if ($callCount === 1) {
                return [
                    'exit_code' => 1,
                    'stdout' => '',
                    'stderr' => 'network failure',
                ];
            }

            return [
                'exit_code' => 0,
                'stdout' => (string) json_encode([
                    [
                        'source_engine' => 'brave',
                        'title' => 'Recovered',
                        'snippet' => 'Second attempt',
                        'url' => 'https://example.com/retry',
                    ],
                ]),
                'stderr' => '',
            ];
        };

        $retriever = new TwatSearchRetriever(
            maxAttempts: 2,
            retryDelayMs: 0,
            processRunner: $runner,
        );

        $response = $retriever->search('Retry scenario');
        $metadata = $response->getProviderMetadata();

        self::assertSame(2, $callCount);
        self::assertSame(2, $metadata['retry_count']);
        self::assertSame('Recovered', $response->getChunks()[0]['document_name']);
    }

    public function testSearchThrowsAfterExceededRetries(): void
    {
        $runner = static fn (array $command, array $env, float $timeout): array => [
            'exit_code' => 127,
            'stdout' => '',
            'stderr' => 'command not found',
        ];

        $retriever = new TwatSearchRetriever(
            maxAttempts: 2,
            retryDelayMs: 0,
            processRunner: $runner,
        );

        $this->expectException(ExternalSearchException::class);
        $this->expectExceptionMessage('twat-search exited with code 127');
        $retriever->search('Missing binary');
    }

    public function testSearchRejectsEmptyQueries(): void
    {
        $retriever = new TwatSearchRetriever(processRunner: static fn (array $command, array $env, float $timeout): array => [
            'exit_code' => 0,
            'stdout' => '[]',
            'stderr' => '',
        ]);

        $this->expectException(ExternalSearchException::class);
        $retriever->search('   ');
    }

    public function testSearchThrowsWhenJsonOutputIsInvalid(): void
    {
        $retriever = new TwatSearchRetriever(
            maxAttempts: 1,
            processRunner: static fn (array $command, array $env, float $timeout): array => [
                'exit_code' => 0,
                'stdout' => 'not-json',
                'stderr' => '',
            ],
        );

        $this->expectException(ExternalSearchException::class);
        $this->expectExceptionMessage('Failed to locate JSON array');
        $retriever->search('Malformed JSON');
    }
}
</document_content>
</document>

<document index="107">
<source>tests/Llm/AskYodaClientTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/AskYodaClientTest.php

namespace ParaGra\Tests\Llm;

use GuzzleHttp\Client as HttpClient;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Llm\AskYodaClient;
use ParaGra\Llm\AskYodaResponse;
use PHPUnit\Framework\TestCase;

final class AskYodaClientTest extends TestCase
{
    public function test_ask_returns_response(): void
    {
        $responseData = [
            'cost' => 0.001611,
            'result' => 'This is the answer',
            'llm_provider' => 'google',
            'llm_model' => 'gemini-2.0-flash-exp',
            'usage' => [
                'input_tokens' => 100,
                'output_tokens' => 50,
                'total_tokens' => 150,
            ],
            'chunks_ids' => ['id1', 'id2', 'id3'],
        ];

        $mock = new MockHandler([
            new Response(200, [], json_encode($responseData) ?: ''),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new HttpClient(['handler' => $handlerStack]);

        $client = new AskYodaClient(
            'test-api-key',
            'test-project-id',
            'google',
            'gemini-2.0-flash-exp',
            $httpClient
        );

        $response = $client->ask('What is RAG?');

        self::assertInstanceOf(AskYodaResponse::class, $response);
        self::assertSame('This is the answer', $response->getResult());
        self::assertSame(0.001611, $response->getCost());
        self::assertSame('google', $response->getLlmProvider());
        self::assertSame(3, $response->getChunkCount());
    }

    public function test_ask_uses_custom_parameters(): void
    {
        $responseData = [
            'cost' => 0.002,
            'result' => 'Custom answer',
            'llm_provider' => 'openai',
            'llm_model' => 'gpt-4',
            'usage' => ['input_tokens' => 200, 'output_tokens' => 100, 'total_tokens' => 300],
            'chunks_ids' => ['id1'],
        ];

        $mock = new MockHandler([
            new Response(200, [], json_encode($responseData) ?: ''),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new HttpClient(['handler' => $handlerStack]);

        $client = new AskYodaClient(
            'test-api-key',
            'test-project-id',
            'openai',
            'gpt-4',
            $httpClient
        );

        $response = $client->ask(
            query: 'Test query',
            k: 5,
            minScore: 0.5,
            temperature: 0.7,
            maxTokens: 500
        );

        self::assertInstanceOf(AskYodaResponse::class, $response);
        self::assertSame('Custom answer', $response->getResult());
    }

    public function test_ask_throws_on_invalid_json(): void
    {
        $mock = new MockHandler([
            new Response(200, [], 'invalid json'),
        ]);

        $handlerStack = HandlerStack::create($mock);
        $httpClient = new HttpClient(['handler' => $handlerStack]);

        $client = new AskYodaClient(
            'test-api-key',
            'test-project-id',
            httpClient: $httpClient
        );

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Failed to decode AskYoda response');

        $client->ask('Test query');
    }

    public function test_from_env_throws_without_api_key(): void
    {
        $originalKey = getenv('EDENAI_API_KEY');
        $originalProject = getenv('EDENAI_ASKYODA_PROJECT');

        putenv('EDENAI_API_KEY');
        putenv('EDENAI_ASKYODA_PROJECT');
        unset($_ENV['EDENAI_API_KEY'], $_ENV['EDENAI_ASKYODA_PROJECT']);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('EDENAI_API_KEY environment variable is required');

        try {
            AskYodaClient::fromEnv();
        } finally {
            if ($originalKey !== false) {
                putenv("EDENAI_API_KEY={$originalKey}");
            }
            if ($originalProject !== false) {
                putenv("EDENAI_ASKYODA_PROJECT={$originalProject}");
            }
        }
    }

    public function test_from_env_throws_without_project_id(): void
    {
        $originalKey = getenv('EDENAI_API_KEY');
        $originalProject = getenv('EDENAI_ASKYODA_PROJECT');

        putenv('EDENAI_API_KEY=test-key');
        putenv('EDENAI_ASKYODA_PROJECT');
        $_ENV['EDENAI_API_KEY'] = 'test-key';
        unset($_ENV['EDENAI_ASKYODA_PROJECT']);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('EDENAI_ASKYODA_PROJECT environment variable is required');

        try {
            AskYodaClient::fromEnv();
        } finally {
            if ($originalKey !== false) {
                putenv("EDENAI_API_KEY={$originalKey}");
            } else {
                putenv('EDENAI_API_KEY');
            }
            if ($originalProject !== false) {
                putenv("EDENAI_ASKYODA_PROJECT={$originalProject}");
            }
            unset($_ENV['EDENAI_API_KEY'], $_ENV['EDENAI_ASKYODA_PROJECT']);
        }
    }

    public function test_from_env_uses_defaults(): void
    {
        putenv('EDENAI_API_KEY=test-key');
        putenv('EDENAI_ASKYODA_PROJECT=test-project');
        putenv('EDENAI_LLM_PROVIDER');
        putenv('EDENAI_LLM_MODEL');

        try {
            $client = AskYodaClient::fromEnv();
            self::assertInstanceOf(AskYodaClient::class, $client);
        } finally {
            putenv('EDENAI_API_KEY');
            putenv('EDENAI_ASKYODA_PROJECT');
        }
    }

    public function test_from_env_uses_custom_provider_and_model(): void
    {
        putenv('EDENAI_API_KEY=test-key');
        putenv('EDENAI_ASKYODA_PROJECT=test-project');
        putenv('EDENAI_LLM_PROVIDER=openai');
        putenv('EDENAI_LLM_MODEL=gpt-4');

        try {
            $client = AskYodaClient::fromEnv();
            self::assertInstanceOf(AskYodaClient::class, $client);
        } finally {
            putenv('EDENAI_API_KEY');
            putenv('EDENAI_ASKYODA_PROJECT');
            putenv('EDENAI_LLM_PROVIDER');
            putenv('EDENAI_LLM_MODEL');
        }
    }
}
</document_content>
</document>

<document index="108">
<source>tests/Llm/AskYodaResponseTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/AskYodaResponseTest.php

namespace ParaGra\Tests\Llm;

use ParaGra\Llm\AskYodaResponse;
use PHPUnit\Framework\TestCase;

final class AskYodaResponseTest extends TestCase
{
    public function test_constructs_from_array(): void
    {
        $data = [
            'cost' => 0.001611,
            'result' => 'This is the answer',
            'llm_provider' => 'google',
            'llm_model' => 'gemini-2.0-flash-exp',
            'usage' => [
                'input_tokens' => 100,
                'output_tokens' => 50,
                'total_tokens' => 150,
            ],
            'chunks_ids' => ['id1', 'id2', 'id3'],
        ];

        $response = new AskYodaResponse($data);

        self::assertSame(0.001611, $response->getCost());
        self::assertSame('This is the answer', $response->getResult());
        self::assertSame('google', $response->getLlmProvider());
        self::assertSame('gemini-2.0-flash-exp', $response->getLlmModel());
        self::assertSame(100, $response->getInputTokens());
        self::assertSame(50, $response->getOutputTokens());
        self::assertSame(150, $response->getTotalTokens());
        self::assertCount(3, $response->getChunkIds());
        self::assertSame(3, $response->getChunkCount());
    }

    public function test_handles_missing_fields(): void
    {
        $response = new AskYodaResponse([]);

        self::assertSame(0.0, $response->getCost());
        self::assertSame('', $response->getResult());
        self::assertSame('', $response->getLlmProvider());
        self::assertSame('', $response->getLlmModel());
        self::assertSame(0, $response->getInputTokens());
        self::assertSame(0, $response->getOutputTokens());
        self::assertSame(0, $response->getTotalTokens());
        self::assertCount(0, $response->getChunkIds());
        self::assertSame(0, $response->getChunkCount());
    }

    public function test_to_array_returns_expected_structure(): void
    {
        $data = [
            'cost' => 0.001,
            'result' => 'Answer text',
            'llm_provider' => 'openai',
            'llm_model' => 'gpt-4',
            'usage' => [
                'input_tokens' => 200,
                'output_tokens' => 100,
                'total_tokens' => 300,
            ],
            'chunks_ids' => ['id1', 'id2'],
        ];

        $response = new AskYodaResponse($data);
        $array = $response->toArray();

        self::assertArrayHasKey('answer', $array);
        self::assertArrayHasKey('cost', $array);
        self::assertArrayHasKey('llm_provider', $array);
        self::assertArrayHasKey('llm_model', $array);
        self::assertArrayHasKey('usage', $array);
        self::assertArrayHasKey('chunks_count', $array);
        self::assertArrayHasKey('chunk_ids', $array);

        self::assertSame('Answer text', $array['answer']);
        self::assertSame(0.001, $array['cost']);
        self::assertSame(2, $array['chunks_count']);
    }

    public function test_get_usage_returns_full_usage_array(): void
    {
        $usageData = [
            'input_tokens' => 500,
            'output_tokens' => 250,
            'total_tokens' => 750,
            'custom_field' => 'value',
        ];

        $response = new AskYodaResponse(['usage' => $usageData]);

        self::assertSame($usageData, $response->getUsage());
    }
}
</document_content>
</document>

<document index="109">
<source>tests/Llm/NeuronAiAdapterTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/NeuronAiAdapterTest.php

namespace ParaGra\Tests\Llm;

use InvalidArgumentException;
use NeuronAI\Chat\Messages\AssistantMessage;
use NeuronAI\Chat\Messages\Message;
use NeuronAI\Chat\Messages\UserMessage;
use NeuronAI\Providers\AIProviderInterface;
use NeuronAI\Providers\Anthropic\Anthropic;
use NeuronAI\Providers\Deepseek\Deepseek;
use NeuronAI\Providers\Gemini\Gemini;
use NeuronAI\Providers\Mistral\Mistral;
use NeuronAI\Providers\OpenAI\OpenAI;
use NeuronAI\Providers\OpenAILike;
use NeuronAI\Providers\XAI\Grok;
use ParaGra\Llm\NeuronAiAdapter;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;
use ReflectionClass;

#[CoversClass(NeuronAiAdapter::class)]
final class NeuronAiAdapterTest extends TestCase
{
    public function test_generate_usesInjectedProviderFactory(): void
    {
        $provider = $this->createMock(AIProviderInterface::class);
        $provider->expects($this->once())
            ->method('systemPrompt')
            ->with('You are helpful')
            ->willReturnSelf();

        $provider->expects($this->once())
            ->method('chat')
            ->with($this->callback(function (array $messages): bool {
                self::assertCount(1, $messages);
                self::assertInstanceOf(UserMessage::class, $messages[0]);
                self::assertSame('Explain ParaGra', $messages[0]->getContent());
                return true;
            }))
            ->willReturn(new AssistantMessage('ParaGra explanation'));

        $adapter = new NeuronAiAdapter(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: 'sk-test',
            parameters: [],
            systemPrompt: 'You are helpful',
            providerFactory: fn (...$args) => $provider
        );

        self::assertSame('ParaGra explanation', $adapter->generate('Explain ParaGra'));
    }

    public function test_generate_trimsArrayResponseAndHonoursSystemOverride(): void
    {
        $provider = $this->createMock(AIProviderInterface::class);
        $provider->expects($this->once())
            ->method('systemPrompt')
            ->with('custom-system')
            ->willReturnSelf();

        $provider->expects($this->once())
            ->method('chat')
            ->willReturn(new AssistantMessage(['Primary answer', 'Secondary']));

        $adapter = new NeuronAiAdapter(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: 'sk-test',
            providerFactory: fn () => $provider
        );

        self::assertSame('Primary answer', $adapter->generate('Explain ParaGra', ['system_prompt' => 'custom-system']));
    }

    #[DataProvider('nativeProviderData')]
    public function test_resolveProvider_buildsNativeProviders(string $providerName, string $expectedClass): void
    {
        $adapter = new NeuronAiAdapter($providerName, 'model-name', 'api-key');
        $provider = $this->callResolveProvider($adapter);

        self::assertInstanceOf($expectedClass, $provider);
    }

    public static function nativeProviderData(): iterable
    {
        yield ['openai', OpenAI::class];
        yield ['anthropic', Anthropic::class];
        yield ['gemini', Gemini::class];
        yield ['mistral', Mistral::class];
        yield ['xai', Grok::class];
        yield ['deepseek', Deepseek::class];
        yield ['cerebras', OpenAILike::class];
        yield ['groq', OpenAILike::class];
    }

    public function test_resolveProvider_mergesScalarOverridesIntoParameters(): void
    {
        $adapter = new NeuronAiAdapter(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: 'sk-123',
            parameters: ['temperature' => 0.3]
        );

        /** @var OpenAI $provider */
        $provider = $this->callResolveProvider($adapter, [
            'parameters' => ['top_p' => 0.95],
            'temperature' => 0.8,
            'max_tokens' => 1024,
        ]);

        $parameters = $this->readProtectedProperty($provider, 'parameters');
        self::assertSame(0.8, $parameters['temperature']);
        self::assertSame(1024, $parameters['max_tokens']);
        self::assertSame(0.95, $parameters['top_p']);
    }

    public function test_resolveProvider_rejectsUnknownProviders(): void
    {
        $adapter = new NeuronAiAdapter('unsupported', 'model', 'key');

        $this->expectException(InvalidArgumentException::class);
        $this->callResolveProvider($adapter);
    }

    private function callResolveProvider(NeuronAiAdapter $adapter, array $options = []): AIProviderInterface
    {
        $reflection = new ReflectionClass($adapter);
        $method = $reflection->getMethod('resolveProvider');
        $method->setAccessible(true);

        /** @var AIProviderInterface $provider */
        $provider = $method->invoke($adapter, $options);

        return $provider;
    }

    /**
     * @return array<string, mixed>
     */
    private function readProtectedProperty(object $object, string $property): array
    {
        $reflection = new ReflectionClass($object);
        $prop = $reflection->getProperty($property);
        $prop->setAccessible(true);

        /** @var array<string, mixed> $value */
        $value = $prop->getValue($object);

        return $value;
    }
}
</document_content>
</document>

<document index="110">
<source>tests/Llm/OpenAiChatClientTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/OpenAiChatClientTest.php

namespace ParaGra\Tests\Llm;

use OpenAI\Contracts\ClientContract as OpenAiClient;
use OpenAI\Contracts\Resources\ChatContract as OpenAiChatResource;
use OpenAI\Responses\Chat\CreateResponse;
use OpenAI\Responses\Meta\MetaInformation;
use ParaGra\Llm\ChatRequestOptions;
use ParaGra\Llm\OpenAiChatClient;
use ParaGra\Llm\OpenAiChatConfig;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;

final class OpenAiChatClientTest extends TestCase
{
    public function test_generate_text_sends_prompt_and_returns_text(): void
    {
        $config = new OpenAiChatConfig(
            apiKey: 'test-key',
            model: 'test-model',
            baseUrl: 'https://example.test/v1',
            defaultTemperature: 0.5,
            defaultTopP: 0.9,
            defaultMaxTokens: 256,
        );

        $chatResponse = $this->fakeCreateResponse('Hello there', 12, 8);

        /** @var OpenAiChatResource&MockObject $chatResource */
        $chatResource = $this->createMock(OpenAiChatResource::class);
        $chatResource
            ->expects(self::once())
            ->method('create')
            ->with($this->callback(function (array $payload): bool {
                self::assertSame('test-model', $payload['model']);
                self::assertSame([
                    ['role' => 'user', 'content' => 'hi'],
                ], $payload['messages']);
                self::assertSame(0.5, $payload['temperature']);
                self::assertSame(0.9, $payload['top_p']);
                self::assertSame(256, $payload['max_tokens']);

                return true;
            }))
            ->willReturn($chatResponse);

        /** @var OpenAiClient&MockObject $client */
        $client = $this->createMock(OpenAiClient::class);
        $client
            ->expects(self::once())
            ->method('chat')
            ->willReturn($chatResource);

        $chatClient = new OpenAiChatClient($config, $client);
        $result = $chatClient->generateText('hi');

        self::assertSame('Hello there', $result->getText());
        self::assertSame(12, $result->getUsage()->promptTokens);
        self::assertSame(8, $result->getUsage()->completionTokens);
        self::assertSame(20, $result->getUsage()->totalTokens);
    }

    public function test_generate_messages_applies_overrides(): void
    {
        $config = new OpenAiChatConfig(
            apiKey: 'xyz',
            model: 'base-model',
            defaultTemperature: 0.4,
            defaultTopP: 0.8,
        );

        $chatResponse = $this->fakeCreateResponse('Custom answer', 20, 5);

        /** @var OpenAiChatResource&MockObject $chatResource */
        $chatResource = $this->createMock(OpenAiChatResource::class);
        $chatResource
            ->expects(self::once())
            ->method('create')
            ->with($this->callback(function (array $payload): bool {
                self::assertSame('override-model', $payload['model']);
                self::assertSame(0.2, $payload['temperature']);
                self::assertSame(0.5, $payload['top_p']);
                self::assertSame(128, $payload['max_tokens']);
                self::assertCount(2, $payload['messages']);

                return true;
            }))
            ->willReturn($chatResponse);

        /** @var OpenAiClient&MockObject $client */
        $client = $this->createMock(OpenAiClient::class);
        $client
            ->expects(self::once())
            ->method('chat')
            ->willReturn($chatResource);

        $chatClient = new OpenAiChatClient($config, $client);

        $options = new ChatRequestOptions(
            model: 'override-model',
            temperature: 0.2,
            topP: 0.5,
            maxTokens: 128,
        );

        $messages = [
            ['role' => 'system', 'content' => 'Instruction'],
            ['role' => 'user', 'content' => 'Question'],
        ];

        $result = $chatClient->generateMessages($messages, $options);

        self::assertSame('Custom answer', $result->getText());
        self::assertSame(20, $result->getUsage()->promptTokens);
        self::assertSame(5, $result->getUsage()->completionTokens);
        self::assertSame(25, $result->getUsage()->totalTokens);
    }

    private function fakeCreateResponse(string $content, int $promptTokens, int $completionTokens): CreateResponse
    {
        return CreateResponse::from([
            'id' => 'chatcmpl-test',
            'object' => 'chat.completion',
            'created' => time(),
            'model' => 'test-model',
            'choices' => [[
                'index' => 0,
                'message' => [
                    'role' => 'assistant',
                    'content' => $content,
                    'function_call' => null,
                    'tool_calls' => null,
                ],
                'logprobs' => null,
                'finish_reason' => 'stop',
            ]],
            'usage' => [
                'prompt_tokens' => $promptTokens,
                'completion_tokens' => $completionTokens,
                'total_tokens' => $promptTokens + $completionTokens,
            ],
        ], MetaInformation::from([]));
    }
}
</document_content>
</document>

<document index="111">
<source>tests/Llm/OpenAiChatConfigTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/OpenAiChatConfigTest.php

namespace ParaGra\Tests\Llm;

use ParaGra\Exception\ConfigurationException;
use ParaGra\Llm\OpenAiChatConfig;
use PHPUnit\Framework\TestCase;

final class OpenAiChatConfigTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        unset(
            $_ENV['OPENAI_API_KEY'],
            $_ENV['OPENAI_BASE_URL'],
            $_ENV['OPENAI_API_MODEL'],
            $_ENV['OPENAI_API_TEMPERATURE'],
            $_ENV['OPENAI_API_TOP_P'],
            $_ENV['OPENAI_API_MAX_OUT']
        );
    }

    public function test_from_env_with_all_defaults(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-api-key';

        $config = OpenAiChatConfig::fromEnv();

        self::assertSame('test-api-key', $config->apiKey);
        self::assertSame('gpt-4o-mini', $config->model);
        self::assertNull($config->baseUrl);
        self::assertSame(0.7, $config->defaultTemperature);
        self::assertSame(1.0, $config->defaultTopP);
        self::assertNull($config->defaultMaxTokens);
    }

    public function test_from_env_with_custom_values(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'custom-key';
        $_ENV['OPENAI_BASE_URL'] = 'https://custom.openai.com';
        $_ENV['OPENAI_API_MODEL'] = 'gpt-4o';
        $_ENV['OPENAI_API_TEMPERATURE'] = '0.9';
        $_ENV['OPENAI_API_TOP_P'] = '0.95';
        $_ENV['OPENAI_API_MAX_OUT'] = '2000';

        $config = OpenAiChatConfig::fromEnv();

        self::assertSame('custom-key', $config->apiKey);
        self::assertSame('gpt-4o', $config->model);
        self::assertSame('https://custom.openai.com', $config->baseUrl);
        self::assertSame(0.9, $config->defaultTemperature);
        self::assertSame(0.95, $config->defaultTopP);
        self::assertSame(2000, $config->defaultMaxTokens);
    }

    public function test_from_env_with_empty_base_url(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key';
        $_ENV['OPENAI_BASE_URL'] = '';

        $config = OpenAiChatConfig::fromEnv();

        self::assertNull($config->baseUrl, 'Empty string should convert to null.');
    }

    public function test_from_env_with_zero_max_tokens(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key';
        $_ENV['OPENAI_API_MAX_OUT'] = '0';

        $config = OpenAiChatConfig::fromEnv();

        self::assertNull($config->defaultMaxTokens, 'Zero max tokens should be treated as null.');
    }

    public function test_from_env_throws_when_api_key_missing(): void
    {
        unset($_ENV['OPENAI_API_KEY']);
        if (getenv('OPENAI_API_KEY') !== false) {
            putenv('OPENAI_API_KEY');
        }

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('OPENAI_API_KEY');

        OpenAiChatConfig::fromEnv();
    }

    public function test_from_env_handles_numeric_string_conversion(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key';
        $_ENV['OPENAI_API_TEMPERATURE'] = '0.5';
        $_ENV['OPENAI_API_TOP_P'] = '0.8';

        $config = OpenAiChatConfig::fromEnv();

        self::assertSame(0.5, $config->defaultTemperature);
        self::assertSame(0.8, $config->defaultTopP);
    }

    public function test_constructor_directly(): void
    {
        $config = new OpenAiChatConfig(
            apiKey: 'direct-key',
            model: 'gpt-4',
            baseUrl: 'https://api.test.com',
            defaultTemperature: 0.8,
            defaultTopP: 0.9,
            defaultMaxTokens: 4000
        );

        self::assertSame('direct-key', $config->apiKey);
        self::assertSame('gpt-4', $config->model);
        self::assertSame('https://api.test.com', $config->baseUrl);
        self::assertSame(0.8, $config->defaultTemperature);
        self::assertSame(0.9, $config->defaultTopP);
        self::assertSame(4000, $config->defaultMaxTokens);
    }
}
</document_content>
</document>

<document index="112">
<source>tests/Llm/PromptBuilderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Llm/PromptBuilderTest.php

namespace ParaGra\Tests\Llm;

use ParaGra\Llm\PromptBuilder;
use PHPUnit\Framework\TestCase;

final class PromptBuilderTest extends TestCase
{
    public function test_build_injects_question_and_context(): void
    {
        $builder = new PromptBuilder();

        $prompt = $builder->build('What is Ragie?', ['Answer 1', '', 'Answer 2']);

        self::assertStringContainsString('What is Ragie?', $prompt);
        self::assertStringContainsString('Answer 1', $prompt);
        self::assertStringContainsString('Answer 2', $prompt);
        self::assertStringNotContainsString('  ', $prompt, 'Prompt should trim blank entries.');
    }

    public function test_custom_template_is_applied(): void
    {
        $template = 'Q: {{question}} -- C: {{context}}';
        $builder = new PromptBuilder($template);

        $prompt = $builder->build('Why?', ['Because']);

        self::assertSame('Q: Why? -- C: Because', $prompt);
    }
}
</document_content>
</document>

<document index="113">
<source>tests/Logging/SpyLogger.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Logging/SpyLogger.php

namespace ParaGra\Tests\Logging;

use Psr\Log\AbstractLogger;

final class SpyLogger extends AbstractLogger
{
    /** @var array<int, array{level: string, message: string, context: array<string, mixed>}> */
    public array $records = [];

    /**
     * @param mixed $level
     * @param mixed $message
     * @param array<array-key, mixed> $context
     */
    #[\Override]
    public function log($level, $message, array $context = []): void
    {
        $this->records[] = [
            'level' => (string) $level,
            'message' => (string) $message,
            'context' => $context,
        ];
    }
}
</document_content>
</document>

<document index="114">
<source>tests/Media/ChutesImageProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Media/ChutesImageProviderTest.php

namespace ParaGra\Tests\Media;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Media\ChutesImageProvider;
use ParaGra\Media\MediaException;
use ParaGra\Media\MediaRequest;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

use const JSON_THROW_ON_ERROR;

#[CoversClass(ChutesImageProvider::class)]
final class ChutesImageProviderTest extends TestCase
{
    public function test_generate_whenJsonResponse_thenReturnsMediaResult(): void
    {
        $payload = [
            'images' => [
                [
                    'url' => 'https://cdn.example/chutes/img-1.png',
                    'mime_type' => 'image/png',
                    'width' => 1024,
                    'height' => 576,
                ],
            ],
            'job_id' => 'job_123',
        ];
        $handler = new MockHandler([new Response(
            200,
            ['Content-Type' => 'application/json'],
            json_encode($payload, JSON_THROW_ON_ERROR)
        )]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new ChutesImageProvider(
            http: $client,
            baseUrl: 'https://artist-chute.chutes.ai',
            apiKey: 'secret',
            defaults: ['model' => 'flux.1-dev'],
        );

        $result = $provider->generate(new MediaRequest('Book cover with glyphs'));

        self::assertSame('chutes', $result->getProvider());
        self::assertSame('https://cdn.example/chutes/img-1.png', $result->getFirstUrl());
        self::assertSame('flux.1-dev', $result->getModel());
    }

    public function test_generate_whenBinaryResponse_thenEncodesBase64(): void
    {
        $handler = new MockHandler([new Response(200, ['Content-Type' => 'image/png'], 'PNGDATA')]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new ChutesImageProvider($client, 'https://demo-chute.chutes.ai', 'secret');

        $result = $provider->generate(new MediaRequest('Icon grid', width: 640, height: 640));
        $artifact = $result->getArtifacts()[0];

        self::assertArrayHasKey('base64', $artifact);
        self::assertSame('image/png', $artifact['mime_type']);
    }

    public function test_generate_whenRetriesExhausted_thenThrows(): void
    {
        $handler = new MockHandler([
            new Response(500),
            new Response(500),
        ]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new ChutesImageProvider(
            $client,
            'https://unstable.chutes.ai',
            'secret',
            ['max_retries' => 1, 'retry_delay_ms' => 0]
        );

        $this->expectException(MediaException::class);
        $provider->generate(new MediaRequest('Failing request'));
    }
}
</document_content>
</document>

<document index="115">
<source>tests/Media/FalImageProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Media/FalImageProviderTest.php

namespace ParaGra\Tests\Media;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Media\FalImageProvider;
use ParaGra\Media\MediaException;
use ParaGra\Media\MediaRequest;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

use const JSON_THROW_ON_ERROR;

#[CoversClass(FalImageProvider::class)]
final class FalImageProviderTest extends TestCase
{
    public function test_generate_whenJobCompletes_thenReturnsArtifact(): void
    {
        $handler = new MockHandler([
            new Response(200, ['Content-Type' => 'application/json'], json_encode(['request_id' => 'job-1'], JSON_THROW_ON_ERROR)),
            new Response(200, ['Content-Type' => 'application/json'], json_encode(['status' => 'IN_PROGRESS'], JSON_THROW_ON_ERROR)),
            new Response(
                200,
                ['Content-Type' => 'application/json'],
                json_encode([
                    'status' => 'COMPLETED',
                    'images' => [
                        [
                            'url' => 'https://fal.ai/cdn/img.png',
                            'content_type' => 'image/png',
                            'width' => 1024,
                            'height' => 1024,
                        ],
                    ],
                ], JSON_THROW_ON_ERROR)
            ),
        ]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new FalImageProvider(
            http: $client,
            apiKey: 'fal-key',
            modelId: 'fal-ai/flux/dev',
            defaults: ['poll_interval_ms' => 0],
        );

        $result = $provider->generate(new MediaRequest('Flux skyline'));
        self::assertSame('https://fal.ai/cdn/img.png', $result->getFirstUrl());
        self::assertSame('fal.ai', $result->getProvider());
    }

    public function test_generate_whenFalReportsFailure_thenThrows(): void
    {
        $handler = new MockHandler([
            new Response(200, ['Content-Type' => 'application/json'], json_encode(['request_id' => 'job-2'], JSON_THROW_ON_ERROR)),
            new Response(
                200,
                ['Content-Type' => 'application/json'],
                json_encode(['status' => 'FAILED', 'error' => 'quota exceeded'], JSON_THROW_ON_ERROR)
            ),
        ]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new FalImageProvider(
            $client,
            'fal-key',
            'fal-ai/flux/dev',
            ['poll_interval_ms' => 0, 'max_poll_attempts' => 2]
        );

        $this->expectException(MediaException::class);
        $provider->generate(new MediaRequest('Should fail'));
    }

    public function test_generate_whenTimeoutReached_thenThrows(): void
    {
        $handler = new MockHandler([
            new Response(200, ['Content-Type' => 'application/json'], json_encode(['request_id' => 'job-3'], JSON_THROW_ON_ERROR)),
            new Response(200, ['Content-Type' => 'application/json'], json_encode(['status' => 'RUNNING'], JSON_THROW_ON_ERROR)),
        ]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new FalImageProvider(
            $client,
            'fal-key',
            'fal-ai/flux/dev',
            ['poll_interval_ms' => 0, 'max_poll_attempts' => 1]
        );

        $this->expectException(MediaException::class);
        $provider->generate(new MediaRequest('Still running'));
    }
}
</document_content>
</document>

<document index="116">
<source>tests/Media/MediaRequestTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Media/MediaRequestTest.php

namespace ParaGra\Tests\Media;

use InvalidArgumentException;
use ParaGra\Media\MediaRequest;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(MediaRequest::class)]
final class MediaRequestTest extends TestCase
{
    public function test_resolveDimensions_whenAspectRatioProvided_thenComputesHeight(): void
    {
        $request = new MediaRequest(
            prompt: 'Bright cover art',
            aspectRatio: '16:9',
            width: 1920,
            metadata: ['style' => 'cinematic']
        );

        self::assertSame(
            ['width' => 1920, 'height' => 1080],
            $request->resolveDimensions()
        );
        self::assertSame('16:9', $request->getAspectRatio());
        self::assertSame(['style' => 'cinematic'], $request->getMetadata());
    }

    public function test_resolveDimensions_whenOnlyAspectRatio_thenUsesDefaults(): void
    {
        $request = new MediaRequest('Square crop', aspectRatio: '1:1');
        $result = $request->resolveDimensions(768, 512);

        self::assertSame(768, $result['width']);
        self::assertSame(768, $result['height']);
    }

    public function test_constructor_whenPromptEmpty_thenThrows(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('');
    }

    public function test_constructor_whenMetadataInvalid_thenThrows(): void
    {
        $this->expectException(InvalidArgumentException::class);
        /** @phpstan-ignore-next-line */
        new MediaRequest('Prompt', metadata: [['bad']]);
    }

    public function test_toArray_whenSeedProvided_thenIncludesAllFields(): void
    {
        $request = new MediaRequest(
            prompt: 'Snowy forest',
            negativePrompt: 'blurry',
            width: 1024,
            height: 768,
            images: 2,
            seed: 1234,
            metadata: ['origin' => 'test']
        );

        $payload = $request->toArray();

        self::assertSame('Snowy forest', $payload['prompt']);
        self::assertSame(2, $payload['images']);
        self::assertSame(1234, $payload['seed']);
        self::assertSame('blurry', $payload['negative_prompt']);
    }

    public function test_resolveDimensions_whenHeightProvided_thenComputesWidth(): void
    {
        $request = new MediaRequest(
            prompt: 'Portrait',
            aspectRatio: '4:5',
            height: 1250
        );

        $result = $request->resolveDimensions();
        self::assertSame(1000, $result['width']);
        self::assertSame(1256, $result['height']);
    }

    public function test_resolveDimensions_enforcesMinimumDimension(): void
    {
        $request = new MediaRequest('Tiny', width: 10);
        $result = $request->resolveDimensions();

        self::assertSame(64, $result['width']);
    }

    public function test_constructor_rejects_invalid_aspect_ratio_format(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('Scene', aspectRatio: 'wide');
    }

    public function test_constructor_rejects_zero_aspect_ratio_component(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('Scene', aspectRatio: '0:4');
    }

    public function test_constructor_rejects_non_scalar_metadata_values(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('Prompt', metadata: ['tags' => ['alpha', ['beta']]]);
    }

    public function test_constructor_rejects_numeric_metadata_keys(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('Prompt', metadata: [123 => 'value']);
    }

    public function test_negative_prompt_allows_empty_string(): void
    {
        $request = new MediaRequest('Prompt', negativePrompt: '   ');
        self::assertSame('', $request->getNegativePrompt());
    }

    public function test_constructor_rejects_zero_width(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaRequest('Prompt', width: 0);
    }

    public function test_metadata_allows_null_entries_in_list(): void
    {
        $request = new MediaRequest('Prompt', metadata: ['tags' => ['alpha', null]]);
        self::assertSame(['tags' => ['alpha', null]], $request->getMetadata());
    }

    public function test_getAspectRatioReturnsNullWhenUnset(): void
    {
        $request = new MediaRequest('Prompt');
        self::assertSame('1:1', $request->getAspectRatio());
    }
}
</document_content>
</document>

<document index="117">
<source>tests/Media/MediaResultTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Media/MediaResultTest.php

namespace ParaGra\Tests\Media;

use InvalidArgumentException;
use ParaGra\Media\MediaResult;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(MediaResult::class)]
final class MediaResultTest extends TestCase
{
    public function test_constructor_whenValidArtifacts_thenStoresMetadata(): void
    {
        $result = new MediaResult(
            provider: 'chutes',
            model: 'flux.1-pro',
            artifacts: [[
                'url' => 'https://cdn.example/chutes/image.png',
                'mime_type' => 'image/png',
                'width' => 1024,
                'height' => 576,
                'metadata' => ['engine' => 'flux', 'nsfw' => 0],
            ]],
            metadata: ['job_id' => 'job_123'],
        );

        self::assertSame('chutes', $result->getProvider());
        self::assertSame('https://cdn.example/chutes/image.png', $result->getFirstUrl());
        self::assertSame('job_123', $result->getMetadata()['job_id'] ?? null);
        self::assertSame('flux.1-pro', $result->getModel());
    }

    public function test_constructor_whenNoArtifact_thenThrows(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('fal', 'fal-ai/flux/dev', []);
    }

    public function test_constructor_whenArtifactMissingPayload_thenThrows(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('fal', 'fal-ai/flux/dev', [['mime_type' => 'image/png']]);
    }

    public function test_getFirstUrl_returnsNullForInlineArtifacts(): void
    {
        $result = new MediaResult('fal', 'flux', [['base64' => 'Zg==']]);
        self::assertNull($result->getFirstUrl());
    }

    public function test_constructor_rejects_empty_provider(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('   ', 'flux', [['url' => 'https://example.com']]);
    }

    public function test_constructor_rejects_invalid_artifact_metadata(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('fal', 'flux', [[
            'url' => 'https://cdn.example/file.png',
            'metadata' => ['bad' => ['nested' => 'value']],
        ]]);
    }

    public function test_constructor_rejects_non_scalar_metadata_values(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult(
            'fal',
            'flux',
            [['url' => 'https://cdn.example/file.png']],
            metadata: ['bad' => ['nested']]
        );
    }

    public function test_toArray_includes_artifacts_and_metadata(): void
    {
        $result = new MediaResult(
            'chutes',
            'flux',
            [[
                'url' => 'https://cdn.example/file.png',
                'bytes' => 1024,
            ]],
            metadata: ['job' => '123']
        );

        $payload = $result->toArray();
        self::assertSame('chutes', $payload['provider']);
        self::assertSame('flux', $payload['model']);
        self::assertSame('https://cdn.example/file.png', $payload['artifacts'][0]['url']);
        self::assertSame('123', $payload['metadata']['job']);
    }

    public function test_constructor_rejects_invalid_dimensions(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('fal', 'flux', [[
            'url' => 'https://cdn.example/file.png',
            'height' => 0,
        ]]);
    }

    public function test_constructor_rejects_negativeBytes(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new MediaResult('fal', 'flux', [[
            'url' => 'https://cdn.example/file.png',
            'bytes' => -5,
        ]]);
    }

    public function test_getters_return_artifacts_and_metadata(): void
    {
        $result = new MediaResult(
            'fal',
            'flux',
            [[
                'url' => 'https://cdn.example/file.png',
                'metadata' => ['frame' => 1],
            ]],
            metadata: ['job' => 'abc']
        );

        self::assertSame([[ 'url' => 'https://cdn.example/file.png', 'metadata' => ['frame' => 1] ]], $result->getArtifacts());
        self::assertSame(['job' => 'abc'], $result->getMetadata());
    }
}
</document_content>
</document>

<document index="118">
<source>tests/Moderation/NullModeratorTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Moderation/NullModeratorTest.php

namespace ParaGra\Tests\Moderation;

use ParaGra\Moderation\NullModerator;
use PHPUnit\Framework\TestCase;

final class NullModeratorTest extends TestCase
{
    public function testModerateAlwaysReturnsSafeResult(): void
    {
        $moderator = new NullModerator();

        $result = $moderator->moderate('any content');

        self::assertFalse($result->isFlagged(), 'Null moderator never flags content');
        self::assertSame([], $result->getCategories(), 'No categories should be returned');
        self::assertSame([], $result->getCategoryScores(), 'No scores should be returned');
    }

    public function testIsSafeAlwaysTrue(): void
    {
        $moderator = new NullModerator();

        self::assertTrue($moderator->isSafe('dangerous content still returns true'));
    }
}
</document_content>
</document>

<document index="119">
<source>tests/Moderation/OpenAiModeratorTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Moderation/OpenAiModeratorTest.php

namespace ParaGra\Tests\Moderation;

use OpenAI\Contracts\Resources\ModerationsContract;
use OpenAI\Responses\Meta\MetaInformation;
use OpenAI\Responses\Moderations\CreateResponse;
use ParaGra\Exception\ConfigurationException;
use ParaGra\Moderation\ModerationException;
use ParaGra\Moderation\ModerationResult;
use ParaGra\Moderation\OpenAiModerator;
use PHPUnit\Framework\TestCase;

final class OpenAiModeratorTest extends TestCase
{
    public function test_moderate_with_clean_content(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-test123',
            'model' => 'omni-moderation-latest',
            'results' => [[
                'flagged' => false,
                'categories' => [
                    'sexual' => false,
                    'hate' => false,
                    'harassment' => false,
                    'self-harm' => false,
                    'violence' => false,
                ],
                'category_scores' => [
                    'sexual' => 0.001,
                    'hate' => 0.002,
                    'harassment' => 0.003,
                    'self-harm' => 0.001,
                    'violence' => 0.002,
                ],
            ]],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));

        $mockModerations->expects(self::once())
            ->method('create')
            ->with([
                'model' => 'omni-moderation-latest',
                'input' => 'This is a safe message',
            ])
            ->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations, 'omni-moderation-latest');
        $result = $moderator->moderate('This is a safe message');

        self::assertInstanceOf(ModerationResult::class, $result);
        self::assertFalse($result->isFlagged());
        self::assertFalse($result->isCategoryFlagged('violence'));
        self::assertEquals(0.002, $result->getCategoryScore('violence'));
    }

    public function test_moderate_with_flagged_content(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-test456',
            'model' => 'omni-moderation-latest',
            'results' => [[
                'flagged' => true,
                'categories' => [
                    'sexual' => false,
                    'hate' => false,
                    'harassment' => true,
                    'self-harm' => false,
                    'violence' => true,
                ],
                'category_scores' => [
                    'sexual' => 0.001,
                    'hate' => 0.002,
                    'harassment' => 0.85,
                    'self-harm' => 0.001,
                    'violence' => 0.92,
                ],
            ]],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));

        $mockModerations->expects(self::once())
            ->method('create')
            ->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations, 'omni-moderation-latest');

        $this->expectException(ModerationException::class);
        $this->expectExceptionMessage('Content flagged by moderation: harassment, violence');

        $moderator->moderate('I want to hurt them');
    }

    public function test_moderation_exception_contains_details(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-test789',
            'model' => 'omni-moderation-latest',
            'results' => [[
                'flagged' => true,
                'categories' => [
                    'sexual' => false,
                    'hate' => true,
                    'harassment' => false,
                    'self-harm' => false,
                    'violence' => false,
                ],
                'category_scores' => [
                    'sexual' => 0.001,
                    'hate' => 0.95,
                    'harassment' => 0.003,
                    'self-harm' => 0.001,
                    'violence' => 0.002,
                ],
            ]],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));
        $mockModerations->method('create')->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations);

        try {
            $moderator->moderate('hateful content');
            self::fail('Expected ModerationException was not thrown');
        } catch (ModerationException $e) {
            self::assertSame('hate', $e->getFlaggedCategoryNames());
            $flaggedCategories = $e->getFlaggedCategories();
            self::assertTrue($flaggedCategories['hate']);
            self::assertFalse($flaggedCategories['sexual']);

            $scores = $e->getCategoryScores();
            self::assertEquals(0.95, $scores['hate']);
        }
    }

    public function test_is_safe_returns_true_for_clean_content(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-safe',
            'model' => 'omni-moderation-latest',
            'results' => [[
                'flagged' => false,
                'categories' => ['violence' => false],
                'category_scores' => ['violence' => 0.001],
            ]],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));
        $mockModerations->method('create')->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations);
        self::assertTrue($moderator->isSafe('Hello world'));
    }

    public function test_is_safe_returns_false_for_flagged_content(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-unsafe',
            'model' => 'omni-moderation-latest',
            'results' => [[
                'flagged' => true,
                'categories' => ['violence' => true],
                'category_scores' => ['violence' => 0.95],
            ]],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));
        $mockModerations->method('create')->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations);
        self::assertFalse($moderator->isSafe('violent content'));
    }

    public function test_moderate_throws_on_empty_results(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);

        $responseData = [
            'id' => 'modr-empty',
            'model' => 'omni-moderation-latest',
            'results' => [],
        ];

        $mockResponse = CreateResponse::from($responseData, MetaInformation::from([]));
        $mockModerations->method('create')->willReturn($mockResponse);

        $moderator = new OpenAiModerator($mockModerations);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('No moderation results returned');

        $moderator->moderate('test');
    }

    public function test_moderate_wraps_api_errors(): void
    {
        $mockModerations = $this->createMock(ModerationsContract::class);
        $mockModerations->method('create')->willThrowException(new \Exception('API Error'));

        $moderator = new OpenAiModerator($mockModerations);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Moderation API request failed: API Error');

        $moderator->moderate('test');
    }

    public function test_from_env_creates_moderator_with_defaults(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key-123';

        $moderator = OpenAiModerator::fromEnv();

        self::assertInstanceOf(OpenAiModerator::class, $moderator);

        unset($_ENV['OPENAI_API_KEY']);
    }

    public function test_from_env_uses_custom_model(): void
    {
        $_ENV['OPENAI_API_KEY'] = 'test-key-456';
        $_ENV['OPENAI_MODERATION_MODEL'] = 'text-moderation-latest';

        $moderator = OpenAiModerator::fromEnv();

        self::assertInstanceOf(OpenAiModerator::class, $moderator);

        unset($_ENV['OPENAI_API_KEY'], $_ENV['OPENAI_MODERATION_MODEL']);
    }

    public function test_from_env_throws_on_missing_api_key(): void
    {
        unset($_ENV['OPENAI_API_KEY']);
        putenv('OPENAI_API_KEY');

        $this->expectException(ConfigurationException::class);

        OpenAiModerator::fromEnv();
    }
}
</document_content>
</document>

<document index="120">
<source>tests/ParaGraTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ParaGraTest.php

namespace ParaGra\Tests;

use InvalidArgumentException;
use ParaGra\Config\PriorityPool;
use ParaGra\Config\ProviderSpec;
use ParaGra\Llm\NeuronAiAdapter;
use ParaGra\Llm\PromptBuilder;
use ParaGra\Moderation\ModerationResult;
use ParaGra\Moderation\ModeratorInterface;
use ParaGra\ParaGra;
use ParaGra\Providers\ProviderFactory;
use ParaGra\Providers\ProviderInterface;
use ParaGra\Response\UnifiedResponse;
use ParaGra\Router\FallbackStrategy;
use ParaGra\Router\KeyRotator;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;
use RuntimeException;
use ReflectionClass;

#[CoversClass(ParaGra::class)]
#[UsesClass(PriorityPool::class)]
#[UsesClass(ProviderSpec::class)]
#[UsesClass(FallbackStrategy::class)]
#[UsesClass(KeyRotator::class)]
#[UsesClass(UnifiedResponse::class)]
final class ParaGraTest extends TestCase
{
    public function test_from_config_when_priority_pools_missing_then_throws(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('priority_pools');

        ParaGra::fromConfig([]);
    }

    public function test_retrieve_returns_response_from_primary_pool(): void
    {
        $pool = $this->createPriorityPool();
        $response = UnifiedResponse::fromChunks('cerebras', 'llama-3.3-70b', [
            ['text' => 'Context block'],
        ]);

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    response: $response
                ),
            ]
        );

        $result = $paragra->retrieve('What is ParaGra?');

        self::assertSame($response, $result);
    }

    public function test_retrieve_when_primary_pool_fails_then_uses_next_pool(): void
    {
        $pool = $this->createPriorityPool();
        $fallbackResponse = UnifiedResponse::fromChunks('openai', 'gpt-4o-mini', [
            ['text' => 'Fallback context'],
        ]);

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    exception: new RuntimeException('rate limited')
                ),
                'openai:gpt-4o-mini' => new StubProvider(
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    response: $fallbackResponse
                ),
            ]
        );

        $result = $paragra->retrieve('Need fallback');

        self::assertSame($fallbackResponse, $result);
    }

    public function test_retrieve_when_three_pools_then_attempts_each_until_success(): void
    {
        $pool = PriorityPool::fromArray([
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-8b',
                    'api_key' => 'free-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ]);

        $callOrder = [];
        $successResponse = UnifiedResponse::fromChunks('openai', 'gpt-4o-mini', [
            ['text' => 'Tier three'],
        ]);

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    exception: new RuntimeException('tier one down'),
                    spy: function (string $query, array $options) use (&$callOrder): void {
                        $callOrder[] = 'cerebras:llama-3.3-70b';
                    }
                ),
                'cerebras:llama-3.3-8b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-8b',
                    exception: new RuntimeException('tier two down'),
                    spy: function (string $query, array $options) use (&$callOrder): void {
                        $callOrder[] = 'cerebras:llama-3.3-8b';
                    }
                ),
                'openai:gpt-4o-mini' => new StubProvider(
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    response: $successResponse,
                    spy: function (string $query, array $options) use (&$callOrder): void {
                        $callOrder[] = 'openai:gpt-4o-mini';
                    }
                ),
            ]
        );

        $result = $paragra->retrieve('Trigger fallback chain');

        self::assertSame($successResponse, $result);
        self::assertSame(
            ['cerebras:llama-3.3-70b', 'cerebras:llama-3.3-8b', 'openai:gpt-4o-mini'],
            $callOrder
        );
    }

    public function test_retrieve_with_moderation_invokes_moderator_once(): void
    {
        $pool = $this->createPriorityPool();
        $response = UnifiedResponse::fromChunks('cerebras', 'llama-3.3-70b', [
            ['text' => 'Context'],
        ]);

        $moderator = $this->createMock(ModeratorInterface::class);
        $moderator->expects(self::once())
            ->method('moderate')
            ->with('Moderate me')
            ->willReturn(new ModerationResult(false, [], []));

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    response: $response
                ),
            ]
        )->withModeration($moderator);

        $paragra->retrieve('Moderate me');
    }

    public function test_answer_builds_prompt_and_calls_llm(): void
    {
        $pool = $this->createPriorityPool();
        $context = UnifiedResponse::fromChunks('cerebras', 'llama-3.3-70b', [
            ['text' => 'Chunk A'],
            ['text' => 'Chunk B'],
        ]);

        $llm = $this->createMock(NeuronAiAdapter::class);
        $llm->expects(self::once())
            ->method('generate')
            ->with(
                self::callback(static function (string $prompt): bool {
                    self::assertStringContainsString('Chunk A', $prompt);
                    self::assertStringContainsString('Chunk B', $prompt);
                    self::assertStringContainsString('Explain ParaGra', $prompt);
                    return true;
                }),
                ['temperature' => 0.2]
            )
            ->willReturn('Final answer');

        $moderator = $this->createMock(ModeratorInterface::class);
        $moderator->expects(self::once())
            ->method('moderate')
            ->with('Explain ParaGra')
            ->willReturn(new ModerationResult(false, [], []));

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    response: $context,
                    spy: function (string $query, array $options): void {
                        self::assertSame('Explain ParaGra', $query);
                        self::assertSame(['top_k' => 5], $options);
                    }
                ),
            ],
            llmMap: [
                'cerebras:llama-3.3-70b' => $llm,
            ]
        )->withModeration($moderator);

        $result = $paragra->answer('Explain ParaGra', [
            'retrieval' => ['top_k' => 5],
            'generation' => ['temperature' => 0.2],
        ]);

        self::assertSame('Final answer', $result['answer']);
        self::assertSame($context, $result['context']);
        self::assertSame('cerebras', $result['metadata']['provider']);
        self::assertSame('llama-3.3-70b', $result['metadata']['model']);
    }

    public function test_answer_when_primary_provider_retrieval_fails_then_rotates(): void
    {
        $pool = PriorityPool::fromArray([
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ]);

        $calls = [];

        $fallbackContext = UnifiedResponse::fromChunks('openai', 'gpt-4o-mini', [
            ['text' => 'Fallback context'],
        ]);

        $openaiLlm = $this->createMock(NeuronAiAdapter::class);
        $openaiLlm->expects(self::once())
            ->method('generate')
            ->willReturnCallback(function (string $prompt, array $options) use (&$calls): string {
                $calls[] = 'llm:openai';
                self::assertStringContainsString('Need fallback rotation', $prompt);
                self::assertSame([], $options);
                return 'Fallback answer';
            });

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    response: null,
                    exception: new RuntimeException('rate limited'),
                    spy: function (string $query, array $options) use (&$calls): void {
                        $calls[] = 'retrieve:cerebras';
                        self::assertSame('Need fallback rotation', $query);
                        self::assertSame([], $options);
                    }
                ),
                'openai:gpt-4o-mini' => new StubProvider(
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    response: $fallbackContext,
                    spy: function (string $query, array $options) use (&$calls): void {
                        $calls[] = 'retrieve:openai';
                        self::assertSame('Need fallback rotation', $query);
                        self::assertSame([], $options);
                    }
                ),
            ],
            llmMap: [
                'openai:gpt-4o-mini' => $openaiLlm,
            ]
        );

        $result = $paragra->answer('Need fallback rotation');

        self::assertSame('Fallback answer', $result['answer']);
        self::assertSame($fallbackContext, $result['context']);
        self::assertSame('openai', $result['metadata']['provider']);
        self::assertSame('gpt-4o-mini', $result['metadata']['model']);
        self::assertSame(
            ['retrieve:cerebras', 'retrieve:openai', 'llm:openai'],
            $calls,
        );
    }

    public function test_answer_when_llm_throws_then_next_pool_used(): void
    {
        $pool = PriorityPool::fromArray([
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ]);

        $calls = [];

        $primaryContext = UnifiedResponse::fromChunks('cerebras', 'llama-3.3-70b', [
            ['text' => 'Tier one context'],
        ]);
        $fallbackContext = UnifiedResponse::fromChunks('openai', 'gpt-4o-mini', [
            ['text' => 'Tier two context'],
        ]);

        $failingLlm = $this->createMock(NeuronAiAdapter::class);
        $failingLlm->expects(self::once())
            ->method('generate')
            ->willReturnCallback(function (string $prompt, array $options) use (&$calls): string {
                $calls[] = 'llm:cerebras';
                throw new RuntimeException('llm failure simulated');
            });

        $openaiLlm = $this->createMock(NeuronAiAdapter::class);
        $openaiLlm->expects(self::once())
            ->method('generate')
            ->willReturnCallback(function (string $prompt, array $options) use (&$calls): string {
                $calls[] = 'llm:openai';
                self::assertStringContainsString('LLM fallback question', $prompt);
                self::assertSame([], $options);
                return 'Recovered answer';
            });

        $paragra = $this->createParaGra(
            $pool,
            providerMap: [
                'cerebras:llama-3.3-70b' => new StubProvider(
                    provider: 'cerebras',
                    model: 'llama-3.3-70b',
                    response: $primaryContext,
                    spy: function (string $query, array $options) use (&$calls): void {
                        $calls[] = 'retrieve:cerebras';
                        self::assertSame('LLM fallback question', $query);
                        self::assertSame([], $options);
                    }
                ),
                'openai:gpt-4o-mini' => new StubProvider(
                    provider: 'openai',
                    model: 'gpt-4o-mini',
                    response: $fallbackContext,
                    spy: function (string $query, array $options) use (&$calls): void {
                        $calls[] = 'retrieve:openai';
                        self::assertSame('LLM fallback question', $query);
                        self::assertSame([], $options);
                    }
                ),
            ],
            llmMap: [
                'cerebras:llama-3.3-70b' => $failingLlm,
                'openai:gpt-4o-mini' => $openaiLlm,
            ]
        );

        $result = $paragra->answer('LLM fallback question');

        self::assertSame('Recovered answer', $result['answer']);
        self::assertSame($fallbackContext, $result['context']);
        self::assertSame('openai', $result['metadata']['provider']);
        self::assertSame('gpt-4o-mini', $result['metadata']['model']);
        self::assertSame(
            ['retrieve:cerebras', 'llm:cerebras', 'retrieve:openai', 'llm:openai'],
            $calls,
        );
    }

    public function test_retrieve_rejects_empty_questions(): void
    {
        $paragra = $this->createParaGra($this->createPriorityPool());

        $this->expectException(InvalidArgumentException::class);
        $paragra->retrieve('   ');
    }

    public function test_answer_rejects_non_array_generation_options(): void
    {
        $paragra = $this->createParaGra($this->createPriorityPool());

        $this->expectException(InvalidArgumentException::class);
        $paragra->answer('Explain', ['generation' => 'not-an-array']);
    }

    public function test_answer_rejects_non_array_retrieval_options(): void
    {
        $paragra = $this->createParaGra($this->createPriorityPool());

        $this->expectException(InvalidArgumentException::class);
        $paragra->answer('Explain', ['retrieval' => 'invalid']);
    }

    public function test_from_config_loads_catalog_entries_when_slug_present(): void
    {
        putenv('OPENAI_API_KEY=test-openai');

        $instance = ParaGra::fromConfig([
            'priority_pools' => [
                [
                    [
                        'catalog_slug' => 'openai',
                        'catalog_model_type' => 'generation',
                    ],
                ],
            ],
        ]);

        self::assertInstanceOf(ParaGra::class, $instance);
    }

    public function test_resolveProviderRejectsInvalidResolverResults(): void
    {
        $paragra = new ParaGra(
            pools: $this->createPriorityPool(),
            providerFactory: new ProviderFactory(),
            providerResolver: static fn (): string => 'invalid'
        );

        $ref = new ReflectionClass($paragra);
        $method = $ref->getMethod('resolveProvider');
        $method->setAccessible(true);
        $spec = ProviderSpec::fromArray([
            'provider' => 'cerebras',
            'model' => 'llama-3.3-70b',
            'api_key' => 'key',
            'solution' => ['type' => 'ragie'],
        ]);

        $this->expectException(InvalidArgumentException::class);
        $method->invoke($paragra, $spec);
    }

    public function test_resolveLlmRejectsInvalidResolverResults(): void
    {
        $provider = new StubProvider('cerebras', 'llama-3.3-70b');
        $paragra = new ParaGra(
            pools: $this->createPriorityPool(),
            providerFactory: new ProviderFactory(),
            providerResolver: static fn (): ProviderInterface => $provider,
            llmResolver: static fn (): string => 'invalid'
        );

        $ref = new ReflectionClass($paragra);
        $method = $ref->getMethod('resolveLlm');
        $method->setAccessible(true);
        $spec = ProviderSpec::fromArray([
            'provider' => 'cerebras',
            'model' => 'llama-3.3-70b',
            'api_key' => 'key',
            'solution' => ['type' => 'ragie'],
        ]);

        $this->expectException(InvalidArgumentException::class);
        $method->invoke($paragra, $spec);
    }

    /**
     * @param array<string, StubProvider> $providerMap
     * @param array<string, NeuronAiAdapter> $llmMap
     */
    private function createParaGra(
        PriorityPool $pool,
        array $providerMap = [],
        array $llmMap = [],
        ?callable $timeProvider = null,
    ): ParaGra {
        $providerResolver = function (ProviderSpec $spec) use ($providerMap): ProviderInterface {
            $key = self::specKey($spec);
            if (!isset($providerMap[$key])) {
                throw new RuntimeException('Missing provider stub for ' . $key);
            }

            return $providerMap[$key];
        };

        $llmResolver = function (ProviderSpec $spec) use ($llmMap): NeuronAiAdapter {
            $key = self::specKey($spec);
            if (!isset($llmMap[$key])) {
                $mock = $this->createMock(NeuronAiAdapter::class);
                $mock->method('generate')->willReturn('unused');
                return $mock;
            }

            return $llmMap[$key];
        };

        $rotator = new KeyRotator($timeProvider ?? static fn (): int => 0);
        $fallback = new FallbackStrategy($pool, $rotator);

        return new ParaGra(
            pools: $pool,
            providerFactory: new ProviderFactory(),
            fallback: $fallback,
            promptBuilder: new PromptBuilder(),
            providerResolver: $providerResolver,
            llmResolver: $llmResolver
        );
    }

    private static function specKey(ProviderSpec $spec): string
    {
        return $spec->provider . ':' . $spec->model;
    }

    private function createPriorityPool(): PriorityPool
    {
        return PriorityPool::fromArray([
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ]);
    }
}

/**
 * @internal Test stub for ProviderInterface
 */
final class StubProvider implements ProviderInterface
{
    /**
     * @var callable(string, array<string, mixed>): void|null
     */
    private $spy;

    /**
     * @param callable(string, array<string, mixed>): void|null $spy
     */
    public function __construct(
        private readonly string $provider,
        private readonly string $model,
        private readonly ?UnifiedResponse $response = null,
        private readonly ?\Throwable $exception = null,
        ?callable $spy = null,
    ) {
        $this->spy = $spy;
    }

    public function getProvider(): string
    {
        return $this->provider;
    }

    public function getModel(): string
    {
        return $this->model;
    }

    public function getCapabilities(): array
    {
        return ['retrieval'];
    }

    public function supports(string $capability): bool
    {
        return $capability === 'retrieval';
    }

    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        if ($this->spy !== null) {
            ($this->spy)($query, $options);
        }

        if ($this->exception !== null) {
            throw $this->exception;
        }

        return $this->response ?? UnifiedResponse::fromChunks(
            $this->provider,
            $this->model,
            [['text' => 'stub']]
        );
    }
}
</document_content>
</document>

<document index="121">
<source>tests/Pipeline/HybridRetrievalPipelineTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Pipeline/HybridRetrievalPipelineTest.php

namespace ParaGra\Tests\Pipeline;

use ParaGra\Embedding\EmbeddingProviderInterface;
use ParaGra\Embedding\EmbeddingRequest;
use ParaGra\Pipeline\HybridRetrievalPipeline;
use ParaGra\Response\UnifiedResponse;
use ParaGra\VectorStore\VectorNamespace;
use ParaGra\VectorStore\VectorStoreInterface;
use PHPUnit\Framework\TestCase;

/**
 * @covers \ParaGra\Pipeline\HybridRetrievalPipeline
 */
final class HybridRetrievalPipelineTest extends TestCase
{
    public function testIngestFromRagieEmbedsChunksAndCallsVectorStore(): void
    {
        $ragieResponse = UnifiedResponse::fromChunks(
            provider: 'ragie',
            model: 'ragie-demo',
            chunks: [
                [
                    'text' => 'ParaGra handles key rotation to stay inside free tiers.',
                    'score' => 0.88,
                    'document_id' => 'doc-1',
                    'metadata' => ['source' => 'kb'],
                ],
                [
                    'text' => 'Vector stores keep frequently accessed passages nearby.',
                    'score' => 0.44,
                    'document_id' => 'doc-2',
                    'metadata' => ['source' => 'kb'],
                ],
            ],
            metadata: ['tier' => 'free'],
        );

        $capturedQuery = null;
        $capturedRetrievalOptions = null;

        $retrieval = static function (string $question, array $options = []) use ($ragieResponse, &$capturedQuery, &$capturedRetrievalOptions): UnifiedResponse {
            $capturedQuery = $question;
            $capturedRetrievalOptions = $options;

            return $ragieResponse;
        };

        $embedding = new FakeEmbeddingProvider();
        $store = new FakeVectorStore();
        $namespace = new VectorNamespace('hybrid-demo', 'kb');

        $pipeline = new HybridRetrievalPipeline(
            ragieRetriever: $retrieval,
            embeddingProvider: $embedding,
            vectorStore: $store,
            namespace: $namespace,
            maxCombinedChunks: 6,
        );

        $result = $pipeline->ingestFromRagie(
            'What does ParaGra do?',
            [
                'retrieval' => ['top_k' => 6],
                'vector_store' => ['consistency' => 'strong'],
            ],
        );

        self::assertSame('What does ParaGra do?', $capturedQuery);
        self::assertSame(['top_k' => 6], $capturedRetrievalOptions);
        self::assertSame(2, $result['ingested_chunks']);
        self::assertSame(['upserted' => 2, 'updated' => 0], $result['upsert']);
        self::assertSame('ragie-demo', $result['context']->getModel());

        self::assertNotNull($embedding->lastRequest);
        $inputs = $embedding->lastRequest->toArray()['inputs'];
        self::assertSame('doc-1', $inputs[0]['id']);
        self::assertSame('ParaGra handles key rotation to stay inside free tiers.', $inputs[0]['text']);
        self::assertSame('ragie', $inputs[0]['metadata']['origin']);
        self::assertSame('ragie_demo', $inputs[0]['metadata']['ragie_model']);

        self::assertNotNull($store->lastUpsert);
        self::assertSame($namespace, $store->lastUpsert['namespace']);
        self::assertSame(['consistency' => 'strong'], $store->lastUpsert['options']);
        $records = $store->lastUpsert['records'];
        self::assertSame('doc-1', $records[0]['id']);
        self::assertSame('ParaGra handles key rotation to stay inside free tiers.', $records[0]['metadata']['text']);
        self::assertSame('ragie', $records[0]['metadata']['origin']);
    }

    public function testHybridRetrieveCombinesAndReranks(): void
    {
        $ragieResponse = UnifiedResponse::fromChunks(
            provider: 'ragie',
            model: 'ragie-demo',
            chunks: [
                [
                    'text' => 'Ragie chunk one',
                    'score' => 0.72,
                    'document_id' => 'doc-1',
                    'metadata' => ['source' => 'ragie'],
                ],
                [
                    'text' => 'Shared paragraph',
                    'score' => 0.50,
                    'document_id' => 'doc-2',
                ],
            ],
        );

        $capturedQuery = null;

        $retrieval = static function (string $question, array $options = []) use ($ragieResponse, &$capturedQuery): UnifiedResponse {
            $capturedQuery = $question;

            return $ragieResponse;
        };

        $embedding = new FakeEmbeddingProvider();
        $store = new FakeVectorStore();
        $store->nextQueryChunks = [
            [
                'text' => 'Semantic chunk',
                'score' => 0.91,
                'document_id' => 'doc-3',
                'metadata' => ['source' => 'vector'],
            ],
            [
                'text' => 'Shared paragraph',
                'score' => 0.93,
                'document_id' => 'doc-2',
            ],
        ];

        $pipeline = new HybridRetrievalPipeline(
            ragieRetriever: $retrieval,
            embeddingProvider: $embedding,
            vectorStore: $store,
            namespace: new VectorNamespace('hybrid-demo'),
            maxCombinedChunks: 3,
        );

        $result = $pipeline->hybridRetrieve(
            'Explain ParaGra hybrid retrieval',
            [
                'retrieval' => ['top_k' => 4],
                'vector_store' => ['top_k' => 2],
                'hybrid_limit' => 3,
            ],
        );

        self::assertSame('Explain ParaGra hybrid retrieval', $capturedQuery);
        self::assertNotNull($store->lastQuery);
        self::assertSame([strlen('Explain ParaGra hybrid retrieval'), 1.0], $store->lastQuery['vector']);
        self::assertSame('Explain ParaGra hybrid retrieval', $store->lastQuery['options']['query']);
        self::assertSame(['top_k' => 2, 'query' => 'Explain ParaGra hybrid retrieval'], $store->lastQuery['options']);

        $combined = $result['combined'];
        self::assertInstanceOf(UnifiedResponse::class, $combined);
        self::assertCount(3, $combined->getChunks());
        self::assertSame('hybrid', $combined->getProvider());
        self::assertSame('ragie+fake-store', $combined->getModel());

        $chunks = $combined->getChunks();
        self::assertSame('Semantic chunk', $chunks[0]['text']);
        self::assertSame('vector_store', $chunks[0]['metadata']['origin']);
        self::assertSame('Ragie chunk one', $chunks[1]['text']);
        self::assertSame('ragie', $chunks[1]['metadata']['origin']);

        // Shared paragraph should be kept once with the higher weighted score (vector store origin).
        $shared = array_values(array_filter($chunks, static fn (array $chunk): bool => $chunk['document_id'] === 'doc-2'));
        self::assertCount(1, $shared);
        self::assertSame('vector_store', $shared[0]['metadata']['origin']);
    }
}

final class FakeEmbeddingProvider implements EmbeddingProviderInterface
{
    public ?EmbeddingRequest $lastRequest = null;

    public function __construct(
        private readonly string $provider = 'fake-embedding',
        private readonly string $model = 'demo-embedding',
    ) {
    }

    public function getProvider(): string
    {
        return $this->provider;
    }

    public function getModel(): string
    {
        return $this->model;
    }

    /**
     * @return list<int>
     */
    public function getSupportedDimensions(): array
    {
        return [2];
    }

    public function getMaxBatchSize(): int
    {
        return 32;
    }

    public function embed(EmbeddingRequest $request): array
    {
        $this->lastRequest = $request;

        $vectors = [];
        foreach ($request->getInputs() as $index => $input) {
            $vectors[] = [
                'id' => $input['id'],
                'values' => [strlen($input['text']), (float) ($index + 1)],
                'metadata' => $input['metadata'],
            ];
        }

        return [
            'provider' => $this->provider,
            'model' => $this->model,
            'dimensions' => 2,
            'vectors' => $vectors,
            'usage' => null,
        ];
    }
}

final class FakeVectorStore implements VectorStoreInterface
{
    public ?array $lastUpsert = null;

    public ?array $lastQuery = null;

    /**
     * @var list<array<string, mixed>>
     */
    public array $nextQueryChunks = [];

    public function getProvider(): string
    {
        return 'fake-store';
    }

    public function getDefaultNamespace(): VectorNamespace
    {
        return new VectorNamespace('fake');
    }

    public function upsert(VectorNamespace $namespace, array $records, array $options = []): array
    {
        $this->lastUpsert = compact('namespace', 'records', 'options');

        return ['upserted' => count($records), 'updated' => 0];
    }

    public function delete(VectorNamespace $namespace, array $ids, array $options = []): array
    {
        return ['deleted' => count($ids)];
    }

    public function query(VectorNamespace $namespace, array $vector, array $options = []): UnifiedResponse
    {
        $this->lastQuery = compact('namespace', 'vector', 'options');

        return UnifiedResponse::fromChunks(
            provider: $this->getProvider(),
            model: 'demo-index',
            chunks: $this->nextQueryChunks,
            metadata: ['namespace' => $namespace->toArray()],
        );
    }
}
</document_content>
</document>

<document index="122">
<source>tests/Planner/PoolBuilderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Planner/PoolBuilderTest.php

namespace ParaGra\Tests\Planner;

use ParaGra\Planner\PoolBuilder;
use ParaGra\ProviderCatalog\ProviderDiscovery;
use PHPUnit\Framework\TestCase;
use RuntimeException;

use function array_replace;

final class PoolBuilderTest extends TestCase
{
    public function test_build_free_tier_pool_structure(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GOOGLE_API_KEY' => 'google-key',
            'GROQ_API_KEY' => 'groq-key',
            'GEMINI_DATASTORE_ID' => 'fileSearchStores/demo-store',
        ]);

        $pools = $builder->build(PoolBuilder::PRESET_FREE, [
            'ragie_defaults' => ['top_k' => 6],
        ]);

        self::assertCount(1, $pools, 'Free tier preset should emit a single rotation pool when no fallbacks set.');
        $pool = $pools[0];
        self::assertCount(2, $pool, 'Free tier rotation should include Gemini and Groq.');

        $gemini = $this->assertHasCatalogSlug($pool, 'gemini');
        self::assertSame('generation', $gemini['catalog']['model_type'] ?? null);
        self::assertSame('google-key', $gemini['catalog']['overrides']['api_key'] ?? null);
        self::assertSame('ragie-key', $gemini['catalog']['overrides']['solution']['ragie_api_key'] ?? null);
        self::assertSame(['top_k' => 6], $gemini['catalog']['overrides']['solution']['default_options'] ?? null);
        self::assertSame(
            ['datastore' => 'fileSearchStores/demo-store'],
            $gemini['catalog']['overrides']['solution']['vector_store'] ?? null
        );
        self::assertSame(
            'google-gemini-embedding',
            $gemini['catalog']['overrides']['solution']['metadata']['embedding_provider'] ?? null
        );
        self::assertSame('qdrant-cloud-free', $gemini['catalog']['overrides']['solution']['metadata']['vector_store'] ?? null);
        $geminiInsight = $gemini['catalog']['overrides']['solution']['metadata']['insight'] ?? null;
        self::assertIsArray($geminiInsight);
        self::assertSame('google-gemini-file-search', $geminiInsight['slug'] ?? null);
        self::assertSame(100, $geminiInsight['free_tier']['max_file_mb'] ?? null);

        $groq = $this->assertHasCatalogSlug($pool, 'groq');
        self::assertSame('groq-key', $groq['catalog']['overrides']['api_key'] ?? null);
        self::assertSame('ragie-key', $groq['catalog']['overrides']['solution']['ragie_api_key'] ?? null);
        self::assertSame('free-tier', $groq['catalog']['overrides']['solution']['metadata']['plan'] ?? null);
        $groqInsight = $groq['catalog']['overrides']['solution']['metadata']['insight'] ?? null;
        self::assertIsArray($groqInsight);
        self::assertSame('groq-llama', $groqInsight['slug'] ?? null);
    }

    public function test_build_hybrid_pool_includes_openai_with_overrides(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GOOGLE_API_KEY' => 'google-key',
            'GROQ_API_KEY' => 'groq-key',
            'OPENAI_API_KEY' => 'openai-key',
            'GEMINI_DATASTORE_ID' => 'fileSearchStores/demo-store',
        ]);

        $pools = $builder->build(PoolBuilder::PRESET_HYBRID, [
            'ragie_partition' => 'support',
            'ragie_defaults' => ['top_k' => 7],
            'openai_model' => 'gpt-4.1-mini',
        ]);

        self::assertGreaterThanOrEqual(2, $pools, 'Hybrid preset should produce at least two pools.');
        $fallbackPool = $pools[1];
        $openai = $this->assertHasCatalogSlug($fallbackPool, 'openai');

        self::assertSame('gpt-4.1-mini', $openai['catalog']['overrides']['model'] ?? null);
        self::assertSame('support', $openai['catalog']['overrides']['solution']['ragie_partition'] ?? null);
        self::assertSame('openai-key', $openai['catalog']['overrides']['api_key'] ?? null);
        self::assertSame(
            'pinecone-starter',
            $openai['catalog']['overrides']['solution']['metadata']['vector_store'] ?? null
        );
        self::assertSame(
            'voyage-embeddings',
            $openai['catalog']['overrides']['solution']['metadata']['embedding_provider'] ?? null
        );
    }

    public function test_build_hosted_pool_includes_hosted_recommendations(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GOOGLE_API_KEY' => 'google-key',
            'GROQ_API_KEY' => 'groq-key',
            'EDENAI_API_KEY' => 'eden-key',
            'EDENAI_ASKYODA_PROJECT' => 'askyoda-project',
        ]);

        $pools = $builder->build(PoolBuilder::PRESET_HOSTED, [
            'askyoda_options' => ['k' => 8],
            'askyoda_llm' => ['provider' => 'google', 'model' => 'gemini-2.0-flash-exp'],
        ]);

        self::assertCount(1, $pools);
        $hosted = $this->assertHasCatalogSlug($pools[0], 'askyoda');
        $solution = $hosted['catalog']['overrides']['solution'] ?? [];

        self::assertSame('eden-key', $solution['askyoda_api_key'] ?? null);
        self::assertSame('askyoda-project', $solution['project_id'] ?? null);
        self::assertSame(['k' => 8], $solution['default_options'] ?? null);
        self::assertSame(['provider' => 'google', 'model' => 'gemini-2.0-flash-exp'], $solution['llm'] ?? null);

        $metadata = $solution['metadata'] ?? [];
        self::assertArrayHasKey('hosted_recommendations', $metadata);
        $recommendations = $metadata['hosted_recommendations'];
        self::assertIsArray($recommendations);
        self::assertSame('vectara-platform', $recommendations[0]['slug'] ?? null);
        self::assertSame('aws-bedrock-knowledge-bases', $recommendations[1]['slug'] ?? null);
        self::assertSame('hosted', $metadata['latency_tier'] ?? null);
        $insight = $metadata['insight'] ?? [];
        self::assertSame('eden-askyoda', $insight['slug'] ?? null);
        self::assertSame(60, $insight['free_tier']['starter_requests_per_minute'] ?? null);
    }

    public function test_build_free_tier_without_required_env_throws(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GEMINI_DATASTORE_ID' => 'fileSearchStores/demo-store',
        ]);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('GOOGLE_API_KEY');

        $builder->build(PoolBuilder::PRESET_FREE);
    }

    public function test_build_free_tier_missing_catalog_provider_throws(): void
    {
        $builder = $this->makeBuilder(
            [
                'RAGIE_API_KEY' => 'ragie-key',
                'GOOGLE_API_KEY' => 'google-key',
                'GROQ_API_KEY' => 'groq-key',
                'GEMINI_DATASTORE_ID' => 'fileSearchStores/demo-store',
            ],
            [],
            ['groq']
        );

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('groq');

        $builder->build(PoolBuilder::PRESET_FREE);
    }

    public function test_build_free_tier_prefers_corpus_env_when_datastore_missing(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GOOGLE_API_KEY' => 'google-key',
            'GROQ_API_KEY' => 'groq-key',
            'GEMINI_CORPUS_ID' => 'corpora/demo-corpus',
        ]);

        $pools = $builder->build(PoolBuilder::PRESET_FREE);
        $gemini = $this->assertHasCatalogSlug($pools[0], 'gemini');

        self::assertSame(
            ['corpus' => 'corpora/demo-corpus'],
            $gemini['catalog']['overrides']['solution']['vector_store'] ?? null
        );
    }

    public function test_build_free_tier_without_vector_store_env_throws(): void
    {
        $builder = $this->makeBuilder([
            'RAGIE_API_KEY' => 'ragie-key',
            'GOOGLE_API_KEY' => 'google-key',
            'GROQ_API_KEY' => 'groq-key',
        ]);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('GEMINI_DATASTORE_ID');

        $builder->build(PoolBuilder::PRESET_FREE);
    }

    /**
     * @param array<string, string> $env
     * @param array<string, array<string, mixed>> $catalogOverrides
     * @param list<string> $omit
     */
    private function makeBuilder(array $env, array $catalogOverrides = [], array $omit = []): PoolBuilder
    {
        $guardedEnv = array_replace([
            'RAGIE_API_KEY' => '',
            'GOOGLE_API_KEY' => '',
            'GROQ_API_KEY' => '',
            'OPENAI_API_KEY' => '',
            'PARAGRA_OPENAI_API_KEY' => '',
            'PARAGRA_OPENAI_MODEL' => '',
            'OPENAI_MODEL' => '',
            'GEMINI_MODEL' => '',
            'GROQ_MODEL' => '',
            'CEREBRAS_API_KEYS' => '',
            'CEREBRAS_API_KEY' => '',
            'CEREBRAS_MODEL' => '',
            'EDENAI_API_KEY' => '',
            'EDENAI_ASKYODA_PROJECT' => '',
            'EDENAI_LLM_PROVIDER' => '',
            'EDENAI_LLM_MODEL' => '',
            'GEMINI_DATASTORE_ID' => '',
            'GEMINI_CORPUS_ID' => '',
            'GEMINI_VECTOR_STORE' => '',
        ], $env);

        return new PoolBuilder($this->makeCatalog($catalogOverrides, $omit), $guardedEnv);
    }

    /**
     * @param array<string, array<string, mixed>> $catalogOverrides
     * @param list<string> $omit
     */
    private function makeCatalog(array $catalogOverrides = [], array $omit = []): ProviderDiscovery
    {
        $providers = $this->baseProviders();
        foreach ($omit as $slug) {
            unset($providers[$slug]);
        }

        foreach ($catalogOverrides as $slug => $override) {
            if (!isset($providers[$slug])) {
                continue;
            }
            $providers[$slug] = array_replace_recursive($providers[$slug], $override);
        }

        return ProviderDiscovery::fromCatalogArray(['providers' => array_values($providers)]);
    }

    /**
     * @return array<string, array<string, mixed>>
     */
    private function baseProviders(): array
    {
        $capabilities = static fn (): array => [
            'llm_chat' => true,
            'embeddings' => true,
            'vector_store' => true,
            'moderation' => false,
            'image_generation' => false,
            'byok' => true,
        ];

        return [
            'gemini' => [
                'slug' => 'gemini',
                'display_name' => 'Google Gemini',
                'description' => '',
                'api_key_env' => 'GOOGLE_API_KEY',
                'base_url' => null,
                'capabilities' => $capabilities(),
                'model_count' => 2,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [
                    'generation' => 'gemini-2.0-flash-exp',
                    'embedding' => 'text-embedding-004',
                ],
                'default_solution' => [
                    'type' => 'gemini-file-search',
                ],
                'metadata' => [
                    'tier' => 'paid',
                    'insights' => [
                        'google-gemini-flash' => [
                            'slug' => 'google-gemini-flash',
                            'name' => 'Gemini 2.5 Flash',
                            'recommended_roles' => ['frontline_free_llm'],
                            'free_tier' => ['requests_per_day' => 250],
                        ],
                        'google-gemini-embedding' => [
                            'slug' => 'google-gemini-embedding',
                            'name' => 'Gemini Embedding',
                            'recommended_roles' => ['frontline_embeddings'],
                            'free_tier' => ['requests_per_day' => 1000],
                        ],
                        'google-gemini-file-search' => [
                            'slug' => 'google-gemini-file-search',
                            'name' => 'Gemini File Search',
                            'recommended_roles' => ['managed_file_rag'],
                            'free_tier' => ['max_file_mb' => 100],
                        ],
                    ],
                ],
            ],
            'groq' => [
                'slug' => 'groq',
                'display_name' => 'Groq',
                'description' => '',
                'api_key_env' => 'GROQ_API_KEY',
                'base_url' => null,
                'capabilities' => $capabilities(),
                'model_count' => 1,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [
                    'generation' => 'llama-3.1-8b-instant',
                ],
                'default_solution' => [
                    'type' => 'ragie',
                ],
                'metadata' => [
                    'tier' => 'free',
                    'insights' => [
                        'groq-llama' => [
                            'slug' => 'groq-llama',
                            'name' => 'Groq Llama',
                            'recommended_roles' => ['latency_critical_llm'],
                            'free_tier' => ['models' => [['model' => 'llama-3.1-8b', 'requests_per_day' => 14400]]],
                        ],
                    ],
                ],
            ],
            'openai' => [
                'slug' => 'openai',
                'display_name' => 'OpenAI',
                'description' => '',
                'api_key_env' => 'OPENAI_API_KEY',
                'base_url' => null,
                'capabilities' => $capabilities(),
                'model_count' => 1,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => 'ragie',
                'default_models' => [
                    'generation' => 'gpt-4o-mini',
                ],
                'default_solution' => [
                    'type' => 'ragie',
                ],
                'metadata' => [
                    'tier' => 'paid',
                ],
            ],
            'askyoda' => [
                'slug' => 'askyoda',
                'display_name' => 'AskYoda',
                'description' => '',
                'api_key_env' => 'EDENAI_API_KEY',
                'base_url' => null,
                'capabilities' => $capabilities(),
                'model_count' => 1,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => 'askyoda',
                'default_models' => [
                    'generation' => 'askyoda-default',
                ],
                'default_solution' => [
                    'type' => 'askyoda',
                ],
                'metadata' => [
                    'tier' => 'fallback',
                    'latency_tier' => 'hosted',
                    'insights' => [
                        'eden-askyoda' => [
                            'slug' => 'eden-askyoda',
                            'name' => 'Eden AI AskYoda Hosted Workflow',
                            'recommended_roles' => ['hosted_fallback_rag'],
                            'free_tier' => [
                                'starter_requests_per_minute' => 60,
                                'personal_requests_per_minute' => 300,
                                'professional_requests_per_minute' => 1000,
                            ],
                        ],
                    ],
                ],
            ],
            'vectara' => [
                'slug' => 'vectara',
                'display_name' => 'Vectara',
                'description' => '',
                'capabilities' => $capabilities(),
                'model_count' => 0,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [],
                'metadata' => [
                    'insights' => [
                        'vectara-platform' => [
                            'slug' => 'vectara-platform',
                            'name' => 'Vectara Managed RAG',
                            'recommended_roles' => ['hosted_enterprise_rag'],
                            'free_tier' => ['trial_days' => 30],
                        ],
                    ],
                ],
            ],
            'bedrock-kb' => [
                'slug' => 'bedrock-kb',
                'display_name' => 'AWS Bedrock KB',
                'description' => '',
                'capabilities' => [
                    'llm_chat' => false,
                    'embeddings' => false,
                    'vector_store' => true,
                    'moderation' => false,
                    'image_generation' => false,
                    'byok' => true,
                ],
                'model_count' => 0,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [],
                'metadata' => [
                    'insights' => [
                        'aws-bedrock-knowledge-bases' => [
                            'slug' => 'aws-bedrock-knowledge-bases',
                            'name' => 'Bedrock Knowledge Bases',
                            'recommended_roles' => ['managed_graph_rag'],
                            'free_tier' => ['monthly_cost_usd' => 500],
                        ],
                    ],
                ],
            ],
            'pinecone' => [
                'slug' => 'pinecone',
                'display_name' => 'Pinecone',
                'description' => '',
                'capabilities' => [
                    'llm_chat' => false,
                    'embeddings' => false,
                    'vector_store' => true,
                    'moderation' => false,
                    'image_generation' => false,
                    'byok' => false,
                ],
                'model_count' => 0,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [],
                'metadata' => [
                    'insights' => [
                        'pinecone-starter' => [
                            'slug' => 'pinecone-starter',
                            'name' => 'Pinecone Starter',
                            'recommended_roles' => ['starter_rag_stack'],
                            'free_tier' => ['storage_gb' => 2],
                        ],
                    ],
                ],
            ],
            'qdrant' => [
                'slug' => 'qdrant',
                'display_name' => 'Qdrant',
                'description' => '',
                'capabilities' => [
                    'llm_chat' => false,
                    'embeddings' => false,
                    'vector_store' => true,
                    'moderation' => false,
                    'image_generation' => false,
                    'byok' => false,
                ],
                'model_count' => 0,
                'models' => [],
                'embedding_dimensions' => [],
                'preferred_vector_store' => null,
                'default_models' => [],
                'metadata' => [
                    'insights' => [
                        'qdrant-cloud-free' => [
                            'slug' => 'qdrant-cloud-free',
                            'name' => 'Qdrant Cloud Free',
                            'recommended_roles' => ['forever_free_vector'],
                            'free_tier' => ['vector_capacity' => 1000000],
                        ],
                    ],
                ],
            ],
        ];
    }

    /**
     * @param array<int, array<string, mixed>> $pool
     * @return array<string, mixed>
     */
    private function assertHasCatalogSlug(array $pool, string $slug): array
    {
        foreach ($pool as $entry) {
            $catalog = $entry['catalog'] ?? null;
            if (is_array($catalog) && ($catalog['slug'] ?? null) === $slug) {
                return $entry;
            }
        }

        self::fail(sprintf('Pool missing catalog entry for %s', $slug));
    }
}
</document_content>
</document>

<document index="123">
<source>tests/ProviderCatalog/CapabilityMapTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ProviderCatalog/CapabilityMapTest.php

namespace ParaGra\Tests\ProviderCatalog;

use InvalidArgumentException;
use ParaGra\ProviderCatalog\CapabilityMap;
use PHPUnit\Framework\TestCase;

final class CapabilityMapTest extends TestCase
{
    public function testFromArrayNormalizesFlags(): void
    {
        $map = CapabilityMap::fromArray([
            'llm_chat' => 1,
            'embeddings' => true,
            'vector_store' => false,
        ]);

        self::assertTrue($map->llmChat());
        self::assertTrue($map->embeddings());
        self::assertFalse($map->vectorStore());
        self::assertFalse($map->imageGeneration());
        self::assertSame(
            [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            $map->toArray()
        );
    }

    public function testUnknownCapabilityThrows(): void
    {
        $map = CapabilityMap::fromArray([]);

        $this->expectException(InvalidArgumentException::class);
        $map->supports('non_existent');
    }

    public function testRejectsUnexpectedKeys(): void
    {
        $this->expectException(InvalidArgumentException::class);
        CapabilityMap::fromArray([
            'llm_chat' => true,
            'foo' => true,
        ]);
    }
}
</document_content>
</document>

<document index="124">
<source>tests/ProviderCatalog/ProviderDiscoveryTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ProviderCatalog/ProviderDiscoveryTest.php

namespace ParaGra\Tests\ProviderCatalog;

use ParaGra\Config\ProviderSpec;
use ParaGra\Exception\ConfigurationException;
use ParaGra\ProviderCatalog\ProviderDiscovery;
use ParaGra\ProviderCatalog\ProviderSummary;
use PHPUnit\Framework\TestCase;
use RuntimeException;

use function array_map;
use function dirname;
use function in_array;
use function putenv;

final class ProviderDiscoveryTest extends TestCase
{
    private ProviderDiscovery $discovery;

    protected function setUp(): void
    {
        parent::setUp();

        $catalogPath = dirname(__DIR__, 2) . '/config/providers/catalog.php';
        $this->discovery = ProviderDiscovery::fromFile($catalogPath);
    }

    protected function tearDown(): void
    {
        putenv('OPENAI_API_KEY');
        parent::tearDown();
    }

    public function testListProvidersExposesSummaries(): void
    {
        $providers = $this->discovery->listProviders();
        self::assertNotEmpty($providers);
        self::assertInstanceOf(ProviderSummary::class, $providers[0]);

        $openai = $this->discovery->get('openai');
        self::assertNotNull($openai);
        self::assertTrue($openai->capabilities()->llmChat());
        self::assertTrue($openai->capabilities()->embeddings());
    }

    public function testFilterByCapabilityReturnsMatchingProviders(): void
    {
        $embeddingProviders = $this->discovery->filterByCapability('embeddings');
        self::assertNotEmpty($embeddingProviders);
        $slugs = array_map(
            static fn (ProviderSummary $summary): string => $summary->slug(),
            $embeddingProviders
        );

        self::assertTrue(in_array('openai', $slugs, true));
    }

    public function testSupportsEmbeddingDimension(): void
    {
        self::assertTrue($this->discovery->supportsEmbeddingDimension('openai', 1536));
        self::assertFalse($this->discovery->supportsEmbeddingDimension('openai', 9999));
    }

    public function testPreferredVectorStore(): void
    {
        self::assertSame('gemini-file-search', $this->discovery->preferredVectorStore('gemini'));
        self::assertNull($this->discovery->preferredVectorStore('unknown'));
    }

    public function testBuildProviderSpecUsesEnvironment(): void
    {
        putenv('OPENAI_API_KEY=test-openai');
        $spec = $this->discovery->buildProviderSpec('openai');

        self::assertInstanceOf(ProviderSpec::class, $spec);
        self::assertSame('openai', $spec->provider);
        self::assertSame('gpt-4o-mini', $spec->model);
        self::assertSame('test-openai', $spec->apiKey);
        self::assertSame('ragie', $spec->solution['type']);
    }

    public function testBuildProviderSpecCanOverrideModelAndSolution(): void
    {
        putenv('OPENAI_API_KEY=test-openai');
        $spec = $this->discovery->buildProviderSpec('openai', 'generation', [
            'model' => 'gpt-4.1-mini',
            'solution' => [
                'default_options' => ['top_k' => 4],
            ],
        ]);

        self::assertSame('gpt-4.1-mini', $spec->model);
        self::assertSame(4, $spec->solution['default_options']['top_k']);
    }

    public function testBuildProviderSpecFailsWhenApiKeyMissing(): void
    {
        putenv('OPENAI_API_KEY');

        $this->expectException(ConfigurationException::class);
        $this->discovery->buildProviderSpec('openai');
    }

    public function testBuildProviderSpecFailsForUnknownProvider(): void
    {
        putenv('OPENAI_API_KEY=test-openai');

        $this->expectException(ConfigurationException::class);
        $this->discovery->buildProviderSpec('does-not-exist');
    }

    public function testGetReturnsNullForUnknownProvider(): void
    {
        self::assertNull($this->discovery->get('does-not-exist'));
    }

    public function testFromFileThrowsWhenMissing(): void
    {
        $this->expectException(RuntimeException::class);
        ProviderDiscovery::fromFile('/tmp/does-not-exist.json');
    }

    public function testFromFileRejectsInvalidJson(): void
    {
        $path = sys_get_temp_dir() . '/invalid-catalog-' . uniqid('', true) . '.json';
        file_put_contents($path, '{invalid');

        try {
            $this->expectException(RuntimeException::class);
            ProviderDiscovery::fromFile($path);
        } finally {
            @unlink($path);
        }
    }

    public function testFromCatalogArrayRejectsInvalidPayload(): void
    {
        $this->expectException(RuntimeException::class);
        ProviderDiscovery::fromCatalogArray(['invalid' => []]);
    }

    public function testBuildProviderSpecFailsWhenModelPresetMissing(): void
    {
        putenv('OPENAI_API_KEY=test-openai');

        $this->expectException(ConfigurationException::class);
        $this->discovery->buildProviderSpec('openai', 'nonexistent');
    }

    public function testBuildProviderSpecFailsWhenEnvEmpty(): void
    {
        putenv('OPENAI_API_KEY=   ');

        $this->expectException(ConfigurationException::class);
        $this->discovery->buildProviderSpec('openai');
    }
}
</document_content>
</document>

<document index="125">
<source>tests/ProviderCatalog/ProviderSummaryTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ProviderCatalog/ProviderSummaryTest.php

namespace ParaGra\Tests\ProviderCatalog;

use InvalidArgumentException;
use ParaGra\ProviderCatalog\CapabilityMap;
use ParaGra\ProviderCatalog\ProviderSummary;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(ProviderSummary::class)]
#[UsesClass(CapabilityMap::class)]
final class ProviderSummaryTest extends TestCase
{
    public function test_from_array_normalizes_optional_fields(): void
    {
        $data = [
            'slug' => '  voyage  ',
            'display_name' => ' Voyage AI ',
            'description' => '  Provider description ',
            'api_key_env' => '',
            'base_url' => '',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'models' => ['voyage-large', '', 42],
            'embedding_dimensions' => [
                'voyage-large' => 1536,
                'voyage-lite' => '512',
                123 => 1024,
                'invalid' => 0,
            ],
            'preferred_vector_store' => '',
            'default_models' => [
                'chat' => 'voyage-large',
                'image' => '',
            ],
            'default_solution' => [
                'type' => 'rag',
                'metadata' => ['tier' => 'free'],
            ],
            'metadata' => [
                'tier' => 'free',
                'region' => 'us',
            ],
        ];

        $summary = ProviderSummary::fromArray($data);

        self::assertSame('voyage', $summary->slug());
        self::assertSame('Voyage AI', $summary->displayName());
        self::assertSame('Provider description', $summary->description());
        self::assertNull($summary->apiKeyEnv());
        self::assertNull($summary->baseUrl());
        self::assertTrue($summary->capabilities()->llmChat());
        self::assertTrue($summary->capabilities()->embeddings());
        self::assertFalse($summary->capabilities()->vectorStore());
        self::assertSame(2, $summary->modelCount());
        self::assertSame(['voyage-large', '42'], $summary->models());
        self::assertSame(
            [
                'voyage-large' => 1536,
                'voyage-lite' => 512,
            ],
            $summary->embeddingDimensions()
        );
        self::assertNull($summary->preferredVectorStore());
        self::assertSame(['chat' => 'voyage-large'], $summary->defaultModels());
        self::assertSame(['type' => 'rag', 'metadata' => ['tier' => 'free']], $summary->defaultSolution());
        self::assertSame(['tier' => 'free', 'region' => 'us'], $summary->metadata());
    }

    public function test_from_array_when_required_fields_missing_or_invalid_then_throws(): void
    {
        $this->expectException(InvalidArgumentException::class);
        ProviderSummary::fromArray([
            'display_name' => 'Missing slug',
            'capabilities' => [],
        ]);
    }

    public function test_from_array_when_slug_empty_then_throws(): void
    {
        $this->expectException(InvalidArgumentException::class);

        ProviderSummary::fromArray([
            'slug' => '   ',
            'display_name' => 'Voyage',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
        ]);
    }
}
</document_content>
</document>

<document index="126">
<source>tests/ProviderCatalog/SyncProviderCatalogTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ProviderCatalog/SyncProviderCatalogTest.php

namespace ParaGra\Tests\ProviderCatalog;

use PHPUnit\Framework\TestCase;

use function array_map;
use function escapeshellarg;
use function exec;
use function file_get_contents;
use function file_put_contents;
use function implode;
use function json_decode;
use function json_encode;
use function mkdir;
use function sprintf;
use function sys_get_temp_dir;
use const JSON_PRETTY_PRINT;
use const JSON_THROW_ON_ERROR;
use const JSON_UNESCAPED_SLASHES;

final class SyncProviderCatalogTest extends TestCase
{
    public function testSyncIncludesReferenceInsights(): void
    {
        $fixture = $this->createSyncFixture();

        $toolPath = realpath(__DIR__ . '/../../tools/sync_provider_catalog.php');
        self::assertNotFalse($toolPath, 'Sync tool should be resolvable.');

        $command = sprintf(
            '%s %s --source=%s --output=%s --insights=%s --quiet',
            escapeshellarg(PHP_BINARY),
            escapeshellarg($toolPath),
            escapeshellarg($fixture['source']),
            escapeshellarg($fixture['output']),
            escapeshellarg($fixture['insights'])
        );

        exec($command, $output, $exitCode);
        self::assertSame(0, $exitCode, 'Sync script exited with an error.');

        $catalogPath = $fixture['output'] . '/catalog.json';
        self::assertFileExists($catalogPath, 'Catalog JSON was not generated.');

        /** @var array<string, mixed> $catalog */
        $catalog = json_decode((string) file_get_contents($catalogPath), true, 512, JSON_THROW_ON_ERROR);
        self::assertArrayHasKey('providers', $catalog);

        $providers = [];
        foreach ($catalog['providers'] as $provider) {
            $providers[$provider['slug']] = $provider;
        }

        $expectations = [
            'gemini' => [
                ['slug' => 'google-gemini-flash', 'role' => 'frontline_free_llm', 'quota' => 'requests_per_day'],
                ['slug' => 'google-gemini-file-search', 'role' => 'managed_file_rag', 'quota' => 'max_file_mb'],
            ],
            'groq' => [
                ['slug' => 'groq-llama', 'role' => 'latency_critical_llm', 'quota' => 'models'],
            ],
            'openrouter' => [
                ['slug' => 'openrouter', 'role' => 'multi_model_experiments', 'quota' => 'requests_per_minute'],
            ],
            'mistral' => [
                ['slug' => 'mistral-la-plateforme', 'role' => 'evaluation_only', 'quota' => 'tokens_per_minute'],
            ],
            'voyage' => [
                ['slug' => 'voyage-embeddings', 'role' => 'code_search', 'quota' => 'one_time_tokens'],
            ],
            'cloudflare' => [
                ['slug' => 'cloudflare-workers-ai', 'role' => 'edge_embeddings', 'quota' => 'neurons_per_day'],
            ],
            'pinecone' => [
                ['slug' => 'pinecone-starter', 'role' => 'starter_rag_stack', 'quota' => 'storage_gb'],
            ],
            'qdrant' => [
                ['slug' => 'qdrant-cloud-free', 'role' => 'forever_free_vector', 'quota' => 'vector_capacity'],
            ],
            'dify' => [
                ['slug' => 'dify-platform', 'role' => 'hosted_rag_builder', 'quota' => 'notes'],
            ],
            'vectara' => [
                ['slug' => 'vectara-platform', 'role' => 'hosted_enterprise_rag', 'quota' => 'trial_days'],
            ],
            'bedrock-kb' => [
                ['slug' => 'aws-bedrock-knowledge-bases', 'role' => 'managed_graph_rag', 'quota' => 'monthly_cost_usd'],
            ],
            'askyoda' => [
                ['slug' => 'eden-askyoda', 'role' => 'hosted_fallback_rag', 'quota' => 'starter_requests_per_minute'],
            ],
        ];

        foreach ($expectations as $providerSlug => $insightExpectations) {
            self::assertArrayHasKey($providerSlug, $providers, sprintf('Missing provider %s.', $providerSlug));

            $metadata = $providers[$providerSlug]['metadata'] ?? [];
            self::assertIsArray($metadata, sprintf('Provider %s metadata missing.', $providerSlug));

            $insights = $metadata['insights'] ?? [];
            self::assertIsArray($insights, sprintf('Provider %s insights missing.', $providerSlug));

            foreach ($insightExpectations as $expectation) {
                self::assertArrayHasKey(
                    $expectation['slug'],
                    $insights,
                    sprintf('Provider %s missing insight %s.', $providerSlug, $expectation['slug'])
                );

                $insight = $insights[$expectation['slug']];
                self::assertContains(
                    $expectation['role'],
                    $insight['recommended_roles'] ?? [],
                    sprintf('Provider %s insight %s missing role.', $providerSlug, $expectation['slug'])
                );

                $freeTier = $insight['free_tier'] ?? [];
                self::assertIsArray(
                    $freeTier,
                    sprintf('Provider %s insight %s missing free tier.', $providerSlug, $expectation['slug'])
                );
                self::assertArrayHasKey(
                    $expectation['quota'],
                    $freeTier,
                    sprintf('Provider %s insight %s missing quota key %s.', $providerSlug, $expectation['slug'], $expectation['quota'])
                );
            }
        }
    }

    /**
     * @return array{source: string, output: string, insights: string}
     */
    private function createSyncFixture(): array
    {
        $base = sys_get_temp_dir() . '/paragra-sync-' . uniqid('', true);
        $source = $base . '/source';
        $output = $base . '/output';
        $insightsPath = $source . '/config/provider_insights.json';

        foreach ([
            $source,
            $source . '/external',
            $source . '/models',
            $source . '/config',
            $output,
        ] as $dir) {
            if (!mkdir($dir, 0777, true) && !is_dir($dir)) {
                self::fail(sprintf('Unable to create directory %s', $dir));
            }
        }

        file_put_contents($source . '/external/dump_models.py', $this->buildDumpScript());

        $modelSlugs = ['gemini', 'groq', 'openrouter', 'mistral', 'cloudflare', 'pinecone', 'qdrant', 'voyage', 'dify'];
        foreach ($modelSlugs as $slug) {
            $payload = ['data' => [['id' => $slug . '-1'], ['id' => $slug . '-2']]];
            file_put_contents(
                $source . '/models/' . $slug . '.json',
                json_encode($payload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL
            );
        }

        file_put_contents(
            $insightsPath,
            json_encode($this->buildInsightsPayload(), JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL
        );

        return [
            'source' => $source,
            'output' => $output,
            'insights' => $insightsPath,
        ];
    }

    private function buildDumpScript(): string
    {
        $urlLines = [
            'GEMINI_API_OPENAI, https://generativelanguage.googleapis.com/v1beta/openai',
            'GROQ_API_OPENAI, https://api.groq.com/openai/v1',
            'OPENROUTER_API_OPENAI, https://openrouter.ai/api/v1',
            'MISTRAL_API_OPENAI, https://api.mistral.ai/v1',
            'CLOUDFLARE_API_OPENAI, https://api.cloudflare.com/client/v4',
            'PINECONE_API_OPENAI, https://controller.us-east1-gcp.pinecone.io',
            'QDRANT_API_OPENAI, https://api.qdrant.tech',
            'VOYAGE_API_OPENAI, https://api.voyageai.com/v1',
            'DIFY_API_OPENAI, https://dify.example/api',
        ];

        $providerLines = [
            'gemini, oai, GOOGLE_API_KEY, GEMINI_API_OPENAI',
            'groq, oai, GROQ_API_KEY, GROQ_API_OPENAI',
            'openrouter, oai, OPENROUTER_API_KEY, OPENROUTER_API_OPENAI',
            'mistral, oai, MISTRAL_API_KEY, MISTRAL_API_OPENAI',
            'cloudflare, oai, CLOUDFLARE_API_TOKEN, CLOUDFLARE_API_OPENAI',
            'pinecone, url, PINECONE_API_KEY, PINECONE_API_OPENAI',
            'qdrant, url, QDRANT_API_KEY, QDRANT_API_OPENAI',
            'voyage, oai, VOYAGE_API_KEY, VOYAGE_API_OPENAI',
            'dify, url, DIFY_API_KEY, DIFY_API_OPENAI',
        ];

        return <<<PY
PROVIDER_URL_CONFIG = """
{$this->indentLines($urlLines)}
""".strip()

PROVIDER_CONFIG = """
{$this->indentLines($providerLines)}
""".strip()
PY;
    }

    /**
     * @return array<string, mixed>
     */
    private function buildInsightsPayload(): array
    {
        $source = [
            'path' => 'reference/research/demo.md',
            'sha256' => str_repeat('a', 64),
        ];

        $entries = [
            [
                'slug' => 'google-gemini-flash',
                'name' => 'Gemini Flash',
                'category' => 'llm',
                'modalities' => ['text'],
                'recommended_roles' => ['frontline_free_llm'],
                'reset_window' => 'daily',
                'commercial_use' => 'Allowed.',
                'free_quota' => ['requests_per_day' => 250],
                'notes' => 'Gemini free tier.',
                'sources' => [$source],
            ],
            [
                'slug' => 'google-gemini-file-search',
                'name' => 'Gemini File Search',
                'category' => 'rag_tool',
                'modalities' => ['rag', 'vector_store'],
                'recommended_roles' => ['managed_file_rag'],
                'free_quota' => [
                    'max_file_mb' => 100,
                    'store_quota_gb_free' => 1,
                ],
                'sources' => [$source],
            ],
            [
                'slug' => 'groq-llama',
                'name' => 'Groq Llama',
                'category' => 'llm',
                'modalities' => ['text'],
                'recommended_roles' => ['latency_critical_llm'],
                'free_quota' => [
                    'requests_per_minute' => 40,
                    'models' => [
                        ['model' => 'llama-3.1-8b', 'requests_per_day' => 14400],
                    ],
                ],
                'sources' => [$source],
            ],
            [
                'slug' => 'openrouter',
                'name' => 'OpenRouter Free',
                'category' => 'router',
                'modalities' => ['text'],
                'recommended_roles' => ['multi_model_experiments'],
                'free_quota' => ['requests_per_minute' => 20],
                'sources' => [$source],
            ],
            [
                'slug' => 'mistral-la-plateforme',
                'name' => 'Mistral Experiment',
                'category' => 'llm',
                'modalities' => ['text'],
                'recommended_roles' => ['evaluation_only'],
                'free_quota' => ['tokens_per_minute' => 500000],
                'sources' => [$source],
            ],
            [
                'slug' => 'voyage-embeddings',
                'name' => 'Voyage Embeddings',
                'category' => 'embedding',
                'modalities' => ['embedding'],
                'recommended_roles' => ['code_search'],
                'free_quota' => ['one_time_tokens' => 200000000],
                'sources' => [$source],
            ],
            [
                'slug' => 'cloudflare-workers-ai',
                'name' => 'Workers AI',
                'category' => 'edge_ai',
                'modalities' => ['embedding'],
                'recommended_roles' => ['edge_embeddings'],
                'free_quota' => ['neurons_per_day' => 10000],
                'sources' => [$source],
            ],
            [
                'slug' => 'pinecone-starter',
                'name' => 'Pinecone Starter',
                'category' => 'vector_store',
                'modalities' => ['vector'],
                'recommended_roles' => ['starter_rag_stack'],
                'free_quota' => ['storage_gb' => 2],
                'sources' => [$source],
            ],
            [
                'slug' => 'qdrant-cloud-free',
                'name' => 'Qdrant Free',
                'category' => 'vector_store',
                'modalities' => ['vector'],
                'recommended_roles' => ['forever_free_vector'],
                'free_quota' => ['vector_capacity' => 1000000],
                'sources' => [$source],
            ],
            [
                'slug' => 'dify-platform',
                'name' => 'Dify Platform',
                'category' => 'platform',
                'modalities' => ['workflow'],
                'recommended_roles' => ['hosted_rag_builder'],
                'free_quota' => ['notes' => 'Self-host cost only.'],
                'sources' => [$source],
            ],
            [
                'slug' => 'vectara-platform',
                'name' => 'Vectara Managed RAG',
                'category' => 'hosted_rag',
                'modalities' => ['rag', 'llm'],
                'recommended_roles' => ['hosted_enterprise_rag'],
                'free_quota' => [
                    'trial_days' => 30,
                    'approx_queries_per_month' => 15000,
                ],
                'sources' => [$source],
            ],
            [
                'slug' => 'eden-askyoda',
                'name' => 'Eden AskYoda Hosted Workflow',
                'category' => 'hosted_rag',
                'modalities' => ['rag', 'workflow'],
                'recommended_roles' => ['hosted_fallback_rag'],
                'free_quota' => [
                    'starter_requests_per_minute' => 60,
                    'personal_requests_per_minute' => 300,
                    'professional_requests_per_minute' => 1000,
                ],
                'sources' => [$source],
            ],
            [
                'slug' => 'aws-bedrock-knowledge-bases',
                'name' => 'AWS Bedrock Knowledge Bases',
                'category' => 'managed_rag',
                'modalities' => ['rag', 'graph'],
                'recommended_roles' => ['managed_graph_rag'],
                'free_quota' => [
                    'monthly_cost_usd' => 500,
                    'setup_days' => 5,
                ],
                'sources' => [$source],
            ],
        ];

        return [
            '__meta__' => [
                'this_file' => 'reference/catalog/provider_insights.json',
                'schema_version' => 1,
            ],
            'providers' => $entries,
        ];
    }

    /**
     * @param list<string> $lines
     */
    private function indentLines(array $lines): string
    {
        return implode("\n", array_map(static fn (string $line): string => '    ' . $line, $lines));
    }
}
</document_content>
</document>

<document index="127">
<source>tests/Providers/AbstractProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Providers/AbstractProviderTest.php

namespace ParaGra\Tests\Providers;

use InvalidArgumentException;
use ParaGra\Config\ProviderSpec;
use ParaGra\Providers\AbstractProvider;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(AbstractProvider::class)]
final class AbstractProviderTest extends TestCase
{
    public function test_supports_whenCapabilityPresent_thenReturnsTrue(): void
    {
        $provider = $this->createProvider(['retrieval', 'LLM_Generation']);

        self::assertTrue($provider->supports('retrieval'));
        self::assertTrue($provider->supports('llm_generation'), 'Lookup should be case-insensitive.');
        self::assertSame(['retrieval', 'llm_generation'], $provider->getCapabilities());
    }

    public function test_supports_whenCapabilityMissing_thenReturnsFalse(): void
    {
        $provider = $this->createProvider(['retrieval']);

        self::assertFalse($provider->supports('rerank'));
    }

    public function test_gettersExposeSpecData(): void
    {
        $provider = $this->createProvider(['retrieval']);

        self::assertSame('ragie', $provider->getProvider());
        self::assertSame('gpt-4o-mini', $provider->getModel());
        self::assertSame([
            'type' => 'ragie',
            'partition' => 'default',
        ], $provider->exposeSolution());
    }

    public function test_sanitizeQuery_whenValid_thenReturnsTrimmed(): void
    {
        $provider = $this->createProvider();

        self::assertSame('What is ParaGra?', $provider->exposeSanitize("  What is ParaGra?  "));
    }

    public function test_sanitizeQuery_whenEmpty_thenThrows(): void
    {
        $provider = $this->createProvider();

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Query text cannot be empty');

        $provider->exposeSanitize('   ');
    }

    public function test_baseMetadata_includesProviderAndModel(): void
    {
        $provider = $this->createProvider();

        self::assertSame([
            'provider' => 'ragie',
            'model' => 'gpt-4o-mini',
        ], $provider->exposeBaseMetadata());
    }

    public function test_invalidOptionHelper_buildsConsistentMessage(): void
    {
        $provider = $this->createProvider();

        $exception = $provider->throwInvalidOption('top_k', 'must be positive');

        self::assertSame('Invalid option "top_k": must be positive', $exception->getMessage());
    }

    public function test_retrieve_usesUnifiedResponse(): void
    {
        $provider = $this->createProvider();

        $response = $provider->retrieve('  hello world   ');

        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame('ragie', $response->getProvider());
        self::assertSame('gpt-4o-mini', $response->getModel());
        self::assertSame(['hello world'], $response->getChunkTexts());
        self::assertSame([
            'provider' => 'ragie',
            'model' => 'gpt-4o-mini',
        ], $response->getProviderMetadata());
    }

    /**
     * @param list<string> $capabilities
     */
    private function createProvider(array $capabilities = []): DummyProvider
    {
        return new DummyProvider($this->spec(), $capabilities);
    }

    private function spec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'ragie',
            model: 'gpt-4o-mini',
            apiKey: 'sk-test',
            solution: [
                'type' => 'ragie',
                'partition' => 'default',
            ]
        );
    }
}

/**
 * @internal
 */
final class DummyProvider extends AbstractProvider
{
    #[\Override]
    public function retrieve(string $query, array $options = []): UnifiedResponse
    {
        $cleanQuery = $this->exposeSanitize($query);

        return new UnifiedResponse(
            provider: $this->getProvider(),
            model: $this->getModel(),
            chunks: [
                [
                    'text' => $cleanQuery,
                    'document_id' => $options['document_id'] ?? 'doc-1',
                ],
            ],
            providerMetadata: $this->exposeBaseMetadata(),
        );
    }

    public function exposeSanitize(string $query): string
    {
        return $this->sanitizeQuery($query);
    }

    /**
     * @return array<string, mixed>
     */
    public function exposeSolution(): array
    {
        return $this->getSolution();
    }

    /**
     * @return array<string, string>
     */
    public function exposeBaseMetadata(): array
    {
        return $this->baseMetadata();
    }

    public function throwInvalidOption(string $name, string $reason): InvalidArgumentException
    {
        return $this->invalidOption($name, $reason);
    }
}
</document_content>
</document>

<document index="128">
<source>tests/Providers/AskYodaProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Providers/AskYodaProviderTest.php

namespace ParaGra\Tests\Providers;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Config\ProviderSpec;
use ParaGra\Providers\AskYodaProvider;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(AskYodaProvider::class)]
final class AskYodaProviderTest extends TestCase
{
    public function test_retrieve_whenPayloadPresent_thenReturnsChunkTexts(): void
    {
        $handler = new MockHandler([
            new Response(200, [], json_encode([
                'result' => 'This is the fallback answer from AskYoda.',
                'cost' => 0.0032,
                'llm_provider' => 'google',
                'llm_model' => 'gemini-2.0-flash-exp',
                'usage' => [
                    'input_tokens' => 120,
                    'output_tokens' => 80,
                    'total_tokens' => 200,
                ],
                'chunks' => [
                    [
                        'chunk_id' => 'alpha',
                        'payload' => ['text' => 'Chunk alpha'],
                        'metadata' => ['source' => 'doc-1'],
                    ],
                    [
                        'chunk_id' => 'beta',
                        'payload' => ['content' => 'Chunk beta text'],
                        'metadata' => ['source' => 'doc-2'],
                    ],
                ],
            ])),
        ]);

        $client = new Client(['handler' => HandlerStack::create($handler)]);
        $provider = new AskYodaProvider(
            $this->spec(),
            $client,
            [
                'default_options' => ['k' => 8],
                'llm' => [
                    'provider' => 'google',
                    'model' => 'gemini-2.0-flash-exp',
                ],
            ]
        );

        $response = $provider->retrieve('Explain ParaGra');
        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame(['Chunk alpha', 'Chunk beta text'], $response->getChunkTexts());
        self::assertSame(120, $response->getUsage()['input_tokens'] ?? null);
        self::assertEquals(0.0032, $response->getCost()['amount'] ?? null);
    }

    public function test_retrieve_whenOnlyChunkIds_thenBuildsPlaceholders(): void
    {
        $handler = new MockHandler([
            new Response(200, [], json_encode([
                'result' => 'Fallback result',
                'chunks_ids' => ['a', 'b'],
            ])),
        ]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);
        $provider = new AskYodaProvider($this->spec(), $client);

        $response = $provider->retrieve('  Hello  ');
        self::assertSame([
            'Chunk a',
            'Chunk b',
        ], $response->getChunkTexts());
    }

    private function spec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'askyoda',
            model: 'edenai-askyoda',
            apiKey: 'unused',
            solution: [
                'type' => 'askyoda',
                'askyoda_api_key' => 'api-key',
                'project_id' => 'project-123',
            ],
        );
    }
}
</document_content>
</document>

<document index="129">
<source>tests/Providers/GeminiFileSearchProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Providers/GeminiFileSearchProviderTest.php

namespace ParaGra\Tests\Providers;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\Config\ProviderSpec;
use ParaGra\Providers\GeminiFileSearchProvider;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(GeminiFileSearchProvider::class)]
final class GeminiFileSearchProviderTest extends TestCase
{
    public function test_retrieve_whenSearchEntriesPresent_thenReturnsChunks(): void
    {
        $payload = [
            'candidates' => [
                [
                    'content' => [
                        'parts' => [
                            ['text' => 'Answer from Gemini'],
                        ],
                    ],
                    'groundingMetadata' => [
                        'searchEntries' => [
                            [
                                'score' => 0.91,
                                'chunk' => [
                                    'chunkId' => 'chunk-1',
                                    'content' => [
                                        'parts' => [
                                            ['text' => 'First part'],
                                            ['text' => 'Second part'],
                                        ],
                                    ],
                                    'source' => 'projects/demo',
                                ],
                                'uri' => 'https://example.com/doc1',
                                'title' => 'Doc 1',
                            ],
                        ],
                    ],
                ],
            ],
            'usageMetadata' => [
                'promptTokenCount' => 50,
                'candidatesTokenCount' => 120,
                'totalTokenCount' => 170,
            ],
        ];

        $handler = new MockHandler([new Response(200, [], json_encode($payload, JSON_THROW_ON_ERROR))]);
        $client = new Client(['handler' => HandlerStack::create($handler)]);

        $provider = new GeminiFileSearchProvider(
            $this->spec(),
            $client,
            [
                'vector_store' => 'projects/demo/locations/us/vectorStores/myStore',
                'api_key' => 'api-key',
            ]
        );

        $response = $provider->retrieve('Summarize ParaGra');
        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame(['First part Second part'], $response->getChunkTexts());
        self::assertSame(50, $response->getUsage()['prompt_tokens'] ?? null);
    }

    public function test_retrieve_whenVectorStoreArray_thenPayloadUsesProvidedName(): void
    {
        $payload = [
            'candidates' => [
                [
                    'content' => [
                        'parts' => [
                            ['text' => 'Answer'],
                        ],
                    ],
                ],
            ],
        ];

        $history = [];
        $handler = new MockHandler([new Response(200, [], json_encode($payload, JSON_THROW_ON_ERROR))]);
        $stack = HandlerStack::create($handler);
        $stack->push(Middleware::history($history));
        $client = new Client(['handler' => $stack]);

        $provider = new GeminiFileSearchProvider(
            $this->spec(),
            $client,
            [
                'vector_store' => ['datastore' => 'fileSearchStores/demo-store'],
                'api_key' => 'api-key',
            ]
        );

        $provider->retrieve('Summarize ParaGra');

        self::assertNotEmpty($history);
        $body = (string) $history[0]['request']->getBody();
        $data = json_decode($body, true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(
            'fileSearchStores/demo-store',
            $data['toolConfig']['fileSearch']['vectorStore'][0]['name'] ?? null
        );
    }

    public function test_retrieve_withoutVectorStoreConfig_throws(): void
    {
        $spec = new ProviderSpec(
            provider: 'gemini',
            model: 'gemini-2.0-flash-exp',
            apiKey: 'api-key',
            solution: ['type' => 'gemini-file-search'],
        );

        $provider = new GeminiFileSearchProvider(
            $spec,
            new Client(['handler' => HandlerStack::create(new MockHandler([]))]),
            ['api_key' => 'api-key']
        );

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('vector_store');

        $provider->retrieve('Summarize ParaGra');
    }

    private function spec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'gemini',
            model: 'gemini-2.0-flash-exp',
            apiKey: 'api-key',
            solution: [
                'type' => 'gemini-file-search',
                'vector_store' => 'projects/demo/locations/us/vectorStores/myStore',
            ],
        );
    }
}
</document_content>
</document>

<document index="130">
<source>tests/Providers/ProviderFactoryTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Providers/ProviderFactoryTest.php

namespace ParaGra\Tests\Providers;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Psr7\Response;
use ParaGra\Config\ProviderSpec;
use ParaGra\Llm\NeuronAiAdapter;
use ParaGra\Providers\AskYodaProvider;
use ParaGra\Providers\GeminiFileSearchProvider;
use ParaGra\Providers\ProviderFactory;
use ParaGra\Providers\RagieProvider;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;
use Ragie\Client as RagieClient;

#[CoversClass(ProviderFactory::class)]
final class ProviderFactoryTest extends TestCase
{
    public function test_createProvider_whenSolutionIsRagie_thenReturnsRagieProvider(): void
    {
        $factory = new ProviderFactory(
            ragieClientFactory: fn (ProviderSpec $spec) => $this->createMock(RagieClient::class),
            httpClientFactory: fn () => new Client(['handler' => HandlerStack::create(new MockHandler())]),
        );

        $provider = $factory->createProvider($this->ragieSpec());
        self::assertInstanceOf(RagieProvider::class, $provider);
    }

    public function test_createProvider_whenSolutionIsGemini_thenReturnsGeminiProvider(): void
    {
        $factory = new ProviderFactory(
            ragieClientFactory: fn () => $this->createMock(RagieClient::class),
            httpClientFactory: fn () => new Client(['handler' => HandlerStack::create(new MockHandler([
                new Response(200, [], json_encode(['candidates' => []], JSON_THROW_ON_ERROR)),
            ]))]),
        );

        $provider = $factory->createProvider($this->geminiSpec());
        self::assertInstanceOf(GeminiFileSearchProvider::class, $provider);
    }

    public function test_createProvider_whenSolutionIsAskYoda_thenReturnsAskYodaProvider(): void
    {
        $factory = new ProviderFactory(
            ragieClientFactory: fn () => $this->createMock(RagieClient::class),
            httpClientFactory: fn () => new Client(['handler' => HandlerStack::create(new MockHandler([
                new Response(200, [], json_encode(['result' => 'ok'], JSON_THROW_ON_ERROR)),
            ]))]),
        );

        $provider = $factory->createProvider($this->askYodaSpec());
        self::assertInstanceOf(AskYodaProvider::class, $provider);
    }

    public function test_createLlmClient_returnsNeuronAdapter(): void
    {
        $factory = new ProviderFactory();
        $adapter = $factory->createLlmClient($this->ragieSpec());
        self::assertInstanceOf(NeuronAiAdapter::class, $adapter);
    }

    private function ragieSpec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: 'sk-openai',
            solution: [
                'type' => 'ragie',
                'ragie_api_key' => 'ragie-key',
            ],
        );
    }

    private function geminiSpec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'gemini',
            model: 'gemini-2.0-flash-exp',
            apiKey: 'ai-key',
            solution: [
                'type' => 'gemini-file-search',
                'vector_store' => 'projects/demo/locations/us/vectorStores/demo',
            ],
        );
    }

    private function askYodaSpec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'askyoda',
            model: 'askyoda-default',
            apiKey: 'unused',
            solution: [
                'type' => 'askyoda',
                'askyoda_api_key' => 'edenai-key',
                'project_id' => 'project-1',
            ],
        );
    }
}
</document_content>
</document>

<document index="131">
<source>tests/Providers/RagieProviderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Providers/RagieProviderTest.php

namespace ParaGra\Tests\Providers;

use ParaGra\Config\ProviderSpec;
use ParaGra\Providers\RagieProvider;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;
use Ragie\Api\Model\Retrieval;
use Ragie\Api\Model\RetrieveParams;
use Ragie\Api\Model\ScoredChunk;
use Ragie\Client as RagieClient;
use Ragie\RetrievalOptions;

#[CoversClass(RagieProvider::class)]
final class RagieProviderTest extends TestCase
{
    public function test_retrieve_whenValidInput_thenReturnsUnifiedResponse(): void
    {
        $spec = $this->spec();
        $client = $this->createMock(RagieClient::class);
        $chunks = [
            $this->chunk('Doc 1 text', 0.9, 'doc-1', 'Doc 1'),
            $this->chunk('Doc 2 text', 0.7, 'doc-2', 'Doc 2'),
        ];

        $client->expects($this->once())
            ->method('retrieve')
            ->with(
                'What is ParaGra?',
                $this->callback(function (?RetrievalOptions $options): bool {
                    self::assertInstanceOf(RetrievalOptions::class, $options);
                    $params = $options->toRetrieveParams('What is ParaGra?');
                    self::assertInstanceOf(RetrieveParams::class, $params);
                    self::assertSame(5, $params->getTopK());
                    self::assertTrue($params->getRerank());
                    self::assertSame('docs', $params->getPartition());
                    return true;
                })
            )
            ->willReturn($this->retrieval($chunks));

        $provider = new RagieProvider(
            $spec,
            $client,
            [
                'default_options' => [
                    'top_k' => 5,
                    'rerank' => true,
                    'partition' => 'docs',
                ],
            ]
        );

        $response = $provider->retrieve('  What is ParaGra?  ');
        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame(2, $response->count());
        self::assertSame(['Doc 1 text', 'Doc 2 text'], $response->getChunkTexts());
        self::assertSame('openai', $response->getProvider());
        self::assertSame('gpt-4o-mini', $response->getModel());
    }

    public function test_retrieve_whenQueryEmpty_thenThrows(): void
    {
        $spec = $this->spec();
        $client = $this->createMock(RagieClient::class);
        $provider = new RagieProvider($spec, $client);

        $this->expectException(\InvalidArgumentException::class);
        $provider->retrieve('   ');
    }

    private function spec(): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: 'sk-test',
            solution: [
                'type' => 'ragie',
                'ragie_api_key' => 'ragie-key',
                'ragie_partition' => 'docs',
            ],
        );
    }

    private function chunk(string $text, float $score, string $documentId, string $documentName): ScoredChunk
    {
        $chunk = new ScoredChunk();
        $chunk->setText($text);
        $chunk->setScore($score);
        $chunk->setDocumentId($documentId);
        $chunk->setDocumentName($documentName);

        return $chunk;
    }

    /**
     * @param list<ScoredChunk> $chunks
     */
    private function retrieval(array $chunks): \Ragie\RetrievalResult
    {
        $retrieval = new Retrieval();
        $retrieval->setScoredChunks($chunks);

        return new \Ragie\RetrievalResult($retrieval);
    }
}
</document_content>
</document>

<document index="132">
<source>tests/ReferenceCatalog/ProviderCatalogBuilderTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/ReferenceCatalog/ProviderCatalogBuilderTest.php

namespace ParaGra\Tests\ReferenceCatalog;

use InvalidArgumentException;
use ParaGra\ReferenceCatalog\ProviderCatalogBuilder;
use PHPUnit\Framework\TestCase;
use RuntimeException;

final class ProviderCatalogBuilderTest extends TestCase
{
    public function testBuildFromSourceAddsHashesAndMetadata(): void
    {
        $fixture = $this->createFixture();
        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        self::assertSame('reference/catalog/provider_insights.json', $catalog['__meta__']['this_file']);
        self::assertSame(1, $catalog['__meta__']['provider_count']);

        $provider = $catalog['providers'][0];
        self::assertSame('demo-provider', $provider['slug']);

        $expectedHash = hash_file('sha256', $fixture['doc']);
        self::assertSame($expectedHash, $provider['sources'][0]['sha256']);
    }

    public function testVerifyCatalogDetectsChecksumMismatch(): void
    {
        $fixture = $this->createFixture();
        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        file_put_contents($fixture['doc'], "mutated content\n");

        $errors = $builder->verifyCatalog($catalog);
        self::assertNotEmpty($errors);
        self::assertStringContainsString('hash mismatch', $errors[0]);
    }

    public function testBuildFromSourceRejectsMissingProvidersList(): void
    {
        $fixture = $this->createFixture();
        file_put_contents(
            $fixture['source'],
            json_encode(['__meta__' => ['schema_version' => 1]], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
        );

        $builder = new ProviderCatalogBuilder($fixture['root']);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('providers array');
        $builder->buildFromSource($fixture['source']);
    }

    public function testBuildFromSourceRejectsMalformedSourceEntries(): void
    {
        $fixture = $this->createFixture();
        $invalidPayload = [
            '__meta__' => ['schema_version' => 1],
            'providers' => [
                [
                    'slug' => 'demo-provider',
                    'sources' => [
                        ['path' => ''],
                    ],
                ],
            ],
        ];
        file_put_contents(
            $fixture['source'],
            json_encode($invalidPayload, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
        );

        $builder = new ProviderCatalogBuilder($fixture['root']);

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('source entry');
        $builder->buildFromSource($fixture['source']);
    }

    public function testVerifyCatalogDetectsMissingSourceFiles(): void
    {
        $fixture = $this->createFixture();
        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        unlink($fixture['doc']);
        $errors = $builder->verifyCatalog($catalog);

        self::assertNotEmpty($errors);
        self::assertStringContainsString('references missing file', $errors[0]);
    }

    public function testVerifyCatalogFlagsInvalidSourceShape(): void
    {
        $fixture = $this->createFixture();
        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        $catalog['providers'][0]['sources'] = 'invalid';

        $errors = $builder->verifyCatalog($catalog);
        self::assertSame(['Provider demo-provider has invalid sources metadata.'], $errors);
    }

    public function testBuildFromSourceRejectsNonArrayProviders(): void
    {
        $fixture = $this->createFixture(data: [
            '__meta__' => ['schema_version' => 1],
            'providers' => ['invalid-entry'],
        ]);
        $builder = new ProviderCatalogBuilder($fixture['root']);

        $this->expectException(InvalidArgumentException::class);
        $builder->buildFromSource($fixture['source']);
    }

    public function testBuildFromSourceSortsProvidersBySlug(): void
    {
        $fixture = $this->createFixture(data: [
            '__meta__' => ['schema_version' => 1],
            'providers' => [
                [
                    'slug' => 'z-provider',
                    'sources' => [['path' => 'reference/research/sample.md']],
                ],
                [
                    'slug' => 'a-provider',
                    'sources' => [['path' => 'reference/research/sample.md']],
                ],
            ],
        ]);
        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        self::assertSame(['a-provider', 'z-provider'], [
            $catalog['providers'][0]['slug'],
            $catalog['providers'][1]['slug'],
        ]);
    }

    public function testBuildFromSourceKeepsAbsoluteSourcePaths(): void
    {
        $external = sys_get_temp_dir() . '/external-source-' . uniqid('', true) . '.md';
        file_put_contents($external, 'external');

        $fixture = $this->createFixture(data: [
            '__meta__' => ['schema_version' => 1],
            'providers' => [
                [
                    'slug' => 'abs-provider',
                    'sources' => [
                        ['path' => $external],
                    ],
                ],
            ],
        ]);

        $builder = new ProviderCatalogBuilder($fixture['root']);
        $catalog = $builder->buildFromSource($fixture['source']);

        self::assertSame($external, $catalog['providers'][0]['sources'][0]['path']);
    }

    /**
     * @return array{root: string, source: string, doc: string}
     */
    private function createFixture(?array $data = null): array
    {
        $root = sys_get_temp_dir() . '/provider-catalog-' . uniqid('', true);
        $catalogDir = $root . '/reference/catalog';
        $researchDir = $root . '/reference/research';
        if (!mkdir($catalogDir, 0777, true) && !is_dir($catalogDir)) {
            self::fail('Unable to create catalog directory.');
        }
        if (!mkdir($researchDir, 0777, true) && !is_dir($researchDir)) {
            self::fail('Unable to create research directory.');
        }

        $docPath = $researchDir . '/sample.md';
        file_put_contents($docPath, "demo content\n");

        $sourceData = $data ?? [
            '__meta__' => [
                'this_file' => 'reference/catalog/provider_insights.source.json',
                'schema_version' => 1,
            ],
            'providers' => [
                [
                    'slug' => 'demo-provider',
                    'name' => 'Demo Provider',
                    'category' => 'llm',
                    'modalities' => ['text'],
                    'recommended_roles' => ['demo'],
                    'reset_window' => 'daily',
                    'commercial_use' => 'demo use only',
                    'free_quota' => ['requests_per_day' => 1],
                    'notes' => 'demo entry',
                    'sources' => [
                        [
                            'path' => 'reference/research/sample.md',
                            'start_line' => 1,
                            'end_line' => 1,
                        ],
                    ],
                ],
            ],
        ];

        $sourcePath = $catalogDir . '/provider_insights.source.json';
        file_put_contents(
            $sourcePath,
            json_encode($sourceData, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES)
        );

        return [
            'root' => $root,
            'source' => $sourcePath,
            'doc' => $docPath,
        ];
    }
}
</document_content>
</document>

<document index="133">
<source>tests/Response/UnifiedResponseTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Response/UnifiedResponseTest.php

namespace ParaGra\Tests\Response;

use InvalidArgumentException;
use ParaGra\Response\UnifiedResponse;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(UnifiedResponse::class)]
final class UnifiedResponseTest extends TestCase
{
    public function test_construction_normalizesChunks(): void
    {
        $response = new UnifiedResponse(
            provider: 'ragie',
            model: 'gpt-4o-mini',
            chunks: [
                [
                    'text' => '  chunk A  ',
                    'score' => 0.92,
                    'document_id' => ' doc-1 ',
                    'document_name' => ' Example Doc ',
                    'metadata' => ['source' => 'ragie'],
                ],
            ],
            providerMetadata: ['pool' => 'primary'],
            usage: ['tokens' => 42],
            cost: ['usd' => 0.001],
        );

        self::assertSame('ragie', $response->getProvider());
        self::assertSame('gpt-4o-mini', $response->getModel());
        self::assertSame([
            [
                'text' => 'chunk A',
                'score' => 0.92,
                'document_id' => 'doc-1',
                'document_name' => 'Example Doc',
                'metadata' => ['source' => 'ragie'],
            ],
        ], $response->getChunks());
        self::assertSame(['chunk A'], $response->getChunkTexts());
        self::assertSame(['pool' => 'primary'], $response->getProviderMetadata());
        self::assertSame(['tokens' => 42], $response->getUsage());
        self::assertSame(['usd' => 0.001], $response->getCost());
        self::assertFalse($response->isEmpty());
        self::assertSame(
            [
                'provider' => 'ragie',
                'model' => 'gpt-4o-mini',
                'chunks' => [
                    [
                        'text' => 'chunk A',
                        'score' => 0.92,
                        'document_id' => 'doc-1',
                        'document_name' => 'Example Doc',
                        'metadata' => ['source' => 'ragie'],
                    ],
                ],
                'metadata' => ['pool' => 'primary'],
                'usage' => ['tokens' => 42],
                'cost' => ['usd' => 0.001],
            ],
            $response->toArray()
        );
    }

    public function test_getChunkTexts_isMemoized(): void
    {
        $response = new UnifiedResponse(
            provider: 'ragie',
            model: 'gpt-4o-mini',
            chunks: [
                ['text' => 'chunk A'],
                ['text' => 'chunk B'],
            ],
        );

        $firstCall = $response->getChunkTexts();
        $secondCall = $response->getChunkTexts();

        self::assertSame($firstCall, $secondCall);
    }

    public function test_constructor_whenChunkMissingText_thenThrows(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Chunk 0 is missing a valid "text" field.');

        new UnifiedResponse(
            provider: 'ragie',
            model: 'gpt-4o-mini',
            chunks: [
                ['score' => 0.5],
            ],
        );
    }

    public function test_isEmpty_returnsTrueWhenNoChunks(): void
    {
        $response = new UnifiedResponse(
            provider: 'ragie',
            model: 'gpt-4o-mini',
            chunks: [],
        );

        self::assertTrue($response->isEmpty());
        self::assertCount(0, $response);
    }

    public function test_fromChunks_staticFactory(): void
    {
        $response = UnifiedResponse::fromChunks(
            provider: 'gemini',
            model: 'gemini-2.0-flash-exp',
            chunks: [
                [
                    'text' => 'Gemini chunk',
                    'score' => 0.81,
                ],
            ],
            metadata: ['solution' => 'gemini-file-search'],
            usage: ['prompt_tokens' => 10],
            cost: ['usd' => 0.0002],
        );

        self::assertSame('gemini', $response->getProvider());
        self::assertSame(['Gemini chunk'], $response->getChunkTexts());
        self::assertSame(['solution' => 'gemini-file-search'], $response->getProviderMetadata());
        self::assertSame(['prompt_tokens' => 10], $response->getUsage());
        self::assertSame(['usd' => 0.0002], $response->getCost());
    }
}
</document_content>
</document>

<document index="134">
<source>tests/Router/FallbackStrategyTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Router/FallbackStrategyTest.php

namespace ParaGra\Tests\Router;

use ParaGra\Config\PriorityPool;
use ParaGra\Config\ProviderSpec;
use ParaGra\Planner\PoolBuilder;
use ParaGra\Router\FallbackStrategy;
use ParaGra\Router\KeyRotator;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;
use RuntimeException;

#[CoversClass(FallbackStrategy::class)]
#[UsesClass(PriorityPool::class)]
#[UsesClass(ProviderSpec::class)]
#[UsesClass(KeyRotator::class)]
final class FallbackStrategyTest extends TestCase
{
    public function test_execute_when_free_pool_rotates_all_specs_before_fallback(): void
    {
        $config = [
            [
                $this->providerConfig('free-1', ['plan' => PoolBuilder::PRESET_FREE]),
                $this->providerConfig('free-2', ['plan' => PoolBuilder::PRESET_FREE]),
                $this->providerConfig('free-3', ['plan' => PoolBuilder::PRESET_FREE]),
            ],
            [
                $this->providerConfig('paid-1', ['plan' => PoolBuilder::PRESET_HYBRID]),
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);
        $logs = [];

        $strategy = new FallbackStrategy(
            $pools,
            $rotator,
            familyPolicies: [],
            logger: static function (string $message) use (&$logs): void {
                $logs[] = $message;
            }
        );

        $attempts = [];
        $result = $strategy->execute(function (ProviderSpec $spec) use (&$attempts): string {
            $attempts[] = $spec->apiKey;
            if (count($attempts) < 3) {
                throw new RuntimeException('fail-' . $spec->apiKey);
            }

            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-free-3', $result);
        self::assertSame(['free-1', 'free-2', 'free-3'], $attempts);
        self::assertCount(2, $logs, 'Failures should be logged for each rotated key.');
    }

    public function test_execute_when_policy_limits_attempts_then_moves_to_next_pool(): void
    {
        $config = [
            [
                $this->providerConfig('hybrid-1', ['plan' => PoolBuilder::PRESET_HYBRID]),
                $this->providerConfig('hybrid-2', ['plan' => PoolBuilder::PRESET_HYBRID]),
                $this->providerConfig('hybrid-3', ['plan' => PoolBuilder::PRESET_HYBRID]),
            ],
            [
                $this->providerConfig('free-1', ['plan' => PoolBuilder::PRESET_FREE]),
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);

        $strategy = new FallbackStrategy(
            $pools,
            $rotator,
            familyPolicies: [
                'hybrid' => ['max_attempts' => 1],
            ]
        );

        $attempts = [];
        $result = $strategy->execute(function (ProviderSpec $spec) use (&$attempts): string {
            $attempts[] = $spec->apiKey;
            if ($spec->apiKey === 'hybrid-1') {
                throw new RuntimeException('fail-hybrid-1');
            }

            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-free-1', $result);
        self::assertSame(['hybrid-1', 'free-1'], $attempts);
    }

    public function test_execute_when_hosted_family_defaults_to_single_attempt(): void
    {
        $config = [
            [
                $this->providerConfig('hosted-1', ['plan' => PoolBuilder::PRESET_HOSTED]),
                $this->providerConfig('hosted-2', ['plan' => PoolBuilder::PRESET_HOSTED]),
            ],
            [
                $this->providerConfig('hybrid-1', ['plan' => PoolBuilder::PRESET_HYBRID]),
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);

        $strategy = new FallbackStrategy($pools, $rotator);

        $attempts = [];
        $result = $strategy->execute(function (ProviderSpec $spec) use (&$attempts): string {
            $attempts[] = $spec->apiKey;
            if ($spec->apiKey === 'hosted-1') {
                throw new RuntimeException('hosted-down');
            }

            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-hybrid-1', $result);
        self::assertSame(['hosted-1', 'hybrid-1'], $attempts);
    }

    public function test_execute_when_first_pool_succeeds_then_does_not_fallback(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);

        $strategy = new FallbackStrategy($pools, $rotator);

        $calls = 0;
        $result = $strategy->execute(static function (ProviderSpec $spec) use (&$calls): string {
            $calls++;
            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-free', $result);
        self::assertSame(1, $calls);
    }

    public function test_execute_when_first_pool_fails_then_tries_next_pool(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);

        $strategy = new FallbackStrategy($pools, $rotator);

        $calls = 0;
        $result = $strategy->execute(function (ProviderSpec $spec) use (&$calls): string {
            $calls++;
            if ($spec->apiKey === 'free') {
                throw new RuntimeException('rate limited');
            }

            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-paid', $result);
        self::assertSame(2, $calls);
    }

    public function test_execute_when_all_pools_fail_then_throws(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $rotator = new KeyRotator(static fn (): int => 0);

        $strategy = new FallbackStrategy($pools, $rotator);

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('All priority pools exhausted');

        $strategy->execute(static function (): never {
            throw new RuntimeException('down');
        });
    }

    public function test_execute_when_three_pools_then_attempts_each_until_success(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $strategy = new FallbackStrategy($pools, new KeyRotator(static fn (): int => 0));

        $attempts = [];

        $result = $strategy->execute(function (ProviderSpec $spec) use (&$attempts): string {
            $attempts[] = $spec->apiKey;
            if ($spec->apiKey !== 'paid-2') {
                throw new RuntimeException('fail-' . $spec->apiKey);
            }

            return 'ok-' . $spec->apiKey;
        });

        self::assertSame('ok-paid-2', $result);
        self::assertSame(['free-1', 'free-2', 'paid-2'], $attempts);
    }

    public function test_execute_when_three_pools_all_fail_then_previous_exception_retained(): void
    {
        $config = [
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-1',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'cerebras',
                    'model' => 'llama-3.3-70b',
                    'api_key' => 'free-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
            [
                [
                    'provider' => 'openai',
                    'model' => 'gpt-4o-mini',
                    'api_key' => 'paid-2',
                    'solution' => ['type' => 'ragie'],
                ],
            ],
        ];

        $pools = PriorityPool::fromArray($config);
        $strategy = new FallbackStrategy($pools, new KeyRotator(static fn (): int => 0));

        $attempts = [];

        try {
            $strategy->execute(function (ProviderSpec $spec) use (&$attempts): never {
                $attempts[] = $spec->apiKey;
                throw new RuntimeException('fail-' . $spec->apiKey);
            });
            self::fail('Expected exception not thrown');
        } catch (RuntimeException $exception) {
            self::assertSame('All priority pools exhausted', $exception->getMessage());
            $previous = $exception->getPrevious();
            self::assertInstanceOf(RuntimeException::class, $previous);
            self::assertSame('fail-paid-2', $previous->getMessage());
            self::assertSame(['free-1', 'free-2', 'paid-2'], $attempts);
        }
    }

    /**
     * @param array<string, mixed> $metadata
     * @return array<string, mixed>
     */
    private function providerConfig(string $apiKey, array $metadata = []): array
    {
        return [
            'provider' => 'cerebras',
            'model' => 'llama-3.3-70b',
            'api_key' => $apiKey,
            'solution' => [
                'type' => 'ragie',
                'metadata' => $metadata,
            ],
        ];
    }
}
</document_content>
</document>

<document index="135">
<source>tests/Router/KeyRotatorTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Router/KeyRotatorTest.php

namespace ParaGra\Tests\Router;

use ParaGra\Config\ProviderSpec;
use ParaGra\Router\KeyRotator;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\TestCase;
use RuntimeException;

#[CoversClass(KeyRotator::class)]
#[UsesClass(ProviderSpec::class)]
final class KeyRotatorTest extends TestCase
{
    public function test_select_spec_when_pool_empty_then_throws(): void
    {
        $rotator = new KeyRotator();

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('empty');

        $rotator->selectSpec([]);
    }

    public function test_select_spec_when_pool_has_single_spec_then_returns_it(): void
    {
        $spec = $this->createSpec('key-1');
        $rotator = new KeyRotator();

        self::assertSame($spec, $rotator->selectSpec([$spec]));
    }

    public function test_select_spec_when_multiple_specs_then_uses_timestamp_distribution(): void
    {
        $pool = [
            $this->createSpec('key-1'),
            $this->createSpec('key-2'),
            $this->createSpec('key-3'),
        ];

        $rotator = new KeyRotator(static fn (): int => 5);

        $selected = $rotator->selectSpec($pool);

        self::assertSame('key-3', $selected->apiKey);
    }

    public function test_get_next_spec_wraps_back_to_first_entry(): void
    {
        $pool = [
            $this->createSpec('key-1'),
            $this->createSpec('key-2'),
        ];

        $rotator = new KeyRotator(static fn (): int => 0);

        $next = $rotator->getNextSpec($pool, 1);

        self::assertSame('key-1', $next->apiKey);
    }

    public function test_select_spec_rotates_evenly_between_two_specs(): void
    {
        $pool = [
            $this->createSpec('key-1'),
            $this->createSpec('key-2'),
        ];

        $rotator = $this->createSequentialRotator();
        $distribution = ['key-1' => 0, 'key-2' => 0];

        for ($i = 0; $i < 100; $i++) {
            $selected = $rotator->selectSpec($pool);
            $distribution[$selected->apiKey]++;
        }

        self::assertSame(50, $distribution['key-1']);
        self::assertSame(50, $distribution['key-2']);
    }

    public function test_select_spec_rotates_evenly_between_three_specs(): void
    {
        $pool = [
            $this->createSpec('key-1'),
            $this->createSpec('key-2'),
            $this->createSpec('key-3'),
        ];

        $rotator = $this->createSequentialRotator();
        $distribution = ['key-1' => 0, 'key-2' => 0, 'key-3' => 0];

        for ($i = 0; $i < 300; $i++) {
            $selected = $rotator->selectSpec($pool);
            $distribution[$selected->apiKey]++;
        }

        self::assertSame(100, $distribution['key-1']);
        self::assertSame(100, $distribution['key-2']);
        self::assertSame(100, $distribution['key-3']);
    }

    public function test_select_spec_rotates_evenly_between_five_specs(): void
    {
        $pool = [
            $this->createSpec('key-1'),
            $this->createSpec('key-2'),
            $this->createSpec('key-3'),
            $this->createSpec('key-4'),
            $this->createSpec('key-5'),
        ];

        $rotator = $this->createSequentialRotator();
        $distribution = [
            'key-1' => 0,
            'key-2' => 0,
            'key-3' => 0,
            'key-4' => 0,
            'key-5' => 0,
        ];

        for ($i = 0; $i < 500; $i++) {
            $selected = $rotator->selectSpec($pool);
            $distribution[$selected->apiKey]++;
        }

        self::assertSame(100, $distribution['key-1']);
        self::assertSame(100, $distribution['key-2']);
        self::assertSame(100, $distribution['key-3']);
        self::assertSame(100, $distribution['key-4']);
        self::assertSame(100, $distribution['key-5']);
    }

    private function createSpec(string $key): ProviderSpec
    {
        return new ProviderSpec(
            provider: 'openai',
            model: 'gpt-4o-mini',
            apiKey: $key,
            solution: ['type' => 'ragie'],
        );
    }

    private function createSequentialRotator(): KeyRotator
    {
        $tick = 0;

        return new KeyRotator(static function () use (&$tick): int {
            return $tick++;
        });
    }
}
</document_content>
</document>

<document index="136">
<source>tests/Support/ExceptionEnhancerTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Support/ExceptionEnhancerTest.php

namespace ParaGra\Tests\Support;

use ParaGra\Support\ExceptionEnhancer;
use PHPUnit\Framework\TestCase;
use Ragie\Api\ApiException;
use RuntimeException;

final class ExceptionEnhancerTest extends TestCase
{
    public function test_enhance_api_exception_adds_http_status(): void
    {
        $original = new ApiException('Original message', 429);

        $enhanced = ExceptionEnhancer::enhanceApiException($original);

        self::assertStringContainsString('[429]', $enhanced->getMessage());
        self::assertStringContainsString('Original message', $enhanced->getMessage());
    }

    public function test_enhance_api_exception_extracts_detail_from_json_response(): void
    {
        $responseBody = json_encode(['detail' => 'Rate limit exceeded']) ?: '';
        $original = new ApiException('API error', 429, null, $responseBody);

        $enhanced = ExceptionEnhancer::enhanceApiException($original);

        self::assertStringContainsString('Detail: Rate limit exceeded', $enhanced->getMessage());
    }

    public function test_enhance_api_exception_extracts_message_from_json_response(): void
    {
        $responseBody = json_encode(['message' => 'Invalid request']) ?: '';
        $original = new ApiException('API error', 400, null, $responseBody);

        $enhanced = ExceptionEnhancer::enhanceApiException($original);

        self::assertStringContainsString('Detail: Invalid request', $enhanced->getMessage());
    }

    public function test_enhance_api_exception_adds_context(): void
    {
        $original = new ApiException('API error', 500);
        $context = ['query' => 'test query', 'user_id' => 123];

        $enhanced = ExceptionEnhancer::enhanceApiException($original, $context);

        self::assertStringContainsString('Context:', $enhanced->getMessage());
        self::assertStringContainsString('query=test query', $enhanced->getMessage());
        self::assertStringContainsString('user_id=123', $enhanced->getMessage());
    }

    public function test_enhance_api_exception_handles_array_context(): void
    {
        $original = new ApiException('API error', 500);
        $context = ['filters' => ['type' => 'doc', 'status' => 'active']];

        $enhanced = ExceptionEnhancer::enhanceApiException($original, $context);

        self::assertStringContainsString('filters=', $enhanced->getMessage());
    }

    public function test_get_user_message_returns_rate_limit_message_for_429(): void
    {
        $exception = new ApiException('Rate limit error', 429);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('Rate limit exceeded. Please try again in a moment.', $message);
    }

    public function test_get_user_message_returns_auth_message_for_401(): void
    {
        $exception = new ApiException('Unauthorized', 401);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('Authentication failed. Please check your API key.', $message);
    }

    public function test_get_user_message_returns_auth_message_for_403(): void
    {
        $exception = new ApiException('Forbidden', 403);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('Authentication failed. Please check your API key.', $message);
    }

    public function test_get_user_message_returns_server_error_for_500(): void
    {
        $exception = new ApiException('Internal server error', 500);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('Service temporarily unavailable. Please try again later.', $message);
    }

    public function test_get_user_message_returns_client_error_for_400(): void
    {
        $exception = new ApiException('Bad request', 400);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('Invalid request. Please check your input.', $message);
    }

    public function test_get_user_message_returns_generic_message_for_non_api_exception(): void
    {
        $exception = new RuntimeException('Something went wrong');

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('An error occurred while processing your request.', $message);
    }

    public function test_get_user_message_returns_generic_message_for_unknown_status(): void
    {
        $exception = new ApiException('Unknown error', 0);

        $message = ExceptionEnhancer::getUserMessage($exception);

        self::assertSame('An error occurred while processing your request.', $message);
    }
}
</document_content>
</document>

<document index="137">
<source>tests/Util/ConfigValidatorTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/Util/ConfigValidatorTest.php

namespace ParaGra\Tests\Util;

use ParaGra\Exception\ConfigurationException;
use ParaGra\Util\ConfigValidator;
use PHPUnit\Framework\TestCase;

final class ConfigValidatorTest extends TestCase
{
    #[\Override]
    protected function setUp(): void
    {
        unset($_ENV['TEST_VAR'], $_ENV['TEST_VAR_EMPTY'], $_ENV['TEST_VAR_WHITESPACE']);
    }

    public function test_require_env_returns_value_when_variable_exists(): void
    {
        $_ENV['TEST_VAR'] = 'test_value';

        $result = ConfigValidator::requireEnv('TEST_VAR');

        self::assertSame('test_value', $result);
    }

    public function test_require_env_trims_whitespace(): void
    {
        $_ENV['TEST_VAR'] = '  test_value  ';

        $result = ConfigValidator::requireEnv('TEST_VAR');

        self::assertSame('test_value', $result);
    }

    public function test_require_env_throws_when_variable_missing(): void
    {
        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('Required environment variable "MISSING_VAR" is not set');

        ConfigValidator::requireEnv('MISSING_VAR');
    }

    public function test_require_env_throws_when_variable_empty(): void
    {
        $_ENV['TEST_VAR_EMPTY'] = '';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('Environment variable "TEST_VAR_EMPTY" is set but empty');

        ConfigValidator::requireEnv('TEST_VAR_EMPTY');
    }

    public function test_require_env_throws_when_variable_whitespace_only(): void
    {
        $_ENV['TEST_VAR_WHITESPACE'] = '   ';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('Environment variable "TEST_VAR_WHITESPACE" is set but empty');

        ConfigValidator::requireEnv('TEST_VAR_WHITESPACE');
    }

    public function test_require_all_validates_multiple_variables(): void
    {
        $_ENV['VAR1'] = 'value1';
        $_ENV['VAR2'] = 'value2';
        $_ENV['VAR3'] = 'value3';

        ConfigValidator::requireAll(['VAR1', 'VAR2', 'VAR3']);

        self::assertTrue(true, 'No exception thrown.');
    }

    public function test_require_all_throws_on_first_missing_variable(): void
    {
        unset($_ENV['VAR1'], $_ENV['VAR2'], $_ENV['VAR3']);

        $_ENV['VAR1'] = 'value1';
        $_ENV['VAR3'] = 'value3';

        $this->expectException(ConfigurationException::class);
        $this->expectExceptionMessage('Required environment variable "VAR2" is not set');

        ConfigValidator::requireAll(['VAR1', 'VAR2', 'VAR3']);
    }

    public function test_get_env_returns_value_when_exists(): void
    {
        $_ENV['TEST_VAR'] = 'test_value';

        $result = ConfigValidator::getEnv('TEST_VAR', 'default');

        self::assertSame('test_value', $result);
    }

    public function test_get_env_returns_default_when_missing(): void
    {
        $result = ConfigValidator::getEnv('MISSING_VAR', 'default_value');

        self::assertSame('default_value', $result);
    }

    public function test_get_env_returns_default_when_empty(): void
    {
        $_ENV['TEST_VAR_EMPTY'] = '';

        $result = ConfigValidator::getEnv('TEST_VAR_EMPTY', 'default_value');

        self::assertSame('default_value', $result);
    }

    public function test_get_env_returns_empty_string_when_no_default(): void
    {
        $result = ConfigValidator::getEnv('MISSING_VAR');

        self::assertSame('', $result);
    }

    public function test_get_env_trims_whitespace(): void
    {
        $_ENV['TEST_VAR'] = '  value  ';

        $result = ConfigValidator::getEnv('TEST_VAR');

        self::assertSame('value', $result);
    }
}
</document_content>
</document>

<document index="138">
<source>tests/VectorStore/ChromaVectorStoreTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/ChromaVectorStoreTest.php

namespace ParaGra\Tests\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\VectorStore\ChromaVectorStore;
use ParaGra\VectorStore\VectorNamespace;
use PHPUnit\Framework\TestCase;

use const JSON_THROW_ON_ERROR;

/**
 * @covers \ParaGra\VectorStore\ChromaVectorStore
 */
final class ChromaVectorStoreTest extends TestCase
{
    public function testUpsertSendsRecordsToCollection(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['ids' => ['doc-1', 'doc-2']], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'http://localhost:8000/api/v2/',
        ]);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            defaultNamespace: new VectorNamespace('kb', 'kb'),
            authToken: 'secret',
            httpClient: $client,
        );

        $records = [
            [
                'id' => 'doc-1',
                'values' => [0.1, 0.2],
                'metadata' => ['text' => 'Chunk one', 'source' => 'kb'],
            ],
            [
                'id' => 'doc-2',
                'values' => [0.3, 0.4],
                'metadata' => ['text' => 'Chunk two'],
            ],
        ];

        $namespace = new VectorNamespace('kb', 'kb');
        $result = $store->upsert($namespace, $records);

        self::assertSame(['upserted' => 2, 'updated' => 0], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('POST', $request->getMethod());
        self::assertSame(
            '/api/v2/tenants/default/databases/db/collections/kb/upsert',
            $request->getUri()->getPath()
        );
        self::assertSame('Bearer secret', $request->getHeaderLine('Authorization'));

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(['doc-1', 'doc-2'], $payload['ids']);
        self::assertSame([[0.1, 0.2], [0.3, 0.4]], $payload['embeddings']);
        self::assertSame(
            [
                ['text' => 'Chunk one', 'source' => 'kb'],
                ['text' => 'Chunk two'],
            ],
            $payload['metadatas']
        );
        self::assertSame(['Chunk one', 'Chunk two'], $payload['documents']);
    }

    public function testDeleteRemovesIdsFromCollection(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['ids' => ['doc-1']], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'http://localhost:8000/api/v2/',
        ]);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', 'kb');
        $result = $store->delete($namespace, ['doc-1', 'doc-2']);

        self::assertSame(['deleted' => 2], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('POST', $request->getMethod());
        self::assertSame(
            '/api/v2/tenants/default/databases/db/collections/kb/delete',
            $request->getUri()->getPath()
        );

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(['doc-1', 'doc-2'], $payload['ids']);
    }

    public function testQueryNormalizesResponse(): void
    {
        $history = [];
        $response = [
            'ids' => [['doc-1', 'doc-2']],
            'distances' => [[0.15, 0.75]],
            'documents' => [['Document body one', '']],
            'metadatas' => [[
                ['title' => 'Doc One', 'url' => 'https://example.test/doc-1'],
                ['content' => 'Fallback chunk body', 'source' => 'import'],
            ]],
        ];

        $mock = new MockHandler([
            new Response(200, [], json_encode($response, JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'http://localhost:8000/api/v2/',
        ]);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', 'kb', metadata: ['source' => 'kb']);
        $result = $store->query($namespace, [0.1, 0.2, 0.3], ['top_k' => 2]);

        self::assertSame('chroma', $result->getProvider());
        self::assertSame('kb', $result->getModel());
        self::assertCount(2, $result->getChunks());

        $chunks = $result->getChunks();
        self::assertSame('Document body one', $chunks[0]['text']);
        self::assertSame('doc-1', $chunks[0]['document_id']);
        self::assertSame('Doc One', $chunks[0]['document_name']);
        self::assertSame(
            ['url' => 'https://example.test/doc-1'],
            $chunks[0]['metadata']
        );
        self::assertEqualsWithDelta(0.8695, $chunks[0]['score'], 0.0001);

        self::assertSame('Fallback chunk body', $chunks[1]['text']);
        self::assertSame('doc-2', $chunks[1]['document_id']);
        self::assertSame(['source' => 'import'], $chunks[1]['metadata']);
        self::assertEqualsWithDelta(0.5714, $chunks[1]['score'], 0.0001);

        self::assertCount(1, $history);
        $request = $history[0]['request'];
        self::assertSame(
            '/api/v2/tenants/default/databases/db/collections/kb/query',
            $request->getUri()->getPath()
        );
        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame([[0.1, 0.2, 0.3]], $payload['query_embeddings']);
        self::assertSame(2, $payload['n_results']);
        self::assertSame(
            ['source' => 'kb'],
            $payload['where']
        );
        self::assertSame(['documents', 'metadatas'], $payload['include']);

        $metadata = $result->getProviderMetadata();
        self::assertSame('default', $metadata['tenant']);
        self::assertSame('db', $metadata['database']);
        self::assertSame('kb', $metadata['collection']);
        self::assertSame(2, $metadata['match_count']);
    }

    public function testQueryIncludesEmbeddingsWhenRequested(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['ids' => [[]]], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'http://localhost:8000/api/v2/',
        ]);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', metadata: ['topics' => ['kb', 'manual'], 'priority' => 2]);
        $store->query($namespace, [0.1], ['include_vectors' => true, 'top_k' => 1]);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(['documents', 'metadatas', 'embeddings'], $payload['include']);
        self::assertSame(
            [
                '$and' => [
                    ['topics' => ['$in' => ['kb', 'manual']]],
                    ['priority' => 2],
                ],
            ],
            $payload['where']
        );
    }

    public function testDeleteHonoursTimeoutOption(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['ids' => ['doc-1']], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'http://localhost:8000/api/v2/',
        ]);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb');
        $store->delete($namespace, ['doc-1'], ['timeout_ms' => 500]);

        self::assertEquals(0.5, $history[0]['options']['timeout']);
    }

    public function testDeleteFallsBackToNamespaceNameWhenCollectionMissing(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['ids' => ['doc-1']], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:8000/api/v2/']);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $store->delete(new VectorNamespace('alias', null), ['doc-1']);

        $request = $history[0]['request'];
        self::assertStringContainsString('/collections/alias/delete', (string) $request->getUri());
    }

    public function testQuerySkipsChunksWithoutTextOrMetadata(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'ids' => [['doc-1']],
                'documents' => [['   ']],
                'metadatas' => [[[]]],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:8000/api/v2/']);

        $store = new ChromaVectorStore(
            baseUrl: 'http://localhost:8000',
            tenant: 'default',
            database: 'db',
            collection: 'kb',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb');
        $result = $store->query($namespace, [0.1], ['top_k' => 1]);

        self::assertCount(0, $result->getChunks());
    }
}
</document_content>
</document>

<document index="139">
<source>tests/VectorStore/GeminiFileSearchVectorStoreTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/GeminiFileSearchVectorStoreTest.php

namespace ParaGra\Tests\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\VectorStore\GeminiFileSearchVectorStore;
use ParaGra\VectorStore\VectorNamespace;
use PHPUnit\Framework\TestCase;
use RuntimeException;
use ReflectionClass;

use function json_decode;
use function json_encode;
use function parse_str;

use const JSON_THROW_ON_ERROR;

/**
 * @covers \ParaGra\VectorStore\GeminiFileSearchVectorStore
 */
final class GeminiFileSearchVectorStoreTest extends TestCase
{
    public function testUpsertCreatesDocuments(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['documents' => []], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'https://generativelanguage.googleapis.com',
        ]);

        $store = new GeminiFileSearchVectorStore(
            apiKey: 'test-key',
            resourceName: 'fileSearchStores/demo-store',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('demo', 'fileSearchStores/demo-store');

        $records = [
            [
                'id' => 'DocOne',
                'values' => [0.1, 0.2],
                'metadata' => [
                    'text' => 'First chunk body',
                    'display_name' => 'Doc One',
                    'topic' => 'kb',
                ],
            ],
            [
                'id' => 'DocTwo',
                'values' => [0.3, 0.9],
                'metadata' => [
                    'text' => 'Second chunk',
                    'source' => 'manual',
                    'tags' => ['alpha', 'beta'],
                ],
            ],
        ];

        $result = $store->upsert($namespace, $records);

        self::assertSame(['upserted' => 2, 'updated' => 0], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('POST', $request->getMethod());
        self::assertSame(
            '/v1beta/fileSearchStores/demo-store/documents:batchCreate',
            $request->getUri()->getPath()
        );

        parse_str($request->getUri()->getQuery(), $query);
        self::assertSame('test-key', $query['key']);

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertCount(2, $payload['requests']);

        $first = $payload['requests'][0];
        self::assertSame('docone', $first['documentId']);
        self::assertSame('Doc One', $first['document']['displayName']);
        self::assertSame(
            [
                ['key' => 'topic', 'value' => 'kb'],
            ],
            $first['document']['customMetadata']
        );
        $jsonData = json_decode($first['document']['jsonData'], true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('docone', $jsonData['id']);
        self::assertSame('First chunk body', $jsonData['text']);

        $second = $payload['requests'][1];
        self::assertSame('doctwo', $second['documentId']);
        $secondMetadata = $second['document']['customMetadata'];
        self::assertCount(3, $secondMetadata);
        self::assertSame(
            [
                ['key' => 'source', 'value' => 'manual'],
                ['key' => 'tags', 'value' => 'alpha'],
                ['key' => 'tags', 'value' => 'beta'],
            ],
            $secondMetadata
        );
    }

    public function testDeleteRemovesDocuments(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(204),
            new Response(204),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'https://generativelanguage.googleapis.com',
        ]);

        $store = new GeminiFileSearchVectorStore(
            apiKey: 'test-key',
            resourceName: 'fileSearchStores/demo-store',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('demo', 'fileSearchStores/demo-store');

        $result = $store->delete($namespace, ['doc-1', 'doc-2']);

        self::assertSame(['deleted' => 2], $result);
        self::assertCount(2, $history);

        $firstRequest = $history[0]['request'];
        self::assertSame('DELETE', $firstRequest->getMethod());
        self::assertSame(
            '/v1beta/fileSearchStores/demo-store/documents/doc-1',
            $firstRequest->getUri()->getPath()
        );
    }

    public function testQueryReturnsUnifiedResponse(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'relevantChunks' => [
                    [
                        'text' => 'Chunk one answer',
                        'relevanceScore' => 0.92,
                        'documentId' => 'doc-1',
                        'chunkId' => 'chunk-1',
                        'metadata' => ['source' => 'kb'],
                        'pageSpan' => ['startPage' => 1, 'endPage' => 2],
                    ],
                    [
                        'text' => 'Chunk two answer',
                        'relevanceScore' => 0.75,
                    ],
                ],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client([
            'handler' => $handler,
            'base_uri' => 'https://generativelanguage.googleapis.com',
        ]);

        $store = new GeminiFileSearchVectorStore(
            apiKey: 'test-key',
            resourceName: 'projects/demo/locations/us/corpora/my-corpus',
            httpClient: $client,
        );

        $namespace = new VectorNamespace(
            name: 'demo',
            collection: 'projects/demo/locations/us/corpora/my-corpus',
            metadata: ['source' => 'kb']
        );

        $response = $store->query($namespace, [], ['query' => 'Where is doc?', 'top_k' => 3]);

        self::assertSame('gemini-file-search', $response->getProvider());
        self::assertSame('projects/demo/locations/us/corpora/my-corpus', $response->getModel());
        self::assertCount(2, $response->getChunks());

        $chunks = $response->getChunks();
        self::assertSame('Chunk one answer', $chunks[0]['text']);
        self::assertSame('doc-1', $chunks[0]['document_id']);
        self::assertSame('chunk-1', $chunks[0]['metadata']['chunk_id']);
        self::assertSame(['startPage' => 1, 'endPage' => 2], $chunks[0]['metadata']['page_span']);

        self::assertSame('Chunk two answer', $chunks[1]['text']);

        $request = $history[0]['request'];
        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('Where is doc?', $payload['query']);
        self::assertSame(['maxChunks' => 3], $payload['chunkControl']);
        self::assertSame(
            [['key' => 'source', 'value' => 'kb']],
            $payload['metadataFilters']
        );
    }

    public function testQueryAllowsResourceOverrideAndNormalizes(): void
    {
        $history = [];
        $handler = HandlerStack::create(new MockHandler([
            new Response(200, [], json_encode(['relevantChunks' => []], JSON_THROW_ON_ERROR)),
        ]));
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://generativelanguage.googleapis.com']);
        $store = new GeminiFileSearchVectorStore('key', 'fileSearchStores/default', httpClient: $client);

        $namespace = new VectorNamespace('default');
        $store->query($namespace, [], ['query' => 'Hello', 'resource' => 'custom-store']);

        $request = $history[0]['request'];
        self::assertSame(
            '/v1beta/fileSearchStores/custom-store/documents:query',
            $request->getUri()->getPath()
        );
    }

    public function testQueryRejectsEmptyResourceOverrides(): void
    {
        $store = new GeminiFileSearchVectorStore('key', 'fileSearchStores/default');
        $namespace = new VectorNamespace('default');

        $this->expectException(RuntimeException::class);
        $store->query($namespace, [], ['query' => 'Hello', 'resource' => '   ']);
    }

    public function testQueryBuildsMetadataFiltersForListsAndScalars(): void
    {
        $history = [];
        $handler = HandlerStack::create(new MockHandler([
            new Response(200, [], json_encode(['relevantChunks' => []], JSON_THROW_ON_ERROR)),
        ]));
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://generativelanguage.googleapis.com']);
        $store = new GeminiFileSearchVectorStore('key', 'fileSearchStores/default', httpClient: $client);

        $namespace = new VectorNamespace('default', metadata: [
            'labels' => ['kb', 'manual'],
            'active' => true,
            'score' => 0.91,
        ]);

        $store->query($namespace, [], ['query' => 'Explain ParaGra']);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertEqualsCanonicalizing(
            [
                ['key' => 'labels', 'value' => 'kb'],
                ['key' => 'labels', 'value' => 'manual'],
                ['key' => 'active', 'value' => 'true'],
                ['key' => 'score', 'value' => '0.91'],
            ],
            $payload['metadataFilters']
        );
    }

    public function testSanitizeDocumentIdGeneratesSafeFallbacks(): void
    {
        $store = new GeminiFileSearchVectorStore('key', 'fileSearchStores/default');
        $reflection = new ReflectionClass($store);
        $method = $reflection->getMethod('sanitizeDocumentId');
        $method->setAccessible(true);

        $generated = $method->invoke($store, '');
        self::assertNotSame('', $generated);
        self::assertSame(strtolower($generated), $generated);
    }

    public function testQueryRequiresNonEmptyQuery(): void
    {
        $store = new GeminiFileSearchVectorStore(
            apiKey: 'key',
            resourceName: 'fileSearchStores/demo-store'
        );

        $namespace = new VectorNamespace('demo', 'fileSearchStores/demo-store');

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('non-empty "query" option');
        $store->query($namespace, [], ['query' => '   ']);
    }

    public function testUpsertThrowsWhenTextMissing(): void
    {
        $store = new GeminiFileSearchVectorStore(
            apiKey: 'key',
            resourceName: 'fileSearchStores/demo-store'
        );

        $namespace = new VectorNamespace('demo', 'fileSearchStores/demo-store');

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('metadata["text"]');
        $store->upsert($namespace, [[
            'id' => 'missing-text',
            'values' => [0.1],
            'metadata' => ['display_name' => 'Doc'],
        ]]);
    }

    public function testDeleteWithNoIdsSkipsRequests(): void
    {
        $history = [];
        $handler = HandlerStack::create(new MockHandler([]));
        $handler->push(Middleware::history($history));
        $client = new Client(['handler' => $handler, 'base_uri' => 'https://generativelanguage.googleapis.com']);

        $store = new GeminiFileSearchVectorStore(
            apiKey: 'key',
            resourceName: 'fileSearchStores/demo-store',
            httpClient: $client
        );

        $namespace = new VectorNamespace('demo', 'fileSearchStores/demo-store');
        $result = $store->delete($namespace, []);

        self::assertSame(['deleted' => 0], $result);
        self::assertCount(0, $history);
    }
}
</document_content>
</document>

<document index="140">
<source>tests/VectorStore/PineconeVectorStoreTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/PineconeVectorStoreTest.php

namespace ParaGra\Tests\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\VectorStore\PineconeVectorStore;
use ParaGra\VectorStore\VectorNamespace;
use PHPUnit\Framework\TestCase;
use RuntimeException;

use const JSON_THROW_ON_ERROR;

/**
 * @covers \ParaGra\VectorStore\PineconeVectorStore
 */
final class PineconeVectorStoreTest extends TestCase
{
    public function testUpsertSendsVectorsAndReturnsCounts(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['upsertedCount' => 2], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.pinecone.io']);

        $store = new PineconeVectorStore(
            baseUrl: 'https://example.pinecone.io',
            apiKey: 'test-key',
            indexName: 'demo-index',
            defaultNamespace: new VectorNamespace('docs'),
            apiVersion: '2024-07',
            httpClient: $client,
        );

        $records = [
            [
                'id' => 'doc-1',
                'values' => [0.1, 0.2],
                'metadata' => ['text' => 'Chunk one', 'source' => 'kb'],
            ],
            [
                'id' => 'doc-2',
                'values' => [0.3, 0.4],
                'metadata' => ['text' => 'Chunk two'],
            ],
        ];

        $result = $store->upsert(new VectorNamespace('docs'), $records);

        self::assertSame(['upserted' => 2, 'updated' => 0], $result);
        self::assertCount(1, $history);
        $request = $history[0]['request'];

        self::assertSame('POST', $request->getMethod());
        self::assertSame('/vectors/upsert', $request->getUri()->getPath());
        self::assertSame('test-key', $request->getHeaderLine('Api-Key'));
        self::assertSame('2024-07', $request->getHeaderLine('X-Pinecone-API-Version'));

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('docs', $payload['namespace']);
        self::assertCount(2, $payload['vectors']);
        self::assertSame('doc-1', $payload['vectors'][0]['id']);
        self::assertSame([0.1, 0.2], $payload['vectors'][0]['values']);
        self::assertSame(['text' => 'Chunk one', 'source' => 'kb'], $payload['vectors'][0]['metadata']);
    }

    public function testDeleteByIds(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['deletedCount' => 3], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.pinecone.io']);

        $store = new PineconeVectorStore(
            baseUrl: 'https://example.pinecone.io',
            apiKey: 'test-key',
            indexName: 'demo-index',
            defaultNamespace: new VectorNamespace('docs'),
            httpClient: $client,
        );

        $result = $store->delete(new VectorNamespace('docs'), ['doc-1', 'doc-2']);

        self::assertSame(['deleted' => 3], $result);
        self::assertCount(1, $history);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(['doc-1', 'doc-2'], $payload['ids']);
        self::assertSame('docs', $payload['namespace']);
    }

    public function testQueryConvertsMatchesToUnifiedResponse(): void
    {
        $response = [
            'namespace' => 'docs',
            'matches' => [
                [
                    'id' => 'doc-1',
                    'score' => 0.92,
                    'metadata' => [
                        'text' => 'First chunk',
                        'source' => 'kb',
                        'url' => 'https://example.test/doc-1',
                    ],
                ],
                [
                    'id' => 'doc-2',
                    'score' => 0.61,
                    'metadata' => [
                        'content' => 'Second chunk body',
                        'title' => 'Doc 2',
                    ],
                ],
            ],
        ];

        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode($response, JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.pinecone.io']);

        $store = new PineconeVectorStore(
            baseUrl: 'https://example.pinecone.io',
            apiKey: 'test-key',
            indexName: 'demo-index',
            defaultNamespace: new VectorNamespace('docs'),
            httpClient: $client,
        );

        $vector = [0.1, 0.2, 0.3];
        $result = $store->query(new VectorNamespace('docs'), $vector, ['top_k' => 2]);

        self::assertSame('pinecone', $result->getProvider());
        self::assertSame('demo-index', $result->getModel());
        self::assertCount(2, $result->getChunks());

        $chunks = $result->getChunks();
        self::assertSame('First chunk', $chunks[0]['text']);
        self::assertSame(0.92, $chunks[0]['score']);
        self::assertSame('doc-1', $chunks[0]['document_id']);
        self::assertSame(['source' => 'kb', 'url' => 'https://example.test/doc-1'], $chunks[0]['metadata']);

        self::assertSame('Second chunk body', $chunks[1]['text']);
        self::assertSame('doc-2', $chunks[1]['document_id']);
        self::assertSame('Doc 2', $chunks[1]['document_name']);

        self::assertCount(1, $history);
        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame([0.1, 0.2, 0.3], $payload['vector']);
        self::assertSame(2, $payload['topK']);
        self::assertTrue($payload['includeMetadata']);
    }

    public function testQueryAppliesMetadataFilterAndIncludesVectors(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['matches' => []], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.pinecone.io']);

        $metadataNamespace = new VectorNamespace('docs', metadata: ['labels' => ['kb'], 'priority' => 2]);
        $store = new PineconeVectorStore(
            baseUrl: 'https://example.pinecone.io',
            apiKey: 'test-key',
            indexName: 'demo-index',
            defaultNamespace: $metadataNamespace,
            httpClient: $client,
        );

        $store->query($metadataNamespace, [0.5], ['include_vectors' => true]);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertTrue($payload['includeValues']);
        self::assertSame(['labels' => ['$in' => ['kb']], 'priority' => ['$eq' => 2]], $payload['filter']);
    }

    public function testConstructorRejectsEmptyBaseUrl(): void
    {
        $this->expectException(RuntimeException::class);
        new PineconeVectorStore(baseUrl: '  ', apiKey: 'key', indexName: 'idx');
    }
}
</document_content>
</document>

<document index="141">
<source>tests/VectorStore/QdrantVectorStoreTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/QdrantVectorStoreTest.php

namespace ParaGra\Tests\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\Response\UnifiedResponse;
use ParaGra\VectorStore\QdrantVectorStore;
use ParaGra\VectorStore\VectorNamespace;
use PHPUnit\Framework\TestCase;
use RuntimeException;

use const JSON_THROW_ON_ERROR;

/**
 * @covers \ParaGra\VectorStore\QdrantVectorStore
 */
final class QdrantVectorStoreTest extends TestCase
{
    public function testUpsertCreatesPointsPayload(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['result' => ['status' => 'ok']], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:6333']);

        $store = new QdrantVectorStore(
            baseUrl: 'http://localhost:6333',
            collection: 'docs',
            apiKey: 'secret',
            httpClient: $client,
        );

        $records = [
            [
                'id' => 'doc-1',
                'values' => [0.1, 0.2],
                'metadata' => ['text' => 'Body', 'source' => 'kb'],
            ],
        ];

        $result = $store->upsert(new VectorNamespace('docs'), $records, ['wait_for_sync' => true]);

        self::assertSame(['upserted' => 1, 'updated' => 0], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('PUT', $request->getMethod());
        self::assertSame('/collections/docs/points', $request->getUri()->getPath());
        self::assertSame('secret', $request->getHeaderLine('api-key'));

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertTrue($payload['wait']);
        self::assertCount(1, $payload['points']);
        self::assertSame('doc-1', $payload['points'][0]['id']);
        self::assertSame(['text' => 'Body', 'source' => 'kb'], $payload['points'][0]['payload']);
    }

    public function testDeletePostsFilterPayload(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['status' => 'ok'], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:6333']);

        $store = new QdrantVectorStore(
            baseUrl: 'http://localhost:6333',
            collection: 'docs',
            apiKey: 'secret',
            httpClient: $client,
        );

        $result = $store->delete(new VectorNamespace('docs'), ['doc-1', 'doc-2']);

        self::assertSame(['deleted' => 2], $result);
        self::assertCount(1, $history);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame(['doc-1', 'doc-2'], $payload['points']);
    }

    public function testQueryBuildsUnifiedResponse(): void
    {
        $qdrantResponse = [
            'result' => [
                [
                    'id' => 'doc-1',
                    'score' => 0.88,
                    'payload' => ['text' => 'Chunk text', 'url' => 'https://example.test'],
                ],
                [
                    'id' => 'doc-2',
                    'score' => 0.51,
                    'payload' => ['content' => 'Second record', 'title' => 'Doc 2'],
                ],
            ],
        ];

        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode($qdrantResponse, JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:6333']);

        $store = new QdrantVectorStore(
            baseUrl: 'http://localhost:6333',
            collection: 'docs',
            apiKey: null,
            httpClient: $client,
        );

        $vector = [0.1, 0.2, 0.3];
        $response = $store->query(new VectorNamespace('docs'), $vector, ['top_k' => 5]);

        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame('qdrant', $response->getProvider());
        self::assertSame('docs', $response->getModel());

        $chunks = $response->getChunks();
        self::assertCount(2, $chunks);
        self::assertSame('Chunk text', $chunks[0]['text']);
        self::assertSame(0.88, $chunks[0]['score']);
        self::assertSame(['url' => 'https://example.test'], $chunks[0]['metadata']);

        self::assertSame('Second record', $chunks[1]['text']);
        self::assertSame('Doc 2', $chunks[1]['document_name']);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame($vector, $payload['vector']);
        self::assertSame(5, $payload['limit']);
        self::assertTrue($payload['with_payload']);
        self::assertFalse($payload['with_vector']);
    }

    public function testQueryAppliesNamespaceMetadataFilter(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['result' => []], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:6333']);

        $store = new QdrantVectorStore(
            baseUrl: 'http://localhost:6333',
            collection: 'docs',
            apiKey: null,
            httpClient: $client,
        );

        $namespace = new VectorNamespace('docs', metadata: [
            'labels' => ['kb', 'manual'],
            'priority' => 2,
        ]);

        $store->query($namespace, [0.5], ['top_k' => 1]);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame([
            'must' => [
                ['key' => 'labels', 'match' => ['any' => ['kb', 'manual']]],
                ['key' => 'priority', 'match' => ['value' => 2]],
            ],
        ], $payload['filter']);
    }

    public function testQueryIncludesVectorsWhenRequested(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['result' => []], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'http://localhost:6333']);

        $store = new QdrantVectorStore(
            baseUrl: 'http://localhost:6333',
            collection: 'docs',
            httpClient: $client,
        );

        $store->query(new VectorNamespace('docs'), [0.2], ['include_vectors' => true]);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertTrue($payload['with_vector']);
    }

    public function testConstructorRejectsEmptyBaseUrl(): void
    {
        $this->expectException(RuntimeException::class);
        new QdrantVectorStore(baseUrl: '   ', collection: 'docs');
    }
}
</document_content>
</document>

<document index="142">
<source>tests/VectorStore/VectorNamespaceTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/VectorNamespaceTest.php

namespace ParaGra\Tests\VectorStore;

use InvalidArgumentException;
use ParaGra\VectorStore\VectorNamespace;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

#[CoversClass(VectorNamespace::class)]
final class VectorNamespaceTest extends TestCase
{
    public function test_it_normalizes_name_collection_and_metadata(): void
    {
        $namespace = new VectorNamespace(
            name: ' Customer Docs ',
            collection: ' Primary ',
            eventuallyConsistent: true,
            metadata: ['region' => 'us-west-2', 'tier' => 'hot'],
        );

        self::assertSame('customer-docs', $namespace->getName());
        self::assertSame('Primary', $namespace->getCollection());
        self::assertTrue($namespace->isEventuallyConsistent());
        self::assertSame(['region' => 'us-west-2', 'tier' => 'hot'], $namespace->getMetadata());
        self::assertSame(
            [
                'name' => 'customer-docs',
                'collection' => 'Primary',
                'eventual_consistency' => true,
                'metadata' => ['region' => 'us-west-2', 'tier' => 'hot'],
            ],
            $namespace->toArray(),
        );
    }

    public function test_it_rejects_invalid_namespace_names(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Vector namespace name');

        new VectorNamespace('!!!');
    }

    public function test_it_rejects_invalid_metadata_values(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Metadata lists must be indexed sequentially');

        new VectorNamespace('docs', metadata: ['invalid' => ['nested' => ['oops']]]);
    }

    public function test_it_nulls_out_blank_collection_values(): void
    {
        $namespace = new VectorNamespace('docs', collection: '  ');
        self::assertNull($namespace->getCollection());
    }

    public function test_it_rejects_overly_long_names(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new VectorNamespace(str_repeat('segment', 11));
    }

    public function test_it_rejects_empty_metadata_keys(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new VectorNamespace('docs', metadata: [' ' => 'value']);
    }

    public function test_it_rejects_metadata_lists_with_non_scalars(): void
    {
        $this->expectException(InvalidArgumentException::class);
        new VectorNamespace('docs', metadata: ['tags' => ['primary', ['bad']]]);
    }

    public function test_it_accepts_scalar_metadata_lists(): void
    {
        $namespace = new VectorNamespace('docs', metadata: ['tags' => ['primary', 'beta']]);
        self::assertSame(['tags' => ['primary', 'beta']], $namespace->getMetadata());
    }
}
</document_content>
</document>

<document index="143">
<source>tests/VectorStore/WeaviateVectorStoreTest.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/VectorStore/WeaviateVectorStoreTest.php

namespace ParaGra\Tests\VectorStore;

use GuzzleHttp\Client;
use GuzzleHttp\Handler\MockHandler;
use GuzzleHttp\HandlerStack;
use GuzzleHttp\Middleware;
use GuzzleHttp\Psr7\Response;
use ParaGra\Response\UnifiedResponse;
use ParaGra\VectorStore\VectorNamespace;
use ParaGra\VectorStore\WeaviateVectorStore;
use PHPUnit\Framework\TestCase;
use RuntimeException;
use ReflectionClass;

use const JSON_THROW_ON_ERROR;

/**
 * @covers \ParaGra\VectorStore\WeaviateVectorStore
 */
final class WeaviateVectorStoreTest extends TestCase
{
    public function testUpsertSendsBatchPayloadWithTenant(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'results' => ['objects' => [], 'successfullyProcessed' => 2],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);

        $namespace = new VectorNamespace('kb', collection: 'Articles', metadata: ['tenant' => 'tenant-b']);
        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            apiKey: 'secret',
            defaultNamespace: $namespace,
            consistencyLevel: 'QUORUM',
            defaultProperties: ['text'],
            httpClient: $client,
        );

        $records = [
            [
                'id' => 'chunk-1',
                'values' => [0.1, 0.2],
                'metadata' => ['text' => 'Chunk one', 'source' => 'kb'],
            ],
            [
                'id' => 'chunk-2',
                'values' => [0.3, 0.4],
                'metadata' => ['text' => 'Chunk two'],
            ],
        ];

        $result = $store->upsert($namespace, $records, ['consistency_level' => 'ALL']);

        self::assertSame(['upserted' => 2, 'updated' => 0], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('POST', $request->getMethod());
        self::assertSame('/v1/batch/objects', $request->getUri()->getPath());
        self::assertSame('consistency_level=ALL', $request->getUri()->getQuery());
        self::assertSame('Bearer secret', $request->getHeaderLine('Authorization'));
        self::assertSame('tenant-b', $request->getHeaderLine('X-Weaviate-Tenant'));

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertArrayHasKey('objects', $payload);
        self::assertCount(2, $payload['objects']);
        self::assertSame('Articles', $payload['objects'][0]['class']);
        self::assertSame('tenant-b', $payload['objects'][0]['tenant']);
        self::assertSame([0.1, 0.2], $payload['objects'][0]['vector']);
        self::assertSame(['text' => 'Chunk one', 'source' => 'kb'], $payload['objects'][0]['properties']);
    }

    public function testDeleteBuildsBatchDeletePayload(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'results' => ['successful' => 2],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);

        $namespace = new VectorNamespace('kb', collection: 'Articles', metadata: ['tenant' => 'tenant-c']);
        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            defaultNamespace: $namespace,
            defaultProperties: ['text'],
            httpClient: $client,
        );

        $result = $store->delete($namespace, ['chunk-1', 'chunk-2']);

        self::assertSame(['deleted' => 2], $result);
        self::assertCount(1, $history);

        $request = $history[0]['request'];
        self::assertSame('DELETE', $request->getMethod());
        self::assertSame('/v1/batch/objects', $request->getUri()->getPath());
        self::assertSame('tenant-c', $request->getHeaderLine('X-Weaviate-Tenant'));

        $payload = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('Articles', $payload['match']['class']);
        self::assertSame(['id'], $payload['match']['where']['path']);
        self::assertSame('ContainsAny', $payload['match']['where']['operator']);
        self::assertSame(['chunk-1', 'chunk-2'], $payload['match']['where']['valueStringArray']);
    }

    public function testQueryCreatesUnifiedResponseFromGraphql(): void
    {
        $history = [];
        $graphqlResponse = [
            'data' => [
                'Get' => [
                    'Articles' => [
                        [
                            'text' => 'Chunk one',
                            'title' => 'Doc 1',
                            'source' => 'kb',
                            '_additional' => [
                                'id' => 'chunk-1',
                                'distance' => 0.2,
                                'score' => 0.8,
                                'vector' => [0.5, 0.6],
                            ],
                        ],
                        [
                            'text' => 'Chunk two',
                            '_additional' => [
                                'id' => 'chunk-2',
                                'certainty' => 0.65,
                            ],
                        ],
                    ],
                ],
            ],
        ];

        $mock = new MockHandler([
            new Response(200, [], json_encode($graphqlResponse, JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);

        $namespace = new VectorNamespace('kb', collection: 'Articles', metadata: [
            'tenant' => 'tenant-d',
            'source' => 'docs',
        ]);

        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            defaultNamespace: $namespace,
            defaultProperties: ['text', 'title', 'source'],
            httpClient: $client,
        );

        $vector = [0.11, 0.22, 0.33];
        $response = $store->query($namespace, $vector, ['top_k' => 2, 'include_vectors' => true]);

        self::assertInstanceOf(UnifiedResponse::class, $response);
        self::assertSame('weaviate', $response->getProvider());
        self::assertSame('Articles', $response->getModel());
        self::assertCount(2, $response->getChunks());

        $chunks = $response->getChunks();
        self::assertSame('Chunk one', $chunks[0]['text']);
        self::assertSame('chunk-1', $chunks[0]['document_id']);
        self::assertSame(0.8, $chunks[0]['score']);
        self::assertSame('Doc 1', $chunks[0]['document_name']);
        self::assertSame(['source' => 'kb'], $chunks[0]['metadata']);

        self::assertSame('Chunk two', $chunks[1]['text']);
        self::assertSame('chunk-2', $chunks[1]['document_id']);
        self::assertSame(0.65, $chunks[1]['score']);

        self::assertCount(1, $history);
        $request = $history[0]['request'];
        self::assertSame('POST', $request->getMethod());
        self::assertSame('/v1/graphql', $request->getUri()->getPath());
        $body = json_decode((string) $request->getBody(), true, 512, JSON_THROW_ON_ERROR);

        self::assertIsString($body['query']);
        self::assertStringContainsString('Articles', $body['query']);
        self::assertStringContainsString('nearVector', $body['query']);
        self::assertStringContainsString('_additional', $body['query']);
        self::assertStringContainsString('vector', $body['query']);

        $variables = $body['variables'];
        self::assertSame($vector, $variables['vector']);
        self::assertSame('tenant-d', $variables['tenant']);
        self::assertSame('ONE', $variables['consistency']);
        self::assertSame([
            'operator' => 'And',
            'operands' => [
                [
                    'path' => ['source'],
                    'operator' => 'Equal',
                    'valueText' => 'docs',
                ],
            ],
        ], $variables['where']);
    }

    public function testDeleteWithSingleIdUsesEqualOperator(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'results' => ['successfullyDeleted' => 1],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);
        $namespace = new VectorNamespace('kb', collection: 'Articles');
        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );

        $result = $store->delete($namespace, ['chunk-1']);

        self::assertSame(['deleted' => 1], $result);
        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('Equal', $payload['match']['where']['operator']);
        self::assertSame('chunk-1', $payload['match']['where']['valueText']);
    }

    public function testQueryThrowsWhenGraphqlReturnsErrors(): void
    {
        $mock = new MockHandler([
            new Response(200, [], json_encode(['errors' => [['message' => 'graphql boom']]], JSON_THROW_ON_ERROR)),
        ]);
        $client = new Client(['handler' => HandlerStack::create($mock), 'base_uri' => 'https://example.weaviate.network/v1/']);

        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', collection: 'Articles');

        $this->expectException(RuntimeException::class);
        $this->expectExceptionMessage('GraphQL query failed');
        $store->query($namespace, [0.1, 0.2], ['query' => 'What is ParaGra?']);
    }

    public function testQueryBuildsMetadataFiltersForListValues(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['data' => ['Get' => ['Articles' => []]]], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);

        $namespace = new VectorNamespace(
            name: 'kb',
            collection: 'Articles',
            metadata: [
                'tenant' => 'tenant-y',
                'labels' => ['kb', 'manual'],
                'priority' => [1, 2],
                'boost' => [0.4],
                'active' => [true],
            ]
        );

        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );

        $store->query($namespace, [0.11, 0.22], ['top_k' => 1]);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        $where = $payload['variables']['where'];

        self::assertSame('And', $where['operator']);
        $operands = $where['operands'];
        self::assertContains(['path' => ['labels'], 'operator' => 'ContainsAny', 'valueStringArray' => ['kb', 'manual']], $operands);
        self::assertContains(['path' => ['priority'], 'operator' => 'ContainsAny', 'valueIntArray' => [1, 2]], $operands);
        self::assertContains(['path' => ['boost'], 'operator' => 'ContainsAny', 'valueNumberArray' => [0.4]], $operands);
        self::assertContains(['path' => ['active'], 'operator' => 'ContainsAny', 'valueBooleanArray' => [true]], $operands);
    }

    public function testConstructorRejectsEmptyBaseUrl(): void
    {
        $this->expectException(RuntimeException::class);
        new WeaviateVectorStore(baseUrl: '   ', className: 'Articles');
    }

    public function testUpsertIgnoresBlankConsistencyLevel(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode([
                'results' => ['objects' => [], 'successfullyProcessed' => 1],
            ], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);
        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', collection: 'Articles');
        $store->upsert($namespace, [
            ['id' => 'doc-1', 'values' => [0.1], 'metadata' => ['text' => 'chunk']],
        ], ['consistency_level' => ' ']);

        self::assertSame('', $history[0]['request']->getUri()->getQuery());
    }

    public function testQueryTrimsConsistencyOverrides(): void
    {
        $history = [];
        $mock = new MockHandler([
            new Response(200, [], json_encode(['data' => ['Get' => ['Articles' => []]]], JSON_THROW_ON_ERROR)),
        ]);
        $handler = HandlerStack::create($mock);
        $handler->push(Middleware::history($history));

        $client = new Client(['handler' => $handler, 'base_uri' => 'https://example.weaviate.network/v1/']);
        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );
        $namespace = new VectorNamespace('kb', collection: 'Articles');

        $store->query($namespace, [0.1], ['query' => 'Hi', 'consistency_level' => '  QUORUM ']);

        $payload = json_decode((string) $history[0]['request']->getBody(), true, 512, JSON_THROW_ON_ERROR);
        self::assertSame('QUORUM', $payload['variables']['consistency']);
    }

    public function testSanitizePropertiesRemovesDuplicates(): void
    {
        $store = new WeaviateVectorStore('https://example.weaviate.network', 'Articles');
        $ref = new ReflectionClass($store);
        $method = $ref->getMethod('sanitizeProperties');
        $method->setAccessible(true);

        /** @var array<int, string> $sanitized */
        $sanitized = $method->invoke($store, [' title ', '', 'text', 'title', 42]);

        self::assertSame(['title', 'text'], $sanitized);
    }

    public function testRequestWrapsHttpExceptions(): void
    {
        $mock = new MockHandler([
            new \GuzzleHttp\Exception\RequestException('boom', new \GuzzleHttp\Psr7\Request('GET', 'test')),
        ]);
        $client = new Client(['handler' => HandlerStack::create($mock), 'base_uri' => 'https://example.weaviate.network/v1/']);

        $store = new WeaviateVectorStore(
            baseUrl: 'https://example.weaviate.network',
            className: 'Articles',
            httpClient: $client,
        );

        $namespace = new VectorNamespace('kb', collection: 'Articles');
        $this->expectException(RuntimeException::class);
        $store->query($namespace, [0.1], ['query' => 'Hello']);
    }
}
</document_content>
</document>

<document index="144">
<source>tests/bootstrap.php</source>
<document_content>
<?php

declare(strict_types=1);

// this_file: paragra-php/tests/bootstrap.php

$autoload = __DIR__ . '/../vendor/autoload.php';
if (! is_file($autoload)) {
    throw new RuntimeException('Composer autoload not found at ' . $autoload);
}

require_once $autoload;

if (class_exists(DG\BypassFinals::class)) {
    DG\BypassFinals::enable();
}
</document_content>
</document>

<document index="145">
<source>tools/pool_builder.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/tools/pool_builder.php

use ParaGra\Planner\PoolBuilder;
use ParaGra\ProviderCatalog\ProviderDiscovery;

require __DIR__ . '/../vendor/autoload.php';

const PB_JSON_FLAGS = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES;

$options = getopt('', ['preset::', 'catalog::', 'format::', 'output::']);

$preset = isset($options['preset']) ? (string) $options['preset'] : PoolBuilder::PRESET_FREE;
$catalogPath = isset($options['catalog'])
    ? (string) $options['catalog']
    : __DIR__ . '/../config/providers/catalog.php';
$format = isset($options['format']) ? strtolower((string) $options['format']) : 'php';
$outputPath = isset($options['output']) ? (string) $options['output'] : null;

try {
    $catalog = ProviderDiscovery::fromFile($catalogPath);
    $builder = PoolBuilder::fromGlobals($catalog);
    $priorityPools = $builder->build($preset);
} catch (Throwable $exception) {
    fwrite(STDERR, $exception->getMessage() . PHP_EOL);
    exit(1);
}

$payload = [
    'provider_catalog' => $catalogPath,
    'priority_pools' => $priorityPools,
];

if ($format === 'json') {
    $contents = json_encode($payload, PB_JSON_FLAGS) . PHP_EOL;
} elseif ($format === 'php') {
    $contents = "<?php\n\ndeclare(strict_types=1);\n\nreturn " . var_export($payload, true) . ";\n";
} else {
    fwrite(STDERR, sprintf('Unsupported format "%s". Use "php" or "json".', $format) . PHP_EOL);
    exit(1);
}

if ($outputPath !== null) {
    if (file_put_contents($outputPath, $contents) === false) {
        fwrite(STDERR, sprintf('Unable to write pools to %s', $outputPath) . PHP_EOL);
        exit(1);
    }

    exit(0);
}

fwrite(STDOUT, $contents);
</document_content>
</document>

<document index="146">
<source>tools/provider_catalog.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/tools/provider_catalog.php

use ParaGra\ReferenceCatalog\ProviderCatalogBuilder;

require __DIR__ . '/../vendor/autoload.php';

const JSON_FLAGS = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES;

$argv = $_SERVER['argv'] ?? [];
$command = $argv[1] ?? 'build';
$options = getopt('', ['project-root::', 'source::', 'output::', 'catalog::']);

$defaultRoot = dirname(__DIR__, 2);
$projectRoot = isset($options['project-root']) ? (string) $options['project-root'] : $defaultRoot;
$builder = new ProviderCatalogBuilder($projectRoot);

switch ($command) {
    case 'build':
        $source = isset($options['source'])
            ? (string) $options['source']
            : $projectRoot . '/reference/catalog/provider_insights.source.json';
        $output = isset($options['output'])
            ? (string) $options['output']
            : $projectRoot . '/reference/catalog/provider_insights.json';

        $catalog = $builder->buildFromSource($source);
        $json = json_encode($catalog, JSON_FLAGS) . "\n";
        if ($json === false) {
            fwrite(STDERR, "Failed to encode provider catalog." . PHP_EOL);
            exit(1);
        }

        if (file_put_contents($output, $json) === false) {
            fwrite(STDERR, sprintf('Unable to write catalog to %s', $output) . PHP_EOL);
            exit(1);
        }

        fwrite(
            STDOUT,
            sprintf('Wrote %d provider entries to %s' . PHP_EOL, $catalog['__meta__']['provider_count'] ?? 0, $output)
        );

        break;

    case 'verify':
        $catalogPath = isset($options['catalog'])
            ? (string) $options['catalog']
            : $projectRoot . '/reference/catalog/provider_insights.json';

        if (!is_file($catalogPath)) {
            fwrite(STDERR, sprintf('Catalog file %s not found.' . PHP_EOL, $catalogPath));
            exit(1);
        }

        $contents = file_get_contents($catalogPath);
        if ($contents === false) {
            fwrite(STDERR, sprintf('Unable to read catalog file %s.' . PHP_EOL, $catalogPath));
            exit(1);
        }

        $catalog = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);
        $errors = $builder->verifyCatalog($catalog);
        if ($errors !== []) {
            foreach ($errors as $error) {
                fwrite(STDERR, $error . PHP_EOL);
            }

            exit(1);
        }

        fwrite(STDOUT, 'Catalog hashes match referenced sources.' . PHP_EOL);
        break;

    default:
        fwrite(STDERR, "Usage: provider_catalog.php [build|verify] [--project-root=path]" . PHP_EOL);
        exit(1);
}
</document_content>
</document>

<document index="147">
<source>tools/sync_provider_catalog.php</source>
<document_content>
#!/usr/bin/env php
<?php

declare(strict_types=1);

// this_file: paragra-php/tools/sync_provider_catalog.php

const JSON_FLAGS = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES;

$rootDir = dirname(__DIR__);
$options = getopt('', ['source::', 'output::', 'insights::', 'quiet']);

$sourcePath = isset($options['source']) ? (string) $options['source'] : $rootDir . '/../vexy-co-model-catalog';
$outputPath = isset($options['output']) ? (string) $options['output'] : $rootDir . '/config/providers';
$insightsPath = isset($options['insights']) ? (string) $options['insights'] : $sourcePath . '/config/provider_insights.json';
$quiet = isset($options['quiet']);

if (!is_dir($sourcePath)) {
    fail(sprintf('Source path "%s" does not exist. Pass --source to override.', $sourcePath));
}

$modelsPath = $sourcePath . '/models';
$dumpScriptPath = $sourcePath . '/external/dump_models.py';

$providerConfigs = parseProviderConfigs($dumpScriptPath);
$modelData = loadModelFiles($modelsPath);
$presets = capabilityPresets();
$insights = loadProviderInsights($insightsPath);
$insightMap = insightMappings();
$catalog = buildCatalog($sourcePath, $providerConfigs, $modelData, $presets, $insights, $insightMap);

if (!is_dir($outputPath) && !mkdir($outputPath, 0775, true) && !is_dir($outputPath)) {
    fail(sprintf('Unable to create output directory "%s".', $outputPath));
}

writeCatalogFiles($outputPath, $catalog);

if (!$quiet) {
    fwrite(
        STDOUT,
        sprintf(
            "Synced %d provider entries into %s\n",
            count($catalog['providers']),
            $outputPath
        )
    );
}

/**
 * @return array<string, array{api_key_env: string|null, base_url: string|null}>
 */
function parseProviderConfigs(string $dumpScriptPath): array
{
    if (!is_file($dumpScriptPath)) {
        fwrite(
            STDERR,
            sprintf("Warning: provider config source %s not found; relying on presets only.\n", $dumpScriptPath)
        );

        return [];
    }

    $contents = file_get_contents($dumpScriptPath);
    if ($contents === false) {
        throw new RuntimeException(sprintf('Unable to read provider config file "%s".', $dumpScriptPath));
    }

    $urlMap = parseKeyValueBlock($contents, 'PROVIDER_URL_CONFIG');
    $providerLines = parseListBlock($contents, 'PROVIDER_CONFIG');

    $providers = [];
    foreach ($providerLines as $line) {
        $parts = array_map('trim', explode(',', $line));
        if (count($parts) !== 4) {
            continue;
        }

        [$name, /* kind */, $apiEnv, $urlEnv] = $parts;
        $urlEnv = $urlEnv !== '' ? $urlEnv : null;
        $baseUrl = $urlEnv && isset($urlMap[$urlEnv]) ? rtrim($urlMap[$urlEnv], '/') : null;

        if ($baseUrl !== null && str_ends_with($baseUrl, '/models')) {
            $baseUrl = rtrim(substr($baseUrl, 0, -7), '/');
        }

        $providers[$name] = [
            'api_key_env' => $apiEnv !== '' ? $apiEnv : null,
            'base_url' => $baseUrl,
        ];
    }

    return $providers;
}

/**
 * @return array<string, string>
 */
function parseKeyValueBlock(string $contents, string $identifier): array
{
    $lines = parseListBlock($contents, $identifier);
    $map = [];
    foreach ($lines as $line) {
        $parts = array_map('trim', explode(',', $line));
        if (count($parts) !== 2) {
            continue;
        }
        $map[$parts[0]] = $parts[1];
    }

    return $map;
}

/**
 * @return list<string>
 */
function parseListBlock(string $contents, string $identifier): array
{
    $pattern = sprintf('/%s\s*=\s*"""\s*(.*?)\s*"""\.strip/s', preg_quote($identifier, '/'));
    if (!preg_match($pattern, $contents, $matches)) {
        return [];
    }

    $block = trim($matches[1]);
    if ($block === '') {
        return [];
    }

    $lines = array_map('trim', explode("\n", $block));

    return array_values(array_filter($lines, static fn (string $line): bool => $line !== ''));
}

/**
 * @return array<string, array{ids: list<string>, raw: mixed}>
 */
function loadModelFiles(string $modelsPath): array
{
    if (!is_dir($modelsPath)) {
        fwrite(STDERR, sprintf("Warning: models directory %s not found; skipping model ingestion.\n", $modelsPath));

        return [];
    }

    $files = glob($modelsPath . '/*.json') ?: [];
    $result = [];
    foreach ($files as $file) {
        $slug = basename($file, '.json');
        $contents = file_get_contents($file);
        if ($contents === false) {
            fwrite(STDERR, sprintf("Warning: unable to read model file %s.\n", $file));
            continue;
        }

        try {
            $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);
        } catch (Throwable $e) {
            fwrite(STDERR, sprintf("Warning: invalid JSON in %s (%s).\n", $file, $e->getMessage()));
            continue;
        }

        $ids = extractModelIds($decoded);
        sort($ids, SORT_NATURAL | SORT_FLAG_CASE);

        $result[$slug] = [
            'ids' => $ids,
            'raw' => $decoded,
        ];
    }

    return $result;
}

/**
 * @param mixed $decoded
 * @return list<string>
 */
function extractModelIds(mixed $decoded): array
{
    if (is_array($decoded)) {
        if (isset($decoded['data']) && is_array($decoded['data'])) {
            $ids = [];
            foreach ($decoded['data'] as $row) {
                if (is_array($row) && isset($row['id']) && is_string($row['id'])) {
                    $ids[] = $row['id'];
                }
            }

            return $ids;
        }

        $ids = [];
        foreach ($decoded as $key => $value) {
            if ($key === 'sample_spec') {
                continue;
            }
            if (is_string($key) && $key !== '') {
                $ids[] = $key;
            } elseif (is_array($value) && isset($value['id']) && is_string($value['id'])) {
                $ids[] = $value['id'];
            }
        }

        return $ids;
    }

    return [];
}

/**
 * @param array<string, array{api_key_env: string|null, base_url: string|null}> $providerConfigs
 * @param array<string, array{ids: list<string>, raw: mixed}> $modelData
 * @param array<string, array<string, mixed>> $presets
 * @param array<string, array<string, mixed>> $insights
 * @param array<string, list<string>> $insightMap
 *
 * @return array{
 *     generated_at: string,
 *     source: string,
 *     providers: list<array{
 *         slug: string,
 *         display_name: string,
 *         description: string,
 *         api_key_env: string|null,
 *         base_url: string|null,
 *         capabilities: array<string, bool>,
 *         model_count: int,
 *         models: list<string>,
 *         embedding_dimensions: array<string, int>,
 *         preferred_vector_store: string|null,
 *         default_models: array<string, string>,
 *         default_solution: array<string, mixed>|null,
 *         metadata: array<string, mixed>
 *     }>
 * }
 */
function buildCatalog(
    string $sourcePath,
    array $providerConfigs,
    array $modelData,
    array $presets,
    array $insights,
    array $insightMap
): array {
    $slugs = array_unique(array_merge(array_keys($providerConfigs), array_keys($modelData), array_keys($presets)));
    sort($slugs);

    $providers = [];
    foreach ($slugs as $slug) {
        $meta = $providerConfigs[$slug] ?? ['api_key_env' => null, 'base_url' => null];
        $preset = $presets[$slug] ?? [];
        $models = $modelData[$slug]['ids'] ?? [];

        $providers[] = [
            'slug' => $slug,
            'display_name' => (string) ($preset['display_name'] ?? ucfirst($slug)),
            'description' => (string) ($preset['description'] ?? ''),
            'api_key_env' => $preset['api_key_env'] ?? $meta['api_key_env'],
            'base_url' => $preset['base_url'] ?? $meta['base_url'],
            'capabilities' => buildCapabilityMap($preset['capabilities'] ?? []),
            'model_count' => count($models),
            'models' => $models,
            'embedding_dimensions' => $preset['embedding_dimensions'] ?? [],
            'preferred_vector_store' => $preset['preferred_vector_store'] ?? null,
            'default_models' => $preset['recommended_models'] ?? [],
            'default_solution' => $preset['default_solution'] ?? null,
            'metadata' => applyInsightMetadata(
                $slug,
                $preset['metadata'] ?? [],
                $insights,
                $insightMap
            ),
        ];
    }

    return [
        'generated_at' => (new DateTimeImmutable())->format(DATE_ATOM),
        'source' => realpath($sourcePath) ?: $sourcePath,
        'providers' => $providers,
    ];
}

/**
 * @param array<string, mixed> $capabilities
 * @return array<string, bool>
 */
function buildCapabilityMap(array $capabilities): array
{
    $defaults = [
        'llm_chat' => false,
        'embeddings' => false,
        'vector_store' => false,
        'moderation' => false,
        'image_generation' => false,
        'byok' => false,
    ];

    foreach ($defaults as $key => $value) {
        if (array_key_exists($key, $capabilities)) {
            $defaults[$key] = (bool) $capabilities[$key];
        }
    }

    return $defaults;
}

/**
 * @return array<string, array<string, mixed>>
 */
function capabilityPresets(): array
{
    return [
        'askyoda' => [
            'display_name' => 'EdenAI AskYoda',
            'description' => 'Full retrieval + answer pipeline via EdenAI AskYoda.',
            'api_key_env' => 'EDENAI_API_KEY',
            'base_url' => 'https://api.edenai.run/v2',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => false,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'recommended_models' => [
                'generation' => 'askyoda:gemini-2.5-flash-lite',
            ],
            'preferred_vector_store' => 'askyoda',
            'default_solution' => [
                'type' => 'askyoda',
                'defaults' => [
                    'k' => 10,
                    'min_score' => 0.3,
                ],
            ],
            'metadata' => [
                'tier' => 'hosted',
                'latency' => 'medium',
                'latency_tier' => 'hosted',
            ],
        ],
        'cloudflare' => [
            'display_name' => 'Cloudflare Workers AI',
            'description' => 'Edge-hosted inference with EmbeddingGemma and 10k neuron daily renewals.',
            'api_key_env' => 'CLOUDFLARE_API_TOKEN',
            'base_url' => 'https://api.cloudflare.com/client/v4',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => true,
            ],
            'recommended_models' => [
                'generation' => '@cf/meta/llama-3.1-8b-instruct',
                'embedding' => '@cf/google/gemma-embedding-002',
            ],
            'preferred_vector_store' => 'workers-ai',
            'metadata' => [
                'tier' => 'free',
                'latency' => 'low',
            ],
        ],
        'dify' => [
            'display_name' => 'Dify Orchestrator',
            'description' => 'Self-hostable RAG + automation builder with visual flows.',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => true,
            ],
            'default_solution' => [
                'type' => 'dify',
            ],
            'metadata' => [
                'tier' => 'self_hosted',
                'latency' => 'dependent',
            ],
        ],
        'cerebras' => [
            'display_name' => 'Cerebras',
            'description' => 'Fast, low-cost Llama-3.3 hosting and generous free tier.',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => false,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'recommended_models' => [
                'generation' => 'llama-3.3-70b',
                'fast_generation' => 'llama-3.1-8b',
            ],
            'preferred_vector_store' => 'ragie',
            'default_solution' => [
                'type' => 'ragie',
                'ragie_partition' => 'default',
                'metadata' => ['tier' => 'free'],
            ],
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'gemini' => [
            'display_name' => 'Google Gemini',
            'description' => 'Gemini API with File Search and text-embedding-004.',
            'base_url' => 'https://generativelanguage.googleapis.com/v1beta/openai',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => true,
                'byok' => true,
            ],
            'embedding_dimensions' => [
                'text-embedding-004' => 3072,
            ],
            'recommended_models' => [
                'generation' => 'gemini-2.0-flash-exp',
                'embedding' => 'text-embedding-004',
            ],
            'preferred_vector_store' => 'gemini-file-search',
            'default_solution' => [
                'type' => 'gemini-file-search',
                'vector_store' => [
                    'corpus' => 'default',
                ],
            ],
            'metadata' => [
                'tier' => 'paid',
                'latency' => 'medium',
            ],
        ],
        'groq' => [
            'display_name' => 'Groq',
            'description' => 'Ultra-low latency OpenAI-compatible endpoint for Llama/Mixtral.',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => false,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => true,
            ],
            'recommended_models' => [
                'generation' => 'llama-3.1-70b-versatile',
                'fast_generation' => 'llama-3.1-8b-instant',
            ],
            'preferred_vector_store' => 'ragie',
            'metadata' => [
                'tier' => 'free',
                'latency' => 'low',
            ],
        ],
        'mistral' => [
            'display_name' => 'Mistral AI',
            'description' => 'La Plateforme access to Mixtral + Large models under the experiment tier.',
            'api_key_env' => 'MISTRAL_API_KEY',
            'base_url' => 'https://api.mistral.ai/v1',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'recommended_models' => [
                'generation' => 'mistral-large-latest',
                'fast_generation' => 'mistral-small-latest',
                'embedding' => 'mistral-embed',
            ],
            'preferred_vector_store' => 'ragie',
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'openrouter' => [
            'display_name' => 'OpenRouter',
            'description' => 'Router for 60+ hosted LLMs with renewable communal credits.',
            'api_key_env' => 'OPENROUTER_API_KEY',
            'base_url' => 'https://openrouter.ai/api/v1',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => false,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => true,
            ],
            'recommended_models' => [
                'generation' => 'meta-llama/llama-3.1-70b-instruct',
                'fast_generation' => 'qwen/qwen-2.5-14b-instruct',
            ],
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'pinecone' => [
            'display_name' => 'Pinecone',
            'description' => 'Managed vector store with starter pods for prototypes.',
            'api_key_env' => 'PINECONE_API_KEY',
            'base_url' => 'https://controller.us-east1-gcp.pinecone.io',
            'capabilities' => [
                'llm_chat' => false,
                'embeddings' => false,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'preferred_vector_store' => 'pinecone',
            'default_solution' => [
                'type' => 'pinecone',
            ],
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'qdrant' => [
            'display_name' => 'Qdrant Serverless',
            'description' => 'Fully-managed vector store with forever-free tier.',
            'api_key_env' => 'QDRANT_API_KEY',
            'base_url' => 'https://api.qdrant.tech',
            'capabilities' => [
                'llm_chat' => false,
                'embeddings' => false,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'preferred_vector_store' => 'qdrant',
            'default_solution' => [
                'type' => 'qdrant',
            ],
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'openai' => [
            'display_name' => 'OpenAI',
            'description' => 'Flagship GPT-4o/4.1 models plus moderation + embeddings.',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => true,
                'image_generation' => true,
                'byok' => false,
            ],
            'embedding_dimensions' => [
                'text-embedding-3-small' => 1536,
                'text-embedding-3-large' => 3072,
            ],
            'recommended_models' => [
                'generation' => 'gpt-4o-mini',
                'fast_generation' => 'gpt-4o-mini',
                'embedding' => 'text-embedding-3-small',
                'moderation' => 'omni-moderation-latest',
            ],
            'preferred_vector_store' => 'ragie',
            'default_solution' => [
                'type' => 'ragie',
                'ragie_partition' => 'default',
                'default_options' => [
                    'top_k' => 8,
                    'rerank' => true,
                ],
            ],
            'metadata' => [
                'tier' => 'paid',
                'latency' => 'medium',
            ],
        ],
        'voyage' => [
            'display_name' => 'Voyage AI',
            'description' => 'High-quality embeddings + rerankers tuned for reasoning tasks.',
            'api_key_env' => 'VOYAGE_API_KEY',
            'base_url' => 'https://api.voyageai.com/v1',
            'capabilities' => [
                'llm_chat' => false,
                'embeddings' => true,
                'vector_store' => false,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'embedding_dimensions' => [
                'voyage-3-large' => 3072,
            ],
            'recommended_models' => [
                'embedding' => 'voyage-3-large',
            ],
            'metadata' => [
                'tier' => 'free',
                'latency' => 'medium',
            ],
        ],
        'vectara' => [
            'display_name' => 'Vectara',
            'description' => 'Managed RAG stack with ingestion, hallucination defense, and Cerebras/OpenAI routing.',
            'capabilities' => [
                'llm_chat' => true,
                'embeddings' => true,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'metadata' => [
                'tier' => 'hosted',
                'latency' => 'medium',
            ],
        ],
        'bedrock-kb' => [
            'display_name' => 'AWS Bedrock Knowledge Bases',
            'description' => 'Managed retrieval layer that pairs OpenSearch Serverless with AWS-hosted LLMs.',
            'capabilities' => [
                'llm_chat' => false,
                'embeddings' => false,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => true,
            ],
            'metadata' => [
                'tier' => 'managed',
                'latency' => 'dependent',
            ],
        ],
        'ragie' => [
            'display_name' => 'Ragie',
            'description' => 'Primary retrieval layer powering ParaGra.',
            'api_key_env' => 'RAGIE_API_KEY',
            'base_url' => 'https://api.ragie.ai',
            'capabilities' => [
                'llm_chat' => false,
                'embeddings' => false,
                'vector_store' => true,
                'moderation' => false,
                'image_generation' => false,
                'byok' => false,
            ],
            'preferred_vector_store' => 'ragie',
            'metadata' => [
                'tier' => 'paid',
                'latency' => 'medium',
            ],
        ],
    ];
}

/**
 * @return array<string, array<string, mixed>>
 */
function loadProviderInsights(?string $path): array
{
    if ($path === null || trim($path) === '') {
        return [];
    }

    if (!is_file($path)) {
        fwrite(STDERR, sprintf("Warning: provider insights file %s not found.\n", $path));

        return [];
    }

    $contents = file_get_contents($path);
    if ($contents === false) {
        fwrite(STDERR, sprintf("Warning: unable to read provider insights file %s.\n", $path));

        return [];
    }

    try {
        $decoded = json_decode($contents, true, 512, JSON_THROW_ON_ERROR);
    } catch (Throwable $exception) {
        fwrite(STDERR, sprintf("Warning: invalid JSON in %s (%s).\n", $path, $exception->getMessage()));

        return [];
    }

    if (!isset($decoded['providers']) || !is_array($decoded['providers'])) {
        fwrite(STDERR, sprintf("Warning: insights payload %s missing providers list.\n", $path));

        return [];
    }

    $index = [];
    foreach ($decoded['providers'] as $entry) {
        if (!is_array($entry) || !isset($entry['slug']) || !is_string($entry['slug']) || $entry['slug'] === '') {
            continue;
        }

        $index[$entry['slug']] = $entry;
    }

    return $index;
}

/**
 * @return array<string, list<string>>
 */
function insightMappings(): array
{
    return [
        'askyoda' => ['eden-askyoda'],
        'cloudflare' => ['cloudflare-workers-ai'],
        'dify' => ['dify-platform'],
        'gemini' => ['google-gemini-flash', 'google-gemini-embedding', 'google-gemini-file-search'],
        'groq' => ['groq-llama'],
        'mistral' => ['mistral-la-plateforme'],
        'openrouter' => ['openrouter'],
        'pinecone' => ['pinecone-starter'],
        'qdrant' => ['qdrant-cloud-free'],
        'voyage' => ['voyage-embeddings'],
        'vectara' => ['vectara-platform'],
        'bedrock-kb' => ['aws-bedrock-knowledge-bases'],
    ];
}

/**
 * @param array<string, mixed> $metadata
 * @param array<string, array<string, mixed>> $insights
 * @param array<string, list<string>> $insightMap
 * @return array<string, mixed>
 */
function applyInsightMetadata(
    string $slug,
    array $metadata,
    array $insights,
    array $insightMap
): array {
    $insightSlugs = $insightMap[$slug] ?? [];
    if ($insightSlugs === [] && isset($insights[$slug])) {
        $insightSlugs = [$slug];
    }

    $entries = [];
    foreach ($insightSlugs as $insightSlug) {
        if (!isset($insights[$insightSlug])) {
            continue;
        }

        $normalized = normalizeInsightEntry($insights[$insightSlug]);
        if ($normalized !== []) {
            $entries[$insightSlug] = $normalized;
        }
    }

    if ($entries !== []) {
        $metadata['insights'] = $entries;
    }

    return $metadata;
}

/**
 * @param array<string, mixed> $entry
 * @return array<string, mixed>
 */
function normalizeInsightEntry(array $entry): array
{
    if (!isset($entry['slug']) || !is_string($entry['slug']) || trim($entry['slug']) === '') {
        return [];
    }

    $normalized = [
        'slug' => trim((string) $entry['slug']),
    ];

    if (isset($entry['name']) && $entry['name'] !== '') {
        $normalized['name'] = (string) $entry['name'];
    }

    if (isset($entry['category']) && $entry['category'] !== '') {
        $normalized['category'] = (string) $entry['category'];
    }

    foreach (['reset_window', 'commercial_use', 'notes'] as $key) {
        if (isset($entry[$key]) && $entry[$key] !== '') {
            $normalized[$key] = (string) $entry[$key];
        }
    }

    $modalities = normalizeStringList($entry['modalities'] ?? []);
    if ($modalities !== []) {
        $normalized['modalities'] = $modalities;
    }

    $roles = normalizeStringList($entry['recommended_roles'] ?? []);
    if ($roles !== []) {
        $normalized['recommended_roles'] = $roles;
    }

    $freeTier = normalizeFreeTier($entry['free_quota'] ?? []);
    if ($freeTier !== []) {
        $normalized['free_tier'] = $freeTier;
    }

    if (isset($entry['sources']) && is_array($entry['sources'])) {
        $sources = [];
        foreach ($entry['sources'] as $source) {
            $normalizedSource = normalizeInsightSource($source);
            if ($normalizedSource !== null) {
                $sources[] = $normalizedSource;
            }
        }

        if ($sources !== []) {
            $normalized['sources'] = $sources;
        }
    }

    return $normalized;
}

/**
 * @param mixed $values
 * @return list<string>
 */
function normalizeStringList(mixed $values): array
{
    if (!is_array($values)) {
        return [];
    }

    $result = [];
    foreach ($values as $value) {
        if ($value === null) {
            continue;
        }

        $stringValue = trim((string) $value);
        if ($stringValue === '') {
            continue;
        }

        $result[] = $stringValue;
    }

    return array_values(array_unique($result));
}

/**
 * @param mixed $freeQuota
 * @return array<string, mixed>
 */
function normalizeFreeTier(mixed $freeQuota): array
{
    if (!is_array($freeQuota)) {
        return [];
    }

    $normalized = [];
    foreach ($freeQuota as $key => $value) {
        if ($key === 'models' && is_array($value)) {
            $models = [];
            foreach ($value as $row) {
                if (!is_array($row)) {
                    continue;
                }
                $modelEntry = [];
                if (isset($row['model']) && $row['model'] !== '') {
                    $modelEntry['model'] = (string) $row['model'];
                }
                foreach (['requests_per_day', 'requests_per_minute', 'tokens_per_minute'] as $metric) {
                    if (isset($row[$metric])) {
                        $modelEntry[$metric] = (int) $row[$metric];
                    }
                }

                if ($modelEntry !== []) {
                    $models[] = $modelEntry;
                }
            }

            if ($models !== []) {
                $normalized['models'] = $models;
            }
            continue;
        }

        if ($value === null || $value === '') {
            continue;
        }

        if (is_numeric($value)) {
            $normalized[(string) $key] = (int) $value;
        } else {
            $normalized[(string) $key] = $value;
        }
    }

    return $normalized;
}

/**
 * @param mixed $source
 * @return array<string, int|string>|null
 */
function normalizeInsightSource(mixed $source): ?array
{
    if (!is_array($source) || !isset($source['path']) || !is_string($source['path']) || $source['path'] === '') {
        return null;
    }

    $entry = [
        'path' => $source['path'],
    ];

    if (isset($source['sha256']) && is_string($source['sha256']) && $source['sha256'] !== '') {
        $entry['sha256'] = $source['sha256'];
    }

    if (isset($source['start_line'])) {
        $entry['start_line'] = (int) $source['start_line'];
    }

    if (isset($source['end_line'])) {
        $entry['end_line'] = (int) $source['end_line'];
    }

    return $entry;
}

function writeCatalogFiles(string $outputPath, array $catalog): void
{
    $json = json_encode($catalog, JSON_FLAGS);
    if ($json === false) {
        throw new RuntimeException('Failed to encode catalog JSON.');
    }

    $jsonPath = $outputPath . '/catalog.json';
    file_put_contents($jsonPath, $json . PHP_EOL);

    $phpPath = $outputPath . '/catalog.php';
    $php = <<<PHP
<?php

declare(strict_types=1);

// this_file: paragra-php/config/providers/catalog.php

return %s;

PHP;

    file_put_contents($phpPath, sprintf($php, var_export($catalog, true)));
}

function fail(string $message): void
{
    fwrite(STDERR, $message . PHP_EOL);
    exit(1);
}
</document_content>
</document>

</documents>